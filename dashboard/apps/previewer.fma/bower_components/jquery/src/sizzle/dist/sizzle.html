<!DOCTYPE html><html lang="en"><head><title>dashboard/apps/previewer.fma/bower_components/jquery/src/sizzle/dist/sizzle</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../../../../"><meta name="groc-document-path" content="dashboard/apps/previewer.fma/bower_components/jquery/src/sizzle/dist/sizzle"><meta name="groc-project-path" content="dashboard/apps/previewer.fma/bower_components/jquery/src/sizzle/dist/sizzle.js"><link rel="stylesheet" type="text/css" media="all" href="../../../../../../../../assets/style.css"><script type="text/javascript" src="../../../../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">dashboard/apps/previewer.fma/bower_components/jquery/src/sizzle/dist/sizzle.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-comment">/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> window </span>) </span>{

<span class="hljs-keyword">var</span> i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Local document vars</p></div></div><div class="code"><div class="wrapper">	setDocument,
	<span class="hljs-built_in">document</span>,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Instance-specific data</p></div></div><div class="code"><div class="wrapper">	expando = <span class="hljs-string">"sizzle"</span> + <span class="hljs-number">1</span> * <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
	preferredDoc = <span class="hljs-built_in">window</span>.document,
	dirruns = <span class="hljs-number">0</span>,
	done = <span class="hljs-number">0</span>,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> a, b </span>) </span>{
		<span class="hljs-keyword">if</span> ( a === b ) {
			hasDuplicate = <span class="hljs-literal">true</span>;
		}
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	},</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>General-purpose constants</p></div></div><div class="code"><div class="wrapper">	MAX_NEGATIVE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Instance methods</p></div></div><div class="code"><div class="wrapper">	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use a stripped-down indexOf as it&#39;s faster than native
<a href="http://jsperf.com/thor-indexof-vs-for/5">http://jsperf.com/thor-indexof-vs-for/5</a></p></div></div><div class="code"><div class="wrapper">	indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> list, elem </span>) </span>{
		<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
			len = list.length;
		<span class="hljs-keyword">for</span> ( ; i &lt; len; i++ ) {
			<span class="hljs-keyword">if</span> ( list[i] === elem ) {
				<span class="hljs-keyword">return</span> i;
			}
		}
		<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
	},

	booleans = <span class="hljs-string">"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped"</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Regular expressions</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Whitespace characters <a href="http://www.w3.org/TR/css3-selectors/#whitespace">http://www.w3.org/TR/css3-selectors/#whitespace</a></p></div></div><div class="code"><div class="wrapper">	whitespace = <span class="hljs-string">"[\\x20\\t\\r\\n\\f]"</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><a href="http://www.w3.org/TR/css3-syntax/#characters">http://www.w3.org/TR/css3-syntax/#characters</a></p></div></div><div class="code"><div class="wrapper">	characterEncoding = <span class="hljs-string">"(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+"</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Loosely modeled on CSS identifier characters
An unquoted value should be a CSS identifier <a href="http://www.w3.org/TR/css3-selectors/#attribute-selectors">http://www.w3.org/TR/css3-selectors/#attribute-selectors</a>
Proper syntax: <a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier</a></p></div></div><div class="code"><div class="wrapper">	identifier = characterEncoding.replace( <span class="hljs-string">"w"</span>, <span class="hljs-string">"w#"</span> ),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attribute selectors: <a href="http://www.w3.org/TR/selectors/#attribute-selectors">http://www.w3.org/TR/selectors/#attribute-selectors</a></p></div></div><div class="code"><div class="wrapper">	attributes = <span class="hljs-string">"\\["</span> + whitespace + <span class="hljs-string">"*("</span> + characterEncoding + <span class="hljs-string">")(?:"</span> + whitespace +</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Operator (capture 2)</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"*([*^$|!~]?=)"</span> + whitespace +</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>&quot;Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]&quot;</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("</span> + identifier + <span class="hljs-string">"))|)"</span> + whitespace +
		<span class="hljs-string">"*\\]"</span>,

	pseudos = <span class="hljs-string">":("</span> + characterEncoding + <span class="hljs-string">")(?:\\(("</span> +</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:</p>
<ol>
<li>quoted (capture 3; capture 4 or capture 5)</li>
</ol></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|"</span> +</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>simple (capture 6)</li>
</ol></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"((?:\\\\.|[^\\\\()[\\]]|"</span> + attributes + <span class="hljs-string">")*)|"</span> +</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>anything else (capture 2)</li>
</ol></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">".*"</span> +
		<span class="hljs-string">")\\)|)"</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter</p></div></div><div class="code"><div class="wrapper">	rwhitespace = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( whitespace + <span class="hljs-string">"+"</span>, <span class="hljs-string">"g"</span> ),
	rtrim = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"+|((?:^|[^\\\\])(?:\\\\.)*)"</span> + whitespace + <span class="hljs-string">"+$"</span>, <span class="hljs-string">"g"</span> ),

	rcomma = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"*,"</span> + whitespace + <span class="hljs-string">"*"</span> ),
	rcombinators = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"*([&gt;+~]|"</span> + whitespace + <span class="hljs-string">")"</span> + whitespace + <span class="hljs-string">"*"</span> ),

	rattributeQuotes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"="</span> + whitespace + <span class="hljs-string">"*([^\\]'\"]*?)"</span> + whitespace + <span class="hljs-string">"*\\]"</span>, <span class="hljs-string">"g"</span> ),

	rpseudo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( pseudos ),
	ridentifier = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^"</span> + identifier + <span class="hljs-string">"$"</span> ),

	matchExpr = {
		<span class="hljs-string">"ID"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^#("</span> + characterEncoding + <span class="hljs-string">")"</span> ),
		<span class="hljs-string">"CLASS"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^\\.("</span> + characterEncoding + <span class="hljs-string">")"</span> ),
		<span class="hljs-string">"TAG"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^("</span> + characterEncoding.replace( <span class="hljs-string">"w"</span>, <span class="hljs-string">"w*"</span> ) + <span class="hljs-string">")"</span> ),
		<span class="hljs-string">"ATTR"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^"</span> + attributes ),
		<span class="hljs-string">"PSEUDO"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^"</span> + pseudos ),
		<span class="hljs-string">"CHILD"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("</span> + whitespace +
			<span class="hljs-string">"*(even|odd|(([+-]|)(\\d*)n|)"</span> + whitespace + <span class="hljs-string">"*(?:([+-]|)"</span> + whitespace +
			<span class="hljs-string">"*(\\d+)|))"</span> + whitespace + <span class="hljs-string">"*\\)|)"</span>, <span class="hljs-string">"i"</span> ),
		<span class="hljs-string">"bool"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^(?:"</span> + booleans + <span class="hljs-string">")$"</span>, <span class="hljs-string">"i"</span> ),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For use in libraries implementing .is()
We use this for POS matching in <code>select</code></p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"needsContext"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("</span> +
			whitespace + <span class="hljs-string">"*((?:-\\d)?\\d*)"</span> + whitespace + <span class="hljs-string">"*\\)|)(?=[^-]|$)"</span>, <span class="hljs-string">"i"</span> )
	},

	rinputs = <span class="hljs-regexp">/^(?:input|select|textarea|button)$/i</span>,
	rheader = <span class="hljs-regexp">/^h\d$/i</span>,

	rnative = <span class="hljs-regexp">/^[^{]+\{\s*\[native \w/</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Easily-parseable/retrievable ID or TAG or CLASS selectors</p></div></div><div class="code"><div class="wrapper">	rquickExpr = <span class="hljs-regexp">/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/</span>,

	rsibling = <span class="hljs-regexp">/[+~]/</span>,
	rescape = <span class="hljs-regexp">/'|\\/g</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>CSS escapes <a href="http://www.w3.org/TR/CSS21/syndata.html#escaped-characters">http://www.w3.org/TR/CSS21/syndata.html#escaped-characters</a></p></div></div><div class="code"><div class="wrapper">	runescape = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"\\\\([\\da-f]{1,6}"</span> + whitespace + <span class="hljs-string">"?|("</span> + whitespace + <span class="hljs-string">")|.)"</span>, <span class="hljs-string">"ig"</span> ),
	funescape = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> _, escaped, escapedWhitespace </span>) </span>{
		<span class="hljs-keyword">var</span> high = <span class="hljs-string">"0x"</span> + escaped - <span class="hljs-number">0x10000</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>NaN means non-codepoint
Support: Firefox&lt;24
Workaround erroneous numeric interpretation of +&quot;0x&quot;</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> high !== high || escapedWhitespace ?
			escaped :
			high &lt; <span class="hljs-number">0</span> ?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>BMP codepoint</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-built_in">String</span>.fromCharCode( high + <span class="hljs-number">0x10000</span> ) :</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Supplemental Plane codepoint (surrogate pair)</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-built_in">String</span>.fromCharCode( high &gt;&gt; <span class="hljs-number">10</span> | <span class="hljs-number">0xD800</span>, high &amp; <span class="hljs-number">0x3FF</span> | <span class="hljs-number">0xDC00</span> );
	},</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used for iframes
See setDocument()
Removing the function wrapper causes a &quot;Permission Denied&quot;
error in IE</p></div></div><div class="code"><div class="wrapper">	unloadHandler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		setDocument();
	};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Optimize for push.apply( _, NodeList )</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">try</span> {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: Android&lt;4.0
Detect silently failing push.apply</p></div></div><div class="code"><div class="wrapper">	arr[ preferredDoc.childNodes.length ].nodeType;
} <span class="hljs-keyword">catch</span> ( e ) {
	push = { apply: arr.length ?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Leverage slice if possible</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> target, els </span>) </span>{
			push_native.apply( target, slice.call(els) );
		} :</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE&lt;9
Otherwise append directly</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> target, els </span>) </span>{
			<span class="hljs-keyword">var</span> j = target.length,
				i = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Can&#39;t trust NodeList.length</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">while</span> ( (target[j++] = els[i++]) ) {}
			target.length = j - <span class="hljs-number">1</span>;
		}
	};
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sizzle</span>(<span class="hljs-params"> selector, context, results, seed </span>) </span>{
	<span class="hljs-keyword">var</span> match, elem, m, nodeType,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>QSA vars</p></div></div><div class="code"><div class="wrapper">		i, groups, old, nid, newContext, newSelector;

	<span class="hljs-keyword">if</span> ( ( context ? context.ownerDocument || context : preferredDoc ) !== <span class="hljs-built_in">document</span> ) {
		setDocument( context );
	}

	context = context || <span class="hljs-built_in">document</span>;
	results = results || [];
	nodeType = context.nodeType;

	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> selector !== <span class="hljs-string">"string"</span> || !selector ||
		nodeType !== <span class="hljs-number">1</span> &amp;&amp; nodeType !== <span class="hljs-number">9</span> &amp;&amp; nodeType !== <span class="hljs-number">11</span> ) {

		<span class="hljs-keyword">return</span> results;
	}

	<span class="hljs-keyword">if</span> ( !seed &amp;&amp; documentIsHTML ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Try to shortcut find operations when possible (e.g., not under DocumentFragment)</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( nodeType !== <span class="hljs-number">11</span> &amp;&amp; (match = rquickExpr.exec( selector )) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Speed-up: Sizzle(&quot;#ID&quot;)</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( (m = match[<span class="hljs-number">1</span>]) ) {
				<span class="hljs-keyword">if</span> ( nodeType === <span class="hljs-number">9</span> ) {
					elem = context.getElementById( m );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check parentNode to catch when Blackberry 4.6 returns
nodes that are no longer in the document (jQuery #6963)</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( elem &amp;&amp; elem.parentNode ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Handle the case where IE, Opera, and Webkit return items
by name instead of ID</p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">if</span> ( elem.id === m ) {
							results.push( elem );
							<span class="hljs-keyword">return</span> results;
						}
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">return</span> results;
					}
				} <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Context is not a document</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById( m )) &amp;&amp;
						contains( context, elem ) &amp;&amp; elem.id === m ) {
						results.push( elem );
						<span class="hljs-keyword">return</span> results;
					}
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Speed-up: Sizzle(&quot;TAG&quot;)</p></div></div><div class="code"><div class="wrapper">			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( match[<span class="hljs-number">2</span>] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				<span class="hljs-keyword">return</span> results;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Speed-up: Sizzle(&quot;.CLASS&quot;)</p></div></div><div class="code"><div class="wrapper">			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( (m = match[<span class="hljs-number">3</span>]) &amp;&amp; support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				<span class="hljs-keyword">return</span> results;
			}
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>QSA path</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== <span class="hljs-number">1</span> &amp;&amp; selector;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>qSA works strangely on Element-rooted queries
We can work around this by specifying an extra ID on the root
and working up from there (Thanks to Andrew Dupont for the technique)
IE 8 doesn&#39;t work on object elements</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( nodeType === <span class="hljs-number">1</span> &amp;&amp; context.nodeName.toLowerCase() !== <span class="hljs-string">"object"</span> ) {
				groups = tokenize( selector );

				<span class="hljs-keyword">if</span> ( (old = context.getAttribute(<span class="hljs-string">"id"</span>)) ) {
					nid = old.replace( rescape, <span class="hljs-string">"\\$&amp;"</span> );
				} <span class="hljs-keyword">else</span> {
					context.setAttribute( <span class="hljs-string">"id"</span>, nid );
				}
				nid = <span class="hljs-string">"[id='"</span> + nid + <span class="hljs-string">"'] "</span>;

				i = groups.length;
				<span class="hljs-keyword">while</span> ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context;
				newSelector = groups.join(<span class="hljs-string">","</span>);
			}

			<span class="hljs-keyword">if</span> ( newSelector ) {
				<span class="hljs-keyword">try</span> {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					<span class="hljs-keyword">return</span> results;
				} <span class="hljs-keyword">catch</span>(qsaError) {
				} <span class="hljs-keyword">finally</span> {
					<span class="hljs-keyword">if</span> ( !old ) {
						context.removeAttribute(<span class="hljs-string">"id"</span>);
					}
				}
			}
		}
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All others</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span> select( selector.replace( rtrim, <span class="hljs-string">"$1"</span> ), context, results, seed );
}</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Create key-value caches of limited size</p>
<p><strong>Returns a Function(string, Object)</strong><br/>(Returns the Object data after storing it on itself with property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength) deleting the oldest entry)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCache</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">var</span> keys = [];

	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cache</span>(<span class="hljs-params"> key, value </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( keys.push( key + <span class="hljs-string">" "</span> ) &gt; Expr.cacheLength ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Only keep the most recent entries</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">delete</span> cache[ keys.shift() ];
		}
		<span class="hljs-keyword">return</span> (cache[ key + <span class="hljs-string">" "</span> ] = value);
	}
	<span class="hljs-keyword">return</span> cache;
}</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Mark a function for special use by Sizzle</p>
<p>Parameters:</p>
<ul>
<li><strong>fn must be a Function.</strong><br/>(The function to mark)</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markFunction</span>(<span class="hljs-params"> fn </span>) </span>{
	fn[ expando ] = <span class="hljs-literal">true</span>;
	<span class="hljs-keyword">return</span> fn;
}</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Support testing using an element</p>
<p>Parameters:</p>
<ul>
<li><strong>fn must be a Function.</strong><br/>(Passed the created div and expects a boolean result)</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assert</span>(<span class="hljs-params"> fn </span>) </span>{
	<span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>);

	<span class="hljs-keyword">try</span> {
		<span class="hljs-keyword">return</span> !!fn( div );
	} <span class="hljs-keyword">catch</span> (e) {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	} <span class="hljs-keyword">finally</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove from its parent by default</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>release memory in IE</p></div></div><div class="code"><div class="wrapper">		div = <span class="hljs-literal">null</span>;
	}
}</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Adds the same handler for all of the specified attrs</p>
<p>Parameters:</p>
<ul>
<li><p><strong>attrs must be a String.</strong><br/>(Pipe-separated list of attributes)</p>
</li>
<li><p><strong>handler must be a Function.</strong><br/>(The method that will be applied)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addHandle</span>(<span class="hljs-params"> attrs, handler </span>) </span>{
	<span class="hljs-keyword">var</span> arr = attrs.split(<span class="hljs-string">"|"</span>),
		i = attrs.length;

	<span class="hljs-keyword">while</span> ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Checks document order of two siblings</p>
<p>Parameters:</p>
<ul>
<li><p><strong>a must be an Element.</strong></p>
</li>
<li><p><strong>b must be an Element.</strong></p>
</li>
</ul>
<p><strong>Returns a Number</strong><br/>(Returns less than 0 if a precedes b, greater than 0 if a follows b)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siblingCheck</span>(<span class="hljs-params"> a, b </span>) </span>{
	<span class="hljs-keyword">var</span> cur = b &amp;&amp; a,
		diff = cur &amp;&amp; a.nodeType === <span class="hljs-number">1</span> &amp;&amp; b.nodeType === <span class="hljs-number">1</span> &amp;&amp;
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use IE sourceIndex if available on both nodes</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> ( diff ) {
		<span class="hljs-keyword">return</span> diff;
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if b follows a</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> ( cur ) {
		<span class="hljs-keyword">while</span> ( (cur = cur.nextSibling) ) {
			<span class="hljs-keyword">if</span> ( cur === b ) {
				<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
			}
		}
	}

	<span class="hljs-keyword">return</span> a ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;
}</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Returns a function to use in pseudos for input types</p>
<p>Parameters:</p>
<ul>
<li><strong>type must be a String.</strong></li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createInputPseudo</span>(<span class="hljs-params"> type </span>) </span>{
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
		<span class="hljs-keyword">var</span> name = elem.nodeName.toLowerCase();
		<span class="hljs-keyword">return</span> name === <span class="hljs-string">"input"</span> &amp;&amp; elem.type === type;
	};
}</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Returns a function to use in pseudos for buttons</p>
<p>Parameters:</p>
<ul>
<li><strong>type must be a String.</strong></li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createButtonPseudo</span>(<span class="hljs-params"> type </span>) </span>{
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
		<span class="hljs-keyword">var</span> name = elem.nodeName.toLowerCase();
		<span class="hljs-keyword">return</span> (name === <span class="hljs-string">"input"</span> || name === <span class="hljs-string">"button"</span>) &amp;&amp; elem.type === type;
	};
}</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Returns a function to use in pseudos for positionals</p>
<p>Parameters:</p>
<ul>
<li><strong>fn must be a Function.</strong></li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPositionalPseudo</span>(<span class="hljs-params"> fn </span>) </span>{
	<span class="hljs-keyword">return</span> markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> argument </span>) </span>{
		argument = +argument;
		<span class="hljs-keyword">return</span> markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> seed, matches </span>) </span>{
			<span class="hljs-keyword">var</span> j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Match elements found at the specified indexes</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">while</span> ( i-- ) {
				<span class="hljs-keyword">if</span> ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Checks a node for validity as a Sizzle context</p>
<p>Parameters:</p>
<ul>
<li><strong>context can be an Element or an Object=.</strong></li>
</ul>
<p><strong>Returns an Element or an Object or a Boolean</strong><br/>(The input node if acceptable, otherwise a falsy value)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testContext</span>(<span class="hljs-params"> context </span>) </span>{
	<span class="hljs-keyword">return</span> context &amp;&amp; <span class="hljs-keyword">typeof</span> context.getElementsByTagName !== <span class="hljs-string">"undefined"</span> &amp;&amp; context;
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Expose support vars for convenience</p></div></div><div class="code"><div class="wrapper">support = Sizzle.support = {};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Detects XML nodes</p>
<p>Parameters:</p>
<ul>
<li><strong>elem can be an Element or an Object.</strong><br/>(An element or a document)</li>
</ul>
<p><strong>Returns a Boolean</strong><br/>(True iff elem is a non-HTML XML node)</p></div></div><div class="code"><div class="wrapper">isXML = Sizzle.isXML = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>documentElement is verified for cases where it doesn&#39;t yet exist
(such as loading iframes in IE - #4833)</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
	<span class="hljs-keyword">return</span> documentElement ? documentElement.nodeName !== <span class="hljs-string">"HTML"</span> : <span class="hljs-literal">false</span>;
};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Sets document-related variables once based on the current document</p>
<p>Parameters:</p>
<ul>
<li><strong>doc is optional and can be an Element or an Object.</strong><br/>(An element or document object to use to set the document)</li>
</ul>
<p><strong>Returns an Object</strong><br/>(Returns the current document)</p></div></div><div class="code"><div class="wrapper">setDocument = Sizzle.setDocument = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> node </span>) </span>{
	<span class="hljs-keyword">var</span> hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If no document and documentElement is available, return</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> ( doc === <span class="hljs-built_in">document</span> || doc.nodeType !== <span class="hljs-number">9</span> || !doc.documentElement ) {
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>;
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set our document</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-built_in">document</span> = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE&gt;8
If iframe document is assigned to &quot;document&quot; variable and if iframe has been reloaded,
IE will throw &quot;permission denied&quot; error when accessing &quot;document&quot; variable, see jQuery #13936
IE6-8 do not support the defaultView property so parent will be undefined</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> ( parent &amp;&amp; parent !== parent.top ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IE11 does not have attachEvent, so all must suffer</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( parent.addEventListener ) {
			parent.addEventListener( <span class="hljs-string">"unload"</span>, unloadHandler, <span class="hljs-literal">false</span> );
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( parent.attachEvent ) {
			parent.attachEvent( <span class="hljs-string">"onunload"</span>, unloadHandler );
		}
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="support-tests">Support tests</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">	documentIsHTML = !isXML( doc );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="attributes">Attributes</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE&lt;8
Verify that getAttribute really returns attributes and not properties
(excepting IE8 booleans)</p></div></div><div class="code"><div class="wrapper">	support.attributes = assert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> div </span>) </span>{
		div.className = <span class="hljs-string">"i"</span>;
		<span class="hljs-keyword">return</span> !div.getAttribute(<span class="hljs-string">"className"</span>);
	});</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="getelementsby">getElement(s)By*</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if getElementsByTagName(&quot;*&quot;) returns only elements</p></div></div><div class="code"><div class="wrapper">	support.getElementsByTagName = assert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> div </span>) </span>{
		div.appendChild( doc.createComment(<span class="hljs-string">""</span>) );
		<span class="hljs-keyword">return</span> !div.getElementsByTagName(<span class="hljs-string">"*"</span>).length;
	});</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE&lt;9</p></div></div><div class="code"><div class="wrapper">	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE&lt;10
Check if getElementById returns elements by name
The broken getElementById methods don&#39;t pick up programatically-set names,
so use a roundabout getElementsByName test</p></div></div><div class="code"><div class="wrapper">	support.getById = assert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> div </span>) </span>{
		docElem.appendChild( div ).id = expando;
		<span class="hljs-keyword">return</span> !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ID find and filter</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> ( support.getById ) {
		Expr.find[<span class="hljs-string">"ID"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> id, context </span>) </span>{
			<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> context.getElementById !== <span class="hljs-string">"undefined"</span> &amp;&amp; documentIsHTML ) {
				<span class="hljs-keyword">var</span> m = context.getElementById( id );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check parentNode to catch when Blackberry 4.6 returns
nodes that are no longer in the document #6963</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">return</span> m &amp;&amp; m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter[<span class="hljs-string">"ID"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> id </span>) </span>{
			<span class="hljs-keyword">var</span> attrId = id.replace( runescape, funescape );
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
				<span class="hljs-keyword">return</span> elem.getAttribute(<span class="hljs-string">"id"</span>) === attrId;
			};
		};
	} <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE6/7
getElementById is not reliable as a find shortcut</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">delete</span> Expr.find[<span class="hljs-string">"ID"</span>];

		Expr.filter[<span class="hljs-string">"ID"</span>] =  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> id </span>) </span>{
			<span class="hljs-keyword">var</span> attrId = id.replace( runescape, funescape );
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
				<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">typeof</span> elem.getAttributeNode !== <span class="hljs-string">"undefined"</span> &amp;&amp; elem.getAttributeNode(<span class="hljs-string">"id"</span>);
				<span class="hljs-keyword">return</span> node &amp;&amp; node.value === attrId;
			};
		};
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Tag</p></div></div><div class="code"><div class="wrapper">	Expr.find[<span class="hljs-string">"TAG"</span>] = support.getElementsByTagName ?
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> tag, context </span>) </span>{
			<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> context.getElementsByTagName !== <span class="hljs-string">"undefined"</span> ) {
				<span class="hljs-keyword">return</span> context.getElementsByTagName( tag );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DocumentFragment nodes don&#39;t have gEBTN</p></div></div><div class="code"><div class="wrapper">			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( support.qsa ) {
				<span class="hljs-keyword">return</span> context.querySelectorAll( tag );
			}
		} :

		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> tag, context </span>) </span>{
			<span class="hljs-keyword">var</span> elem,
				tmp = [],
				i = <span class="hljs-number">0</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too</p></div></div><div class="code"><div class="wrapper">				results = context.getElementsByTagName( tag );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Filter out possible comments</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( tag === <span class="hljs-string">"*"</span> ) {
				<span class="hljs-keyword">while</span> ( (elem = results[i++]) ) {
					<span class="hljs-keyword">if</span> ( elem.nodeType === <span class="hljs-number">1</span> ) {
						tmp.push( elem );
					}
				}

				<span class="hljs-keyword">return</span> tmp;
			}
			<span class="hljs-keyword">return</span> results;
		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Class</p></div></div><div class="code"><div class="wrapper">	Expr.find[<span class="hljs-string">"CLASS"</span>] = support.getElementsByClassName &amp;&amp; <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> className, context </span>) </span>{
		<span class="hljs-keyword">if</span> ( documentIsHTML ) {
			<span class="hljs-keyword">return</span> context.getElementsByClassName( className );
		}
	};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="qsamatchesselector">QSA/matchesSelector</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>QSA and matchesSelector support</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>matchesSelector(:active) reports false when true (IE9/Opera 11.5)</p></div></div><div class="code"><div class="wrapper">	rbuggyMatches = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>qSa(:focus) reports false when true (Chrome 21)
We allow this because of a bug in IE8/9 that throws an error
whenever <code>document.activeElement</code> is accessed on an iframe
So, we allow :focus to pass through QSA all the time to avoid the IE error
See <a href="http://bugs.jquery.com/ticket/13378">http://bugs.jquery.com/ticket/13378</a></p></div></div><div class="code"><div class="wrapper">	rbuggyQSA = [];

	<span class="hljs-keyword">if</span> ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build QSA regex
Regex strategy adopted from Diego Perini</p></div></div><div class="code"><div class="wrapper">		assert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> div </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Select is set to empty string on purpose
This is to test IE&#39;s treatment of not explicitly
setting a boolean content attribute,
since its presence should be enough
<a href="http://bugs.jquery.com/ticket/12359">http://bugs.jquery.com/ticket/12359</a></p></div></div><div class="code"><div class="wrapper">			docElem.appendChild( div ).innerHTML = <span class="hljs-string">"&lt;a id='"</span> + expando + <span class="hljs-string">"'&gt;&lt;/a&gt;"</span> +
				<span class="hljs-string">"&lt;select id='"</span> + expando + <span class="hljs-string">"-\f]' msallowcapture=''&gt;"</span> +
				<span class="hljs-string">"&lt;option selected=''&gt;&lt;/option&gt;&lt;/select&gt;"</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE8, Opera 11-12.16
Nothing should be selected when empty strings follow ^= or $= or *=
The test attribute must be unknown in Opera but &quot;safe&quot; for WinRT
<a href="http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section">http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section</a></p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( div.querySelectorAll(<span class="hljs-string">"[msallowcapture^='']"</span>).length ) {
				rbuggyQSA.push( <span class="hljs-string">"[*^$]="</span> + whitespace + <span class="hljs-string">"*(?:''|\"\")"</span> );
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE8
Boolean attributes and &quot;value&quot; are not treated correctly</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( !div.querySelectorAll(<span class="hljs-string">"[selected]"</span>).length ) {
				rbuggyQSA.push( <span class="hljs-string">"\\["</span> + whitespace + <span class="hljs-string">"*(?:value|"</span> + booleans + <span class="hljs-string">")"</span> );
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: Chrome&lt;29, Android&lt;4.2+, Safari&lt;7.0+, iOS&lt;7.0+, PhantomJS&lt;1.9.7+</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( !div.querySelectorAll( <span class="hljs-string">"[id~="</span> + expando + <span class="hljs-string">"-]"</span> ).length ) {
				rbuggyQSA.push(<span class="hljs-string">"~="</span>);
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Webkit/Opera - :checked should return selected option elements
<a href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked">http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</a>
IE8 throws error here and will not see later tests</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( !div.querySelectorAll(<span class="hljs-string">":checked"</span>).length ) {
				rbuggyQSA.push(<span class="hljs-string">":checked"</span>);
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: Safari 8+, iOS 8+
<a href="https://bugs.webkit.org/show_bug.cgi?id=136851">https://bugs.webkit.org/show_bug.cgi?id=136851</a>
In-page <code>selector#id sibing-combinator selector</code> fails</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( !div.querySelectorAll( <span class="hljs-string">"a#"</span> + expando + <span class="hljs-string">"+*"</span> ).length ) {
				rbuggyQSA.push(<span class="hljs-string">".#.+[+~]"</span>);
			}
		});

		assert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> div </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: Windows 8 Native Apps
The type and name attributes are restricted during .innerHTML assignment</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> input = doc.createElement(<span class="hljs-string">"input"</span>);
			input.setAttribute( <span class="hljs-string">"type"</span>, <span class="hljs-string">"hidden"</span> );
			div.appendChild( input ).setAttribute( <span class="hljs-string">"name"</span>, <span class="hljs-string">"D"</span> );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE8
Enforce case-sensitivity of name attribute</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( div.querySelectorAll(<span class="hljs-string">"[name=d]"</span>).length ) {
				rbuggyQSA.push( <span class="hljs-string">"name"</span> + whitespace + <span class="hljs-string">"*[*^$|!~]?="</span> );
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
IE8 throws error here and will not see later tests</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( !div.querySelectorAll(<span class="hljs-string">":enabled"</span>).length ) {
				rbuggyQSA.push( <span class="hljs-string">":enabled"</span>, <span class="hljs-string">":disabled"</span> );
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Opera 10-11 does not throw on post-comma invalid pseudos</p></div></div><div class="code"><div class="wrapper">			div.querySelectorAll(<span class="hljs-string">"*,:x"</span>);
			rbuggyQSA.push(<span class="hljs-string">",.*:"</span>);
		});
	}

	<span class="hljs-keyword">if</span> ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> div </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check to see if it&#39;s possible to do matchesSelector
on a disconnected node (IE 9)</p></div></div><div class="code"><div class="wrapper">			support.disconnectedMatch = matches.call( div, <span class="hljs-string">"div"</span> );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This should fail with an exception
Gecko does not error, returns false instead</p></div></div><div class="code"><div class="wrapper">			matches.call( div, <span class="hljs-string">"[s!='']:x"</span> );
			rbuggyMatches.push( <span class="hljs-string">"!="</span>, pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length &amp;&amp; <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( rbuggyQSA.join(<span class="hljs-string">"|"</span>) );
	rbuggyMatches = rbuggyMatches.length &amp;&amp; <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( rbuggyMatches.join(<span class="hljs-string">"|"</span>) );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="contains">Contains</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">	hasCompare = rnative.test( docElem.compareDocumentPosition );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Element contains another
Purposefully does not implement inclusive descendent
As in, an element does not contain itself</p></div></div><div class="code"><div class="wrapper">	contains = hasCompare || rnative.test( docElem.contains ) ?
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> a, b </span>) </span>{
			<span class="hljs-keyword">var</span> adown = a.nodeType === <span class="hljs-number">9</span> ? a.documentElement : a,
				bup = b &amp;&amp; b.parentNode;
			<span class="hljs-keyword">return</span> a === bup || !!( bup &amp;&amp; bup.nodeType === <span class="hljs-number">1</span> &amp;&amp; (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; <span class="hljs-number">16</span>
			));
		} :
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> a, b </span>) </span>{
			<span class="hljs-keyword">if</span> ( b ) {
				<span class="hljs-keyword">while</span> ( (b = b.parentNode) ) {
					<span class="hljs-keyword">if</span> ( b === a ) {
						<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
					}
				}
			}
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="sorting">Sorting</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Document order sorting</p></div></div><div class="code"><div class="wrapper">	sortOrder = hasCompare ?
	<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> a, b </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag for duplicate removal</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( a === b ) {
			hasDuplicate = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sort on method existence if only one input has compareDocumentPosition</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		<span class="hljs-keyword">if</span> ( compare ) {
			<span class="hljs-keyword">return</span> compare;
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate position if both inputs belong to the same document</p></div></div><div class="code"><div class="wrapper">		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Otherwise we know they are disconnected</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-number">1</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Disconnected nodes</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( compare &amp; <span class="hljs-number">1</span> ||
			(!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Choose the first element that is related to our preferred document</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( a === doc || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a) ) {
				<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
			}
			<span class="hljs-keyword">if</span> ( b === doc || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b) ) {
				<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Maintain original order</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				<span class="hljs-number">0</span>;
		}

		<span class="hljs-keyword">return</span> compare &amp; <span class="hljs-number">4</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
	} :
	<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> a, b </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Exit early if the nodes are identical</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( a === b ) {
			hasDuplicate = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		}

		<span class="hljs-keyword">var</span> cur,
			i = <span class="hljs-number">0</span>,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parentless nodes are either documents or disconnected</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( !aup || !bup ) {
			<span class="hljs-keyword">return</span> a === doc ? -<span class="hljs-number">1</span> :
				b === doc ? <span class="hljs-number">1</span> :
				aup ? -<span class="hljs-number">1</span> :
				bup ? <span class="hljs-number">1</span> :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				<span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the nodes are siblings, we can do a quick check</p></div></div><div class="code"><div class="wrapper">		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( aup === bup ) {
			<span class="hljs-keyword">return</span> siblingCheck( a, b );
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Otherwise we need full lists of their ancestors for comparison</p></div></div><div class="code"><div class="wrapper">		cur = a;
		<span class="hljs-keyword">while</span> ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		<span class="hljs-keyword">while</span> ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Walk down the tree looking for a discrepancy</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">while</span> ( ap[i] === bp[i] ) {
			i++;
		}

		<span class="hljs-keyword">return</span> i ?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Do a sibling check if the nodes have a common ancestor</p></div></div><div class="code"><div class="wrapper">			siblingCheck( ap[i], bp[i] ) :</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Otherwise nodes in our document sort first</p></div></div><div class="code"><div class="wrapper">			ap[i] === preferredDoc ? -<span class="hljs-number">1</span> :
			bp[i] === preferredDoc ? <span class="hljs-number">1</span> :
			<span class="hljs-number">0</span>;
	};

	<span class="hljs-keyword">return</span> doc;
};

Sizzle.matches = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> expr, elements </span>) </span>{
	<span class="hljs-keyword">return</span> Sizzle( expr, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, elements );
};

Sizzle.matchesSelector = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, expr </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set document vars if needed</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> ( ( elem.ownerDocument || elem ) !== <span class="hljs-built_in">document</span> ) {
		setDocument( elem );
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make sure that attribute selectors are quoted</p></div></div><div class="code"><div class="wrapper">	expr = expr.replace( rattributeQuotes, <span class="hljs-string">"='$1']"</span> );

	<span class="hljs-keyword">if</span> ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">var</span> ret = matches.call( elem, expr );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IE 9&#39;s matchesSelector returns false on disconnected nodes</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( ret || support.disconnectedMatch ||</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>As well, disconnected nodes are said to be in a document
fragment in IE 9</p></div></div><div class="code"><div class="wrapper">					elem.document &amp;&amp; elem.document.nodeType !== <span class="hljs-number">11</span> ) {
				<span class="hljs-keyword">return</span> ret;
			}
		} <span class="hljs-keyword">catch</span> (e) {}
	}

	<span class="hljs-keyword">return</span> Sizzle( expr, <span class="hljs-built_in">document</span>, <span class="hljs-literal">null</span>, [ elem ] ).length &gt; <span class="hljs-number">0</span>;
};

Sizzle.contains = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> context, elem </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set document vars if needed</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> ( ( context.ownerDocument || context ) !== <span class="hljs-built_in">document</span> ) {
		setDocument( context );
	}
	<span class="hljs-keyword">return</span> contains( context, elem );
};

Sizzle.attr = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, name </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set document vars if needed</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> ( ( elem.ownerDocument || elem ) !== <span class="hljs-built_in">document</span> ) {
		setDocument( elem );
	}

	<span class="hljs-keyword">var</span> fn = Expr.attrHandle[ name.toLowerCase() ],</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Don&#39;t get fooled by Object.prototype properties (jQuery #13807)</p></div></div><div class="code"><div class="wrapper">		val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			<span class="hljs-literal">undefined</span>;

	<span class="hljs-keyword">return</span> val !== <span class="hljs-literal">undefined</span> ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
				val.value :
				<span class="hljs-literal">null</span>;
};

Sizzle.error = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> msg </span>) </span>{
	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"Syntax error, unrecognized expression: "</span> + msg );
};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Document sorting and removing duplicates</p>
<p>Parameters:</p>
<ul>
<li><strong>results must be an ArrayLike.</strong></li>
</ul></div></div><div class="code"><div class="wrapper">Sizzle.uniqueSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> results </span>) </span>{
	<span class="hljs-keyword">var</span> elem,
		duplicates = [],
		j = <span class="hljs-number">0</span>,
		i = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unless we <em>know</em> we can detect duplicates, assume their presence</p></div></div><div class="code"><div class="wrapper">	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable &amp;&amp; results.slice( <span class="hljs-number">0</span> );
	results.sort( sortOrder );

	<span class="hljs-keyword">if</span> ( hasDuplicate ) {
		<span class="hljs-keyword">while</span> ( (elem = results[i++]) ) {
			<span class="hljs-keyword">if</span> ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		<span class="hljs-keyword">while</span> ( j-- ) {
			results.splice( duplicates[ j ], <span class="hljs-number">1</span> );
		}
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Clear input after sorting to release objects
See <a href="https://github.com/jquery/sizzle/pull/225">https://github.com/jquery/sizzle/pull/225</a></p></div></div><div class="code"><div class="wrapper">	sortInput = <span class="hljs-literal">null</span>;

	<span class="hljs-keyword">return</span> results;
};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Utility function for retrieving the text value of an array of DOM nodes</p>
<p>Parameters:</p>
<ul>
<li><strong>elem can be an Array or an Element.</strong></li>
</ul></div></div><div class="code"><div class="wrapper">getText = Sizzle.getText = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
	<span class="hljs-keyword">var</span> node,
		ret = <span class="hljs-string">""</span>,
		i = <span class="hljs-number">0</span>,
		nodeType = elem.nodeType;

	<span class="hljs-keyword">if</span> ( !nodeType ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If no nodeType, this is expected to be an array</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">while</span> ( (node = elem[i++]) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Do not traverse comment nodes</p></div></div><div class="code"><div class="wrapper">			ret += getText( node );
		}
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( nodeType === <span class="hljs-number">1</span> || nodeType === <span class="hljs-number">9</span> || nodeType === <span class="hljs-number">11</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use textContent for elements
innerText usage removed for consistency of new lines (jQuery #11153)</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> elem.textContent === <span class="hljs-string">"string"</span> ) {
			<span class="hljs-keyword">return</span> elem.textContent;
		} <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Traverse its children</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( nodeType === <span class="hljs-number">3</span> || nodeType === <span class="hljs-number">4</span> ) {
		<span class="hljs-keyword">return</span> elem.nodeValue;
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Do not include comment or processing instruction nodes</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span> ret;
};

Expr = Sizzle.selectors = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Can be adjusted by the user</p></div></div><div class="code"><div class="wrapper">	cacheLength: <span class="hljs-number">50</span>,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		<span class="hljs-string">"&gt;"</span>: { dir: <span class="hljs-string">"parentNode"</span>, first: <span class="hljs-literal">true</span> },
		<span class="hljs-string">" "</span>: { dir: <span class="hljs-string">"parentNode"</span> },
		<span class="hljs-string">"+"</span>: { dir: <span class="hljs-string">"previousSibling"</span>, first: <span class="hljs-literal">true</span> },
		<span class="hljs-string">"~"</span>: { dir: <span class="hljs-string">"previousSibling"</span> }
	},

	preFilter: {
		<span class="hljs-string">"ATTR"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> match </span>) </span>{
			match[<span class="hljs-number">1</span>] = match[<span class="hljs-number">1</span>].replace( runescape, funescape );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Move the given value to match[3] whether quoted or unquoted</p></div></div><div class="code"><div class="wrapper">			match[<span class="hljs-number">3</span>] = ( match[<span class="hljs-number">3</span>] || match[<span class="hljs-number">4</span>] || match[<span class="hljs-number">5</span>] || <span class="hljs-string">""</span> ).replace( runescape, funescape );

			<span class="hljs-keyword">if</span> ( match[<span class="hljs-number">2</span>] === <span class="hljs-string">"~="</span> ) {
				match[<span class="hljs-number">3</span>] = <span class="hljs-string">" "</span> + match[<span class="hljs-number">3</span>] + <span class="hljs-string">" "</span>;
			}

			<span class="hljs-keyword">return</span> match.slice( <span class="hljs-number">0</span>, <span class="hljs-number">4</span> );
		},

		<span class="hljs-string">"CHILD"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> match </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>matches from matchExpr[&quot;CHILD&quot;]
    1 type (only|nth|...)
    2 what (child|of-type)
    3 argument (even|odd|\d<em>|\d</em>n([+-]\d+)?|...)
    4 xn-component of xn+y argument ([+-]?\d*n|)
    5 sign of xn-component
    6 x of xn-component
    7 sign of y-component
    8 y of y-component</p></div></div><div class="code"><div class="wrapper">			match[<span class="hljs-number">1</span>] = match[<span class="hljs-number">1</span>].toLowerCase();

			<span class="hljs-keyword">if</span> ( match[<span class="hljs-number">1</span>].slice( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) === <span class="hljs-string">"nth"</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>nth-* requires argument</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( !match[<span class="hljs-number">3</span>] ) {
					Sizzle.error( match[<span class="hljs-number">0</span>] );
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>numeric x and y parameters for Expr.filter.CHILD
remember that false/true cast respectively to 0/1</p></div></div><div class="code"><div class="wrapper">				match[<span class="hljs-number">4</span>] = +( match[<span class="hljs-number">4</span>] ? match[<span class="hljs-number">5</span>] + (match[<span class="hljs-number">6</span>] || <span class="hljs-number">1</span>) : <span class="hljs-number">2</span> * ( match[<span class="hljs-number">3</span>] === <span class="hljs-string">"even"</span> || match[<span class="hljs-number">3</span>] === <span class="hljs-string">"odd"</span> ) );
				match[<span class="hljs-number">5</span>] = +( ( match[<span class="hljs-number">7</span>] + match[<span class="hljs-number">8</span>] ) || match[<span class="hljs-number">3</span>] === <span class="hljs-string">"odd"</span> );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>other types prohibit arguments</p></div></div><div class="code"><div class="wrapper">			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( match[<span class="hljs-number">3</span>] ) {
				Sizzle.error( match[<span class="hljs-number">0</span>] );
			}

			<span class="hljs-keyword">return</span> match;
		},

		<span class="hljs-string">"PSEUDO"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> match </span>) </span>{
			<span class="hljs-keyword">var</span> excess,
				unquoted = !match[<span class="hljs-number">6</span>] &amp;&amp; match[<span class="hljs-number">2</span>];

			<span class="hljs-keyword">if</span> ( matchExpr[<span class="hljs-string">"CHILD"</span>].test( match[<span class="hljs-number">0</span>] ) ) {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Accept quoted arguments as-is</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( match[<span class="hljs-number">3</span>] ) {
				match[<span class="hljs-number">2</span>] = match[<span class="hljs-number">4</span>] || match[<span class="hljs-number">5</span>] || <span class="hljs-string">""</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Strip excess characters from unquoted arguments</p></div></div><div class="code"><div class="wrapper">			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get excess from tokenize (recursively)</p></div></div><div class="code"><div class="wrapper">				(excess = tokenize( unquoted, <span class="hljs-literal">true</span> )) &amp;&amp;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>advance to the next closing parenthesis</p></div></div><div class="code"><div class="wrapper">				(excess = unquoted.indexOf( <span class="hljs-string">")"</span>, unquoted.length - excess ) - unquoted.length) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>excess is a negative index</p></div></div><div class="code"><div class="wrapper">				match[<span class="hljs-number">0</span>] = match[<span class="hljs-number">0</span>].slice( <span class="hljs-number">0</span>, excess );
				match[<span class="hljs-number">2</span>] = unquoted.slice( <span class="hljs-number">0</span>, excess );
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return only captures needed by the pseudo filter method (type and argument)</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> match.slice( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );
		}
	},

	filter: {

		<span class="hljs-string">"TAG"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> nodeNameSelector </span>) </span>{
			<span class="hljs-keyword">var</span> nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			<span class="hljs-keyword">return</span> nodeNameSelector === <span class="hljs-string">"*"</span> ?
				<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; } :
				<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
					<span class="hljs-keyword">return</span> elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
				};
		},

		<span class="hljs-string">"CLASS"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> className </span>) </span>{
			<span class="hljs-keyword">var</span> pattern = classCache[ className + <span class="hljs-string">" "</span> ];

			<span class="hljs-keyword">return</span> pattern ||
				(pattern = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"(^|"</span> + whitespace + <span class="hljs-string">")"</span> + className + <span class="hljs-string">"("</span> + whitespace + <span class="hljs-string">"|$)"</span> )) &amp;&amp;
				classCache( className, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
					<span class="hljs-keyword">return</span> pattern.test( <span class="hljs-keyword">typeof</span> elem.className === <span class="hljs-string">"string"</span> &amp;&amp; elem.className || <span class="hljs-keyword">typeof</span> elem.getAttribute !== <span class="hljs-string">"undefined"</span> &amp;&amp; elem.getAttribute(<span class="hljs-string">"class"</span>) || <span class="hljs-string">""</span> );
				});
		},

		<span class="hljs-string">"ATTR"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> name, operator, check </span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
				<span class="hljs-keyword">var</span> result = Sizzle.attr( elem, name );

				<span class="hljs-keyword">if</span> ( result == <span class="hljs-literal">null</span> ) {
					<span class="hljs-keyword">return</span> operator === <span class="hljs-string">"!="</span>;
				}
				<span class="hljs-keyword">if</span> ( !operator ) {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
				}

				result += <span class="hljs-string">""</span>;

				<span class="hljs-keyword">return</span> operator === <span class="hljs-string">"="</span> ? result === check :
					operator === <span class="hljs-string">"!="</span> ? result !== check :
					operator === <span class="hljs-string">"^="</span> ? check &amp;&amp; result.indexOf( check ) === <span class="hljs-number">0</span> :
					operator === <span class="hljs-string">"*="</span> ? check &amp;&amp; result.indexOf( check ) &gt; -<span class="hljs-number">1</span> :
					operator === <span class="hljs-string">"$="</span> ? check &amp;&amp; result.slice( -check.length ) === check :
					operator === <span class="hljs-string">"~="</span> ? ( <span class="hljs-string">" "</span> + result.replace( rwhitespace, <span class="hljs-string">" "</span> ) + <span class="hljs-string">" "</span> ).indexOf( check ) &gt; -<span class="hljs-number">1</span> :
					operator === <span class="hljs-string">"|="</span> ? result === check || result.slice( <span class="hljs-number">0</span>, check.length + <span class="hljs-number">1</span> ) === check + <span class="hljs-string">"-"</span> :
					<span class="hljs-literal">false</span>;
			};
		},

		<span class="hljs-string">"CHILD"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> type, what, argument, first, last </span>) </span>{
			<span class="hljs-keyword">var</span> simple = type.slice( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) !== <span class="hljs-string">"nth"</span>,
				forward = type.slice( -<span class="hljs-number">4</span> ) !== <span class="hljs-string">"last"</span>,
				ofType = what === <span class="hljs-string">"of-type"</span>;

			<span class="hljs-keyword">return</span> first === <span class="hljs-number">1</span> &amp;&amp; last === <span class="hljs-number">0</span> ?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Shortcut for :nth-*(n)</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
					<span class="hljs-keyword">return</span> !!elem.parentNode;
				} :

				<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, context, xml </span>) </span>{
					<span class="hljs-keyword">var</span> cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? <span class="hljs-string">"nextSibling"</span> : <span class="hljs-string">"previousSibling"</span>,
						parent = elem.parentNode,
						name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
						useCache = !xml &amp;&amp; !ofType;

					<span class="hljs-keyword">if</span> ( parent ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>:(first|last|only)-(child|of-type)</p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">if</span> ( simple ) {
							<span class="hljs-keyword">while</span> ( dir ) {
								node = elem;
								<span class="hljs-keyword">while</span> ( (node = node[ dir ]) ) {
									<span class="hljs-keyword">if</span> ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === <span class="hljs-number">1</span> ) {
										<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
									}
								}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reverse direction for :only-* (if we haven&#39;t yet done so)</p></div></div><div class="code"><div class="wrapper">								start = dir = type === <span class="hljs-string">"only"</span> &amp;&amp; !start &amp;&amp; <span class="hljs-string">"nextSibling"</span>;
							}
							<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>non-xml :nth-child(...) stores cache data on <code>parent</code></p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">if</span> ( forward &amp;&amp; useCache ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Seek <code>elem</code> from a previously-cached index</p></div></div><div class="code"><div class="wrapper">							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[<span class="hljs-number">0</span>] === dirruns &amp;&amp; cache[<span class="hljs-number">1</span>];
							diff = cache[<span class="hljs-number">0</span>] === dirruns &amp;&amp; cache[<span class="hljs-number">2</span>];
							node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];

							<span class="hljs-keyword">while</span> ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fallback to seeking <code>elem</code> from the start</p></div></div><div class="code"><div class="wrapper">								(diff = nodeIndex = <span class="hljs-number">0</span>) || start.pop()) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When found, cache indexes on <code>parent</code> and break</p></div></div><div class="code"><div class="wrapper">								<span class="hljs-keyword">if</span> ( node.nodeType === <span class="hljs-number">1</span> &amp;&amp; ++diff &amp;&amp; node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									<span class="hljs-keyword">break</span>;
								}
							}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use previously-cached element index if available</p></div></div><div class="code"><div class="wrapper">						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( useCache &amp;&amp; (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) &amp;&amp; cache[<span class="hljs-number">0</span>] === dirruns ) {
							diff = cache[<span class="hljs-number">1</span>];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)</p></div></div><div class="code"><div class="wrapper">						} <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use the same loop as above to seek <code>elem</code> from the start</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">while</span> ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
								(diff = nodeIndex = <span class="hljs-number">0</span>) || start.pop()) ) {

								<span class="hljs-keyword">if</span> ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === <span class="hljs-number">1</span> ) &amp;&amp; ++diff ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache the index of each encountered element</p></div></div><div class="code"><div class="wrapper">									<span class="hljs-keyword">if</span> ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									<span class="hljs-keyword">if</span> ( node === elem ) {
										<span class="hljs-keyword">break</span>;
									}
								}
							}
						}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Incorporate the offset, then check against cycle size</p></div></div><div class="code"><div class="wrapper">						diff -= last;
						<span class="hljs-keyword">return</span> diff === first || ( diff % first === <span class="hljs-number">0</span> &amp;&amp; diff / first &gt;= <span class="hljs-number">0</span> );
					}
				};
		},

		<span class="hljs-string">"PSEUDO"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> pseudo, argument </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>pseudo-class names are case-insensitive
<a href="http://www.w3.org/TR/selectors/#pseudo-classes">http://www.w3.org/TR/selectors/#pseudo-classes</a>
Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
Remember that setFilters inherits from pseudos</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( <span class="hljs-string">"unsupported pseudo: "</span> + pseudo );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The user may use createPseudo to indicate that
arguments are needed to create the filter function
just as Sizzle does</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( fn[ expando ] ) {
				<span class="hljs-keyword">return</span> fn( argument );
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>But maintain support for old signatures</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( fn.length &gt; <span class="hljs-number">1</span> ) {
				args = [ pseudo, pseudo, <span class="hljs-string">""</span>, argument ];
				<span class="hljs-keyword">return</span> Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> seed, matches </span>) </span>{
						<span class="hljs-keyword">var</span> idx,
							matched = fn( seed, argument ),
							i = matched.length;
						<span class="hljs-keyword">while</span> ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
						<span class="hljs-keyword">return</span> fn( elem, <span class="hljs-number">0</span>, args );
					};
			}

			<span class="hljs-keyword">return</span> fn;
		}
	},

	pseudos: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Potentially complex pseudos</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"not"</span>: markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> selector </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trim the selector passed to compile
to avoid treating leading and trailing
spaces as combinators</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, <span class="hljs-string">"$1"</span> ) );

			<span class="hljs-keyword">return</span> matcher[ expando ] ?
				markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> seed, matches, context, xml </span>) </span>{
					<span class="hljs-keyword">var</span> elem,
						unmatched = matcher( seed, <span class="hljs-literal">null</span>, xml, [] ),
						i = seed.length;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Match elements unmatched by <code>matcher</code></p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">while</span> ( i-- ) {
						<span class="hljs-keyword">if</span> ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, context, xml </span>) </span>{
					input[<span class="hljs-number">0</span>] = elem;
					matcher( input, <span class="hljs-literal">null</span>, xml, results );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Don&#39;t keep the element (issue #299)</p></div></div><div class="code"><div class="wrapper">					input[<span class="hljs-number">0</span>] = <span class="hljs-literal">null</span>;
					<span class="hljs-keyword">return</span> !results.pop();
				};
		}),

		<span class="hljs-string">"has"</span>: markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> selector </span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
				<span class="hljs-keyword">return</span> Sizzle( selector, elem ).length &gt; <span class="hljs-number">0</span>;
			};
		}),

		<span class="hljs-string">"contains"</span>: markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> text </span>) </span>{
			text = text.replace( runescape, funescape );
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
				<span class="hljs-keyword">return</span> ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -<span class="hljs-number">1</span>;
			};
		}),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>&quot;Whether an element is represented by a :lang() selector
is based solely on the element&#39;s language value
being equal to the identifier C,
or beginning with the identifier C immediately followed by &quot;-&quot;.
The matching of C against the element&#39;s language value is performed case-insensitively.
The identifier C does not have to be a valid language name.&quot;
<a href="http://www.w3.org/TR/selectors/#lang-pseudo">http://www.w3.org/TR/selectors/#lang-pseudo</a></p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"lang"</span>: markFunction( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> lang </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>lang value must be a valid identifier</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( !ridentifier.test(lang || <span class="hljs-string">""</span>) ) {
				Sizzle.error( <span class="hljs-string">"unsupported lang: "</span> + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
				<span class="hljs-keyword">var</span> elemLang;
				<span class="hljs-keyword">do</span> {
					<span class="hljs-keyword">if</span> ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute(<span class="hljs-string">"xml:lang"</span>) || elem.getAttribute(<span class="hljs-string">"lang"</span>)) ) {

						elemLang = elemLang.toLowerCase();
						<span class="hljs-keyword">return</span> elemLang === lang || elemLang.indexOf( lang + <span class="hljs-string">"-"</span> ) === <span class="hljs-number">0</span>;
					}
				} <span class="hljs-keyword">while</span> ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === <span class="hljs-number">1</span> );
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
			};
		}),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Miscellaneous</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"target"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">var</span> hash = <span class="hljs-built_in">window</span>.location &amp;&amp; <span class="hljs-built_in">window</span>.location.hash;
			<span class="hljs-keyword">return</span> hash &amp;&amp; hash.slice( <span class="hljs-number">1</span> ) === elem.id;
		},

		<span class="hljs-string">"root"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">return</span> elem === docElem;
		},

		<span class="hljs-string">"focus"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">return</span> elem === <span class="hljs-built_in">document</span>.activeElement &amp;&amp; (!<span class="hljs-built_in">document</span>.hasFocus || <span class="hljs-built_in">document</span>.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
		},</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Boolean properties</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"enabled"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">return</span> elem.disabled === <span class="hljs-literal">false</span>;
		},

		<span class="hljs-string">"disabled"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">return</span> elem.disabled === <span class="hljs-literal">true</span>;
		},

		<span class="hljs-string">"checked"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In CSS3, :checked should return both checked and selected elements
<a href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked">http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</a></p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> nodeName = elem.nodeName.toLowerCase();
			<span class="hljs-keyword">return</span> (nodeName === <span class="hljs-string">"input"</span> &amp;&amp; !!elem.checked) || (nodeName === <span class="hljs-string">"option"</span> &amp;&amp; !!elem.selected);
		},

		<span class="hljs-string">"selected"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Accessing this property makes selected-by-default
options in Safari work properly</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			<span class="hljs-keyword">return</span> elem.selected === <span class="hljs-literal">true</span>;
		},</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Contents</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"empty"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><a href="http://www.w3.org/TR/selectors/#empty-pseudo">http://www.w3.org/TR/selectors/#empty-pseudo</a>
:empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
  but not by others (comment: 8; processing instruction: 7; etc.)
nodeType &lt; 6 works because attributes (2) do not appear as children</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				<span class="hljs-keyword">if</span> ( elem.nodeType &lt; <span class="hljs-number">6</span> ) {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
				}
			}
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		},

		<span class="hljs-string">"parent"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">return</span> !Expr.pseudos[<span class="hljs-string">"empty"</span>]( elem );
		},</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Element/input types</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"header"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">return</span> rheader.test( elem.nodeName );
		},

		<span class="hljs-string">"input"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">return</span> rinputs.test( elem.nodeName );
		},

		<span class="hljs-string">"button"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">var</span> name = elem.nodeName.toLowerCase();
			<span class="hljs-keyword">return</span> name === <span class="hljs-string">"input"</span> &amp;&amp; elem.type === <span class="hljs-string">"button"</span> || name === <span class="hljs-string">"button"</span>;
		},

		<span class="hljs-string">"text"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">var</span> attr;
			<span class="hljs-keyword">return</span> elem.nodeName.toLowerCase() === <span class="hljs-string">"input"</span> &amp;&amp;
				elem.type === <span class="hljs-string">"text"</span> &amp;&amp;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE&lt;8
New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type === &quot;text&quot;</p></div></div><div class="code"><div class="wrapper">				( (attr = elem.getAttribute(<span class="hljs-string">"type"</span>)) == <span class="hljs-literal">null</span> || attr.toLowerCase() === <span class="hljs-string">"text"</span> );
		},</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Position-in-collection</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"first"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> [ <span class="hljs-number">0</span> ];
		}),

		<span class="hljs-string">"last"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> matchIndexes, length </span>) </span>{
			<span class="hljs-keyword">return</span> [ length - <span class="hljs-number">1</span> ];
		}),

		<span class="hljs-string">"eq"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> matchIndexes, length, argument </span>) </span>{
			<span class="hljs-keyword">return</span> [ argument &lt; <span class="hljs-number">0</span> ? argument + length : argument ];
		}),

		<span class="hljs-string">"even"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> matchIndexes, length </span>) </span>{
			<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">for</span> ( ; i &lt; length; i += <span class="hljs-number">2</span> ) {
				matchIndexes.push( i );
			}
			<span class="hljs-keyword">return</span> matchIndexes;
		}),

		<span class="hljs-string">"odd"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> matchIndexes, length </span>) </span>{
			<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;
			<span class="hljs-keyword">for</span> ( ; i &lt; length; i += <span class="hljs-number">2</span> ) {
				matchIndexes.push( i );
			}
			<span class="hljs-keyword">return</span> matchIndexes;
		}),

		<span class="hljs-string">"lt"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> matchIndexes, length, argument </span>) </span>{
			<span class="hljs-keyword">var</span> i = argument &lt; <span class="hljs-number">0</span> ? argument + length : argument;
			<span class="hljs-keyword">for</span> ( ; --i &gt;= <span class="hljs-number">0</span>; ) {
				matchIndexes.push( i );
			}
			<span class="hljs-keyword">return</span> matchIndexes;
		}),

		<span class="hljs-string">"gt"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> matchIndexes, length, argument </span>) </span>{
			<span class="hljs-keyword">var</span> i = argument &lt; <span class="hljs-number">0</span> ? argument + length : argument;
			<span class="hljs-keyword">for</span> ( ; ++i &lt; length; ) {
				matchIndexes.push( i );
			}
			<span class="hljs-keyword">return</span> matchIndexes;
		})
	}
};

Expr.pseudos[<span class="hljs-string">"nth"</span>] = Expr.pseudos[<span class="hljs-string">"eq"</span>];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add button/input type pseudos</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">for</span> ( i <span class="hljs-keyword">in</span> { radio: <span class="hljs-literal">true</span>, checkbox: <span class="hljs-literal">true</span>, file: <span class="hljs-literal">true</span>, password: <span class="hljs-literal">true</span>, image: <span class="hljs-literal">true</span> } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
<span class="hljs-keyword">for</span> ( i <span class="hljs-keyword">in</span> { submit: <span class="hljs-literal">true</span>, reset: <span class="hljs-literal">true</span> } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Easy API for creating new setFilters</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setFilters</span>(<span class="hljs-params"></span>) </span>{}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = <span class="hljs-keyword">new</span> setFilters();

tokenize = Sizzle.tokenize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> selector, parseOnly </span>) </span>{
	<span class="hljs-keyword">var</span> matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + <span class="hljs-string">" "</span> ];

	<span class="hljs-keyword">if</span> ( cached ) {
		<span class="hljs-keyword">return</span> parseOnly ? <span class="hljs-number">0</span> : cached.slice( <span class="hljs-number">0</span> );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	<span class="hljs-keyword">while</span> ( soFar ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Comma and first run</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( !matched || (match = rcomma.exec( soFar )) ) {
			<span class="hljs-keyword">if</span> ( match ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Don&#39;t consume trailing commas as valid</p></div></div><div class="code"><div class="wrapper">				soFar = soFar.slice( match[<span class="hljs-number">0</span>].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Combinators</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cast descendant combinators to space</p></div></div><div class="code"><div class="wrapper">				type: match[<span class="hljs-number">0</span>].replace( rtrim, <span class="hljs-string">" "</span> )
			});
			soFar = soFar.slice( matched.length );
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Filters</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( type <span class="hljs-keyword">in</span> Expr.filter ) {
			<span class="hljs-keyword">if</span> ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		<span class="hljs-keyword">if</span> ( !matched ) {
			<span class="hljs-keyword">break</span>;
		}
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return the length of the invalid excess
if we&#39;re just parsing
Otherwise, throw an error or return tokens</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span> parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache the tokens</p></div></div><div class="code"><div class="wrapper">			tokenCache( selector, groups ).slice( <span class="hljs-number">0</span> );
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toSelector</span>(<span class="hljs-params"> tokens </span>) </span>{
	<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
		len = tokens.length,
		selector = <span class="hljs-string">""</span>;
	<span class="hljs-keyword">for</span> ( ; i &lt; len; i++ ) {
		selector += tokens[i].value;
	}
	<span class="hljs-keyword">return</span> selector;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCombinator</span>(<span class="hljs-params"> matcher, combinator, base </span>) </span>{
	<span class="hljs-keyword">var</span> dir = combinator.dir,
		checkNonElements = base &amp;&amp; dir === <span class="hljs-string">"parentNode"</span>,
		doneName = done++;

	<span class="hljs-keyword">return</span> combinator.first ?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check against closest ancestor/preceding element</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, context, xml </span>) </span>{
			<span class="hljs-keyword">while</span> ( (elem = elem[ dir ]) ) {
				<span class="hljs-keyword">if</span> ( elem.nodeType === <span class="hljs-number">1</span> || checkNonElements ) {
					<span class="hljs-keyword">return</span> matcher( elem, context, xml );
				}
			}
		} :</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check against all ancestor/preceding elements</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, context, xml </span>) </span>{
			<span class="hljs-keyword">var</span> oldCache, outerCache,
				newCache = [ dirruns, doneName ];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We can&#39;t set arbitrary data on XML nodes, so they don&#39;t benefit from dir caching</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( xml ) {
				<span class="hljs-keyword">while</span> ( (elem = elem[ dir ]) ) {
					<span class="hljs-keyword">if</span> ( elem.nodeType === <span class="hljs-number">1</span> || checkNonElements ) {
						<span class="hljs-keyword">if</span> ( matcher( elem, context, xml ) ) {
							<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
						}
					}
				}
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">while</span> ( (elem = elem[ dir ]) ) {
					<span class="hljs-keyword">if</span> ( elem.nodeType === <span class="hljs-number">1</span> || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						<span class="hljs-keyword">if</span> ( (oldCache = outerCache[ dir ]) &amp;&amp;
							oldCache[ <span class="hljs-number">0</span> ] === dirruns &amp;&amp; oldCache[ <span class="hljs-number">1</span> ] === doneName ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Assign to newCache so results back-propagate to previous elements</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">return</span> (newCache[ <span class="hljs-number">2</span> ] = oldCache[ <span class="hljs-number">2</span> ]);
						} <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reuse newcache so results back-propagate to previous elements</p></div></div><div class="code"><div class="wrapper">							outerCache[ dir ] = newCache;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A match means we&#39;re done; a fail means we have to keep checking</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">if</span> ( (newCache[ <span class="hljs-number">2</span> ] = matcher( elem, context, xml )) ) {
								<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
							}
						}
					}
				}
			}
		};
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elementMatcher</span>(<span class="hljs-params"> matchers </span>) </span>{
	<span class="hljs-keyword">return</span> matchers.length &gt; <span class="hljs-number">1</span> ?
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, context, xml </span>) </span>{
			<span class="hljs-keyword">var</span> i = matchers.length;
			<span class="hljs-keyword">while</span> ( i-- ) {
				<span class="hljs-keyword">if</span> ( !matchers[i]( elem, context, xml ) ) {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
				}
			}
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		} :
		matchers[<span class="hljs-number">0</span>];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multipleContexts</span>(<span class="hljs-params"> selector, contexts, results </span>) </span>{
	<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
		len = contexts.length;
	<span class="hljs-keyword">for</span> ( ; i &lt; len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	<span class="hljs-keyword">return</span> results;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">condense</span>(<span class="hljs-params"> unmatched, map, filter, context, xml </span>) </span>{
	<span class="hljs-keyword">var</span> elem,
		newUnmatched = [],
		i = <span class="hljs-number">0</span>,
		len = unmatched.length,
		mapped = map != <span class="hljs-literal">null</span>;

	<span class="hljs-keyword">for</span> ( ; i &lt; len; i++ ) {
		<span class="hljs-keyword">if</span> ( (elem = unmatched[i]) ) {
			<span class="hljs-keyword">if</span> ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				<span class="hljs-keyword">if</span> ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	<span class="hljs-keyword">return</span> newUnmatched;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMatcher</span>(<span class="hljs-params"> preFilter, selector, matcher, postFilter, postFinder, postSelector </span>) </span>{
	<span class="hljs-keyword">if</span> ( postFilter &amp;&amp; !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	<span class="hljs-keyword">if</span> ( postFinder &amp;&amp; !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	<span class="hljs-keyword">return</span> markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> seed, results, context, xml </span>) </span>{
		<span class="hljs-keyword">var</span> temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get initial elements from seed or context</p></div></div><div class="code"><div class="wrapper">			elems = seed || multipleContexts( selector || <span class="hljs-string">"*"</span>, context.nodeType ? [ context ] : context, [] ),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prefilter to get matcher input, preserving a map for seed-results synchronization</p></div></div><div class="code"><div class="wrapper">			matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,</p></div></div><div class="code"><div class="wrapper">				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>...intermediate processing is necessary</p></div></div><div class="code"><div class="wrapper">					[] :</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>...otherwise use results directly</p></div></div><div class="code"><div class="wrapper">					results :
				matcherIn;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find primary matches</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply postFilter</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Un-match failing elements by moving them back to matcherIn</p></div></div><div class="code"><div class="wrapper">			i = temp.length;
			<span class="hljs-keyword">while</span> ( i-- ) {
				<span class="hljs-keyword">if</span> ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		<span class="hljs-keyword">if</span> ( seed ) {
			<span class="hljs-keyword">if</span> ( postFinder || preFilter ) {
				<span class="hljs-keyword">if</span> ( postFinder ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the final matcherOut by condensing this intermediate into postFinder contexts</p></div></div><div class="code"><div class="wrapper">					temp = [];
					i = matcherOut.length;
					<span class="hljs-keyword">while</span> ( i-- ) {
						<span class="hljs-keyword">if</span> ( (elem = matcherOut[i]) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Restore matcherIn since elem is not yet a final match</p></div></div><div class="code"><div class="wrapper">							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( <span class="hljs-literal">null</span>, (matcherOut = []), temp, xml );
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Move matched elements from seed to results to keep them synchronized</p></div></div><div class="code"><div class="wrapper">				i = matcherOut.length;
				<span class="hljs-keyword">while</span> ( i-- ) {
					<span class="hljs-keyword">if</span> ( (elem = matcherOut[i]) &amp;&amp;
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) &gt; -<span class="hljs-number">1</span> ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add elements to results, through postFinder if defined</p></div></div><div class="code"><div class="wrapper">		} <span class="hljs-keyword">else</span> {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			<span class="hljs-keyword">if</span> ( postFinder ) {
				postFinder( <span class="hljs-literal">null</span>, results, matcherOut, xml );
			} <span class="hljs-keyword">else</span> {
				push.apply( results, matcherOut );
			}
		}
	});
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matcherFromTokens</span>(<span class="hljs-params"> tokens </span>) </span>{
	<span class="hljs-keyword">var</span> checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[<span class="hljs-number">0</span>].type ],
		implicitRelative = leadingRelative || Expr.relative[<span class="hljs-string">" "</span>],
		i = leadingRelative ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The foundational matcher ensures that elements are reachable from top-level context(s)</p></div></div><div class="code"><div class="wrapper">		matchContext = addCombinator( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">return</span> elem === checkContext;
		}, implicitRelative, <span class="hljs-literal">true</span> ),
		matchAnyContext = addCombinator( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
			<span class="hljs-keyword">return</span> indexOf( checkContext, elem ) &gt; -<span class="hljs-number">1</span>;
		}, implicitRelative, <span class="hljs-literal">true</span> ),
		matchers = [ <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, context, xml </span>) </span>{
			<span class="hljs-keyword">var</span> ret = ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Avoid hanging onto element (issue #299)</p></div></div><div class="code"><div class="wrapper">			checkContext = <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">return</span> ret;
		} ];

	<span class="hljs-keyword">for</span> ( ; i &lt; len; i++ ) {
		<span class="hljs-keyword">if</span> ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} <span class="hljs-keyword">else</span> {
			matcher = Expr.filter[ tokens[i].type ].apply( <span class="hljs-literal">null</span>, tokens[i].matches );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return special upon seeing a positional matcher</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( matcher[ expando ] ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the next relative operator (if any) for proper handling</p></div></div><div class="code"><div class="wrapper">				j = ++i;
				<span class="hljs-keyword">for</span> ( ; j &lt; len; j++ ) {
					<span class="hljs-keyword">if</span> ( Expr.relative[ tokens[j].type ] ) {
						<span class="hljs-keyword">break</span>;
					}
				}
				<span class="hljs-keyword">return</span> setMatcher(
					i &gt; <span class="hljs-number">1</span> &amp;&amp; elementMatcher( matchers ),
					i &gt; <span class="hljs-number">1</span> &amp;&amp; toSelector(</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the preceding token was a descendant combinator, insert an implicit any-element <code>*</code></p></div></div><div class="code"><div class="wrapper">						tokens.slice( <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span> ).concat({ value: tokens[ i - <span class="hljs-number">2</span> ].type === <span class="hljs-string">" "</span> ? <span class="hljs-string">"*"</span> : <span class="hljs-string">""</span> })
					).replace( rtrim, <span class="hljs-string">"$1"</span> ),
					matcher,
					i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
					j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),
					j &lt; len &amp;&amp; toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	<span class="hljs-keyword">return</span> elementMatcher( matchers );
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matcherFromGroupMatchers</span>(<span class="hljs-params"> elementMatchers, setMatchers </span>) </span>{
	<span class="hljs-keyword">var</span> bySet = setMatchers.length &gt; <span class="hljs-number">0</span>,
		byElement = elementMatchers.length &gt; <span class="hljs-number">0</span>,
		superMatcher = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> seed, context, xml, results, outermost </span>) </span>{
			<span class="hljs-keyword">var</span> elem, j, matcher,
				matchedCount = <span class="hljs-number">0</span>,
				i = <span class="hljs-string">"0"</span>,
				unmatched = seed &amp;&amp; [],
				setMatched = [],
				contextBackup = outermostContext,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We must always have either seed elements or outermost context</p></div></div><div class="code"><div class="wrapper">				elems = seed || byElement &amp;&amp; Expr.find[<span class="hljs-string">"TAG"</span>]( <span class="hljs-string">"*"</span>, outermost ),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use integer dirruns iff this is the outermost matcher</p></div></div><div class="code"><div class="wrapper">				dirrunsUnique = (dirruns += contextBackup == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : <span class="hljs-built_in">Math</span>.random() || <span class="hljs-number">0.1</span>),
				len = elems.length;

			<span class="hljs-keyword">if</span> ( outermost ) {
				outermostContext = context !== <span class="hljs-built_in">document</span> &amp;&amp; context;
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add elements passing elementMatchers directly to results
Keep <code>i</code> a string if there are no elements so <code>matchedCount</code> will be &quot;00&quot; below
Support: IE<9, Safari
Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( ; i !== len &amp;&amp; (elem = elems[i]) != <span class="hljs-literal">null</span>; i++ ) {
				<span class="hljs-keyword">if</span> ( byElement &amp;&amp; elem ) {
					j = <span class="hljs-number">0</span>;
					<span class="hljs-keyword">while</span> ( (matcher = elementMatchers[j++]) ) {
						<span class="hljs-keyword">if</span> ( matcher( elem, context, xml ) ) {
							results.push( elem );
							<span class="hljs-keyword">break</span>;
						}
					}
					<span class="hljs-keyword">if</span> ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Track unmatched elements for set filters</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( bySet ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>They will have gone through all possible matchers</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( (elem = !matcher &amp;&amp; elem) ) {
						matchedCount--;
					}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Lengthen the array for every element, matched or not</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( seed ) {
						unmatched.push( elem );
					}
				}
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply set filters to unmatched elements</p></div></div><div class="code"><div class="wrapper">			matchedCount += i;
			<span class="hljs-keyword">if</span> ( bySet &amp;&amp; i !== matchedCount ) {
				j = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">while</span> ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				<span class="hljs-keyword">if</span> ( seed ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reintegrate element matches to eliminate the need for sorting</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( matchedCount &gt; <span class="hljs-number">0</span> ) {
						<span class="hljs-keyword">while</span> ( i-- ) {
							<span class="hljs-keyword">if</span> ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Discard index placeholder values to get only actual matches</p></div></div><div class="code"><div class="wrapper">					setMatched = condense( setMatched );
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add matches to results</p></div></div><div class="code"><div class="wrapper">				push.apply( results, setMatched );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Seedless set matches succeeding multiple successful matchers stipulate sorting</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; <span class="hljs-number">0</span> &amp;&amp;
					( matchedCount + setMatchers.length ) &gt; <span class="hljs-number">1</span> ) {

					Sizzle.uniqueSort( results );
				}
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Override manipulation of globals by nested matchers</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			<span class="hljs-keyword">return</span> unmatched;
		};

	<span class="hljs-keyword">return</span> bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> selector, match <span class="hljs-comment">/* Internal Use Only */</span> </span>) </span>{
	<span class="hljs-keyword">var</span> i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + <span class="hljs-string">" "</span> ];

	<span class="hljs-keyword">if</span> ( !cached ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Generate a function of recursive functions that can be used to check each element</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		<span class="hljs-keyword">while</span> ( i-- ) {
			cached = matcherFromTokens( match[i] );
			<span class="hljs-keyword">if</span> ( cached[ expando ] ) {
				setMatchers.push( cached );
			} <span class="hljs-keyword">else</span> {
				elementMatchers.push( cached );
			}
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache the compiled function</p></div></div><div class="code"><div class="wrapper">		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Save selector and tokenization</p></div></div><div class="code"><div class="wrapper">		cached.selector = selector;
	}
	<span class="hljs-keyword">return</span> cached;
};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>A low-level selection function that works with Sizzle&#39;s compiled
 selector functions</p>
<p>Parameters:</p>
<ul>
<li><p><strong>selector can be a String or a Function.</strong><br/>(A selector or a pre-compiled selector function built with Sizzle.compile)</p>
</li>
<li><p><strong>context must be an Element.</strong></p>
</li>
<li><p><strong>results is optional and must be an Array.</strong></p>
</li>
<li><p><strong>seed is optional and must be an Array.</strong><br/>(A set of elements to match against)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">select = Sizzle.select = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> selector, context, results, seed </span>) </span>{
	<span class="hljs-keyword">var</span> i, tokens, token, type, find,
		compiled = <span class="hljs-keyword">typeof</span> selector === <span class="hljs-string">"function"</span> &amp;&amp; selector,
		match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) );

	results = results || [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Try to minimize operations if there is no seed and only one group</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">if</span> ( match.length === <span class="hljs-number">1</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Take a shortcut and set the context if the root selector is an ID</p></div></div><div class="code"><div class="wrapper">		tokens = match[<span class="hljs-number">0</span>] = match[<span class="hljs-number">0</span>].slice( <span class="hljs-number">0</span> );
		<span class="hljs-keyword">if</span> ( tokens.length &gt; <span class="hljs-number">2</span> &amp;&amp; (token = tokens[<span class="hljs-number">0</span>]).type === <span class="hljs-string">"ID"</span> &amp;&amp;
				support.getById &amp;&amp; context.nodeType === <span class="hljs-number">9</span> &amp;&amp; documentIsHTML &amp;&amp;
				Expr.relative[ tokens[<span class="hljs-number">1</span>].type ] ) {

			context = ( Expr.find[<span class="hljs-string">"ID"</span>]( token.matches[<span class="hljs-number">0</span>].replace(runescape, funescape), context ) || [] )[<span class="hljs-number">0</span>];
			<span class="hljs-keyword">if</span> ( !context ) {
				<span class="hljs-keyword">return</span> results;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Precompiled matchers will still verify ancestry, so step up a level</p></div></div><div class="code"><div class="wrapper">			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fetch a seed set for right-to-left matching</p></div></div><div class="code"><div class="wrapper">		i = matchExpr[<span class="hljs-string">"needsContext"</span>].test( selector ) ? <span class="hljs-number">0</span> : tokens.length;
		<span class="hljs-keyword">while</span> ( i-- ) {
			token = tokens[i];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Abort if we hit a combinator</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( Expr.relative[ (type = token.type) ] ) {
				<span class="hljs-keyword">break</span>;
			}
			<span class="hljs-keyword">if</span> ( (find = Expr.find[ type ]) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Search, expanding context for leading sibling combinators</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( (seed = find(
					token.matches[<span class="hljs-number">0</span>].replace( runescape, funescape ),
					rsibling.test( tokens[<span class="hljs-number">0</span>].type ) &amp;&amp; testContext( context.parentNode ) || context
				)) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If seed is empty or no tokens remain, we can return early</p></div></div><div class="code"><div class="wrapper">					tokens.splice( i, <span class="hljs-number">1</span> );
					selector = seed.length &amp;&amp; toSelector( tokens );
					<span class="hljs-keyword">if</span> ( !selector ) {
						push.apply( results, seed );
						<span class="hljs-keyword">return</span> results;
					}

					<span class="hljs-keyword">break</span>;
				}
			}
		}
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compile and execute a filtering function if one is not provided
Provide <code>match</code> to avoid retokenization if we modified the selector above</p></div></div><div class="code"><div class="wrapper">	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context
	);
	<span class="hljs-keyword">return</span> results;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>One-time assignments</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sort stability</p></div></div><div class="code"><div class="wrapper">support.sortStable = expando.split(<span class="hljs-string">""</span>).sort( sortOrder ).join(<span class="hljs-string">""</span>) === expando;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: Chrome 14-35+
Always assume duplicates if they aren&#39;t passed to the comparison function</p></div></div><div class="code"><div class="wrapper">support.detectDuplicates = !!hasDuplicate;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Initialize against the default document</p></div></div><div class="code"><div class="wrapper">setDocument();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
Detached nodes confoundingly follow <em>each other</em></p></div></div><div class="code"><div class="wrapper">support.sortDetached = assert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> div1 </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Should return 1, but returns 4 (following)</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span> div1.compareDocumentPosition( <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>) ) &amp; <span class="hljs-number">1</span>;
});</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE&lt;8
Prevent attribute/property &quot;interpolation&quot;
<a href="http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx">http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx</a></p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">if</span> ( !assert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> div </span>) </span>{
	div.innerHTML = <span class="hljs-string">"&lt;a href='#'&gt;&lt;/a&gt;"</span>;
	<span class="hljs-keyword">return</span> div.firstChild.getAttribute(<span class="hljs-string">"href"</span>) === <span class="hljs-string">"#"</span> ;
}) ) {
	addHandle( <span class="hljs-string">"type|href|height|width"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, name, isXML </span>) </span>{
		<span class="hljs-keyword">if</span> ( !isXML ) {
			<span class="hljs-keyword">return</span> elem.getAttribute( name, name.toLowerCase() === <span class="hljs-string">"type"</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span> );
		}
	});
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE&lt;9
Use defaultValue in place of getAttribute(&quot;value&quot;)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">if</span> ( !support.attributes || !assert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> div </span>) </span>{
	div.innerHTML = <span class="hljs-string">"&lt;input/&gt;"</span>;
	div.firstChild.setAttribute( <span class="hljs-string">"value"</span>, <span class="hljs-string">""</span> );
	<span class="hljs-keyword">return</span> div.firstChild.getAttribute( <span class="hljs-string">"value"</span> ) === <span class="hljs-string">""</span>;
}) ) {
	addHandle( <span class="hljs-string">"value"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, name, isXML </span>) </span>{
		<span class="hljs-keyword">if</span> ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === <span class="hljs-string">"input"</span> ) {
			<span class="hljs-keyword">return</span> elem.defaultValue;
		}
	});
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support: IE&lt;9
Use getAttributeNode to fetch booleans when getAttribute lies</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">if</span> ( !assert(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> div </span>) </span>{
	<span class="hljs-keyword">return</span> div.getAttribute(<span class="hljs-string">"disabled"</span>) == <span class="hljs-literal">null</span>;
}) ) {
	addHandle( booleans, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, name, isXML </span>) </span>{
		<span class="hljs-keyword">var</span> val;
		<span class="hljs-keyword">if</span> ( !isXML ) {
			<span class="hljs-keyword">return</span> elem[ name ] === <span class="hljs-literal">true</span> ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) &amp;&amp; val.specified ?
					val.value :
				<span class="hljs-literal">null</span>;
		}
	});
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>EXPOSE</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> define === <span class="hljs-string">"function"</span> &amp;&amp; define.amd ) {
	define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> Sizzle; });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sizzle requires that there be a global window in Common-JS like environments</p></div></div><div class="code"><div class="wrapper">} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> !== <span class="hljs-string">"undefined"</span> &amp;&amp; <span class="hljs-built_in">module</span>.exports ) {
	<span class="hljs-built_in">module</span>.exports = Sizzle;
} <span class="hljs-keyword">else</span> {
	<span class="hljs-built_in">window</span>.Sizzle = Sizzle;
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>EXPOSE</p></div></div><div class="code"><div class="wrapper">})( <span class="hljs-built_in">window</span> );</div></div></div></div></body></html>
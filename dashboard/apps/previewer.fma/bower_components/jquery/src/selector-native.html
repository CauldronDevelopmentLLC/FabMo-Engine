<!DOCTYPE html><html lang="en"><head><title>dashboard/apps/previewer.fma/bower_components/jquery/src/selector-native</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../../"><meta name="groc-document-path" content="dashboard/apps/previewer.fma/bower_components/jquery/src/selector-native"><meta name="groc-project-path" content="dashboard/apps/previewer.fma/bower_components/jquery/src/selector-native.js"><link rel="stylesheet" type="text/css" media="all" href="../../../../../../assets/style.css"><script type="text/javascript" src="../../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">dashboard/apps/previewer.fma/bower_components/jquery/src/selector-native.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper">define([
	<span class="hljs-string">"./core"</span>
], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> jQuery </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Optional (non-Sizzle) selector module for custom builds.</p>
<p>Note that this DOES NOT SUPPORT many documented jQuery
features in exchange for its smaller size:</p>
<p>Attribute not equal selector
Positional selectors (:first; :eq(n); :odd; etc.)
Type selectors (:input; :checkbox; :button; etc.)
State-based selectors (:animated; :visible; :hidden; etc.)
:has(selector)
:not(complex selector)
custom selectors via Sizzle extensions
Leading combinators (e.g., $collection.find(&quot;&gt; <em>&quot;))
Reliable functionality on XML fragments
Requiring all parts of a selector to match elements under context
  (e.g., $div.find(&quot;div &gt; </em>&quot;) now matches children of $div)
Matching against non-elements
Reliable sorting of disconnected nodes
querySelectorAll bug fixes (e.g., unreliable :focus on WebKit)</p>
<p>If any of these are unacceptable tradeoffs, either use Sizzle or
customize this stub for the project&#39;s specific needs.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> docElem = <span class="hljs-built_in">window</span>.document.documentElement,
	selector_hasDuplicate,
	matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector,
	selector_sortOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> a, b </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag for duplicate removal</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( a === b ) {
			selector_hasDuplicate = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		}

		<span class="hljs-keyword">var</span> compare = b.compareDocumentPosition &amp;&amp; a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( b );

		<span class="hljs-keyword">if</span> ( compare ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Disconnected nodes</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( compare &amp; <span class="hljs-number">1</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Choose the first element that is related to our document</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( a === <span class="hljs-built_in">document</span> || jQuery.contains(<span class="hljs-built_in">document</span>, a) ) {
					<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
				}
				<span class="hljs-keyword">if</span> ( b === <span class="hljs-built_in">document</span> || jQuery.contains(<span class="hljs-built_in">document</span>, b) ) {
					<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Maintain original order</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
			}

			<span class="hljs-keyword">return</span> compare &amp; <span class="hljs-number">4</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Not directly comparable, sort on existence of method</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> a.compareDocumentPosition ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
	};

jQuery.extend({
	find: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> selector, context, results, seed </span>) </span>{
		<span class="hljs-keyword">var</span> elem, nodeType,
			i = <span class="hljs-number">0</span>;

		results = results || [];
		context = context || <span class="hljs-built_in">document</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Same basic safeguard as Sizzle</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( !selector || <span class="hljs-keyword">typeof</span> selector !== <span class="hljs-string">"string"</span> ) {
			<span class="hljs-keyword">return</span> results;
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Early return if context is not an element or document</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( (nodeType = context.nodeType) !== <span class="hljs-number">1</span> &amp;&amp; nodeType !== <span class="hljs-number">9</span> ) {
			<span class="hljs-keyword">return</span> [];
		}

		<span class="hljs-keyword">if</span> ( seed ) {
			<span class="hljs-keyword">while</span> ( (elem = seed[i++]) ) {
				<span class="hljs-keyword">if</span> ( jQuery.find.matchesSelector(elem, selector) ) {
					results.push( elem );
				}
			}
		} <span class="hljs-keyword">else</span> {
			jQuery.merge( results, context.querySelectorAll(selector) );
		}

		<span class="hljs-keyword">return</span> results;
	},
	unique: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> results </span>) </span>{
		<span class="hljs-keyword">var</span> elem,
			duplicates = [],
			i = <span class="hljs-number">0</span>,
			j = <span class="hljs-number">0</span>;

		selector_hasDuplicate = <span class="hljs-literal">false</span>;
		results.sort( selector_sortOrder );

		<span class="hljs-keyword">if</span> ( selector_hasDuplicate ) {
			<span class="hljs-keyword">while</span> ( (elem = results[i++]) ) {
				<span class="hljs-keyword">if</span> ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			<span class="hljs-keyword">while</span> ( j-- ) {
				results.splice( duplicates[ j ], <span class="hljs-number">1</span> );
			}
		}

		<span class="hljs-keyword">return</span> results;
	},
	text: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
		<span class="hljs-keyword">var</span> node,
			ret = <span class="hljs-string">""</span>,
			i = <span class="hljs-number">0</span>,
			nodeType = elem.nodeType;

		<span class="hljs-keyword">if</span> ( !nodeType ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If no nodeType, this is expected to be an array</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">while</span> ( (node = elem[i++]) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Do not traverse comment nodes</p></div></div><div class="code"><div class="wrapper">				ret += jQuery.text( node );
			}
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( nodeType === <span class="hljs-number">1</span> || nodeType === <span class="hljs-number">9</span> || nodeType === <span class="hljs-number">11</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use textContent for elements</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> elem.textContent;
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( nodeType === <span class="hljs-number">3</span> || nodeType === <span class="hljs-number">4</span> ) {
			<span class="hljs-keyword">return</span> elem.nodeValue;
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Do not include comment or processing instruction nodes</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> ret;
	},
	contains: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> a, b </span>) </span>{
		<span class="hljs-keyword">var</span> adown = a.nodeType === <span class="hljs-number">9</span> ? a.documentElement : a,
			bup = b &amp;&amp; b.parentNode;
		<span class="hljs-keyword">return</span> a === bup || !!( bup &amp;&amp; bup.nodeType === <span class="hljs-number">1</span> &amp;&amp; adown.contains(bup) );
	},
	isXMLDoc: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem </span>) </span>{
		<span class="hljs-keyword">return</span> (elem.ownerDocument || elem).documentElement.nodeName !== <span class="hljs-string">"HTML"</span>;
	},
	expr: {
		attrHandle: {},
		match: {
			bool: <span class="hljs-regexp">/^(?:checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped)$/i</span>,
			needsContext: <span class="hljs-regexp">/^[\x20\t\r\n\f]*[&gt;+~]/</span>
		}
	}
});

jQuery.extend( jQuery.find, {
	matches: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> expr, elements </span>) </span>{
		<span class="hljs-keyword">return</span> jQuery.find( expr, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, elements );
	},
	matchesSelector: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, expr </span>) </span>{
		<span class="hljs-keyword">return</span> matches.call( elem, expr );
	},
	attr: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> elem, name </span>) </span>{
		<span class="hljs-keyword">return</span> elem.getAttribute( name );
	}
});

});</div></div></div></div></body></html>
<!DOCTYPE html><html lang="en"><head><title>dashboard/apps/editor.fma/js/cm-addons/searchcursor</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../"><meta name="groc-document-path" content="dashboard/apps/editor.fma/js/cm-addons/searchcursor"><meta name="groc-project-path" content="dashboard/apps/editor.fma/js/cm-addons/searchcursor.js"><link rel="stylesheet" type="text/css" media="all" href="../../../../../assets/style.css"><script type="text/javascript" src="../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">dashboard/apps/editor.fma/js/cm-addons/searchcursor.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>CodeMirror, copyright (c) by Marijn Haverbeke and others
Distributed under an MIT license: <a href="http://codemirror.net/LICENSE">http://codemirror.net/LICENSE</a></p></div></div><div class="code"><div class="wrapper">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mod</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports == <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> == <span class="hljs-string">"object"</span>) <span class="hljs-comment">// CommonJS</span>
    mod(<span class="hljs-built_in">require</span>(<span class="hljs-string">"../../lib/codemirror"</span>));
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define == <span class="hljs-string">"function"</span> &amp;&amp; define.amd) <span class="hljs-comment">// AMD</span>
    define([<span class="hljs-string">"../../lib/codemirror"</span>], mod);
  <span class="hljs-keyword">else</span> <span class="hljs-comment">// Plain browser env</span>
    mod(CodeMirror);
})(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">CodeMirror</span>) </span>{
<span class="hljs-pi">  "use strict"</span>;
  <span class="hljs-keyword">var</span> Pos = CodeMirror.Pos;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchCursor</span>(<span class="hljs-params">doc, query, pos, caseFold</span>) </span>{
    <span class="hljs-keyword">this</span>.atOccurrence = <span class="hljs-literal">false</span>; <span class="hljs-keyword">this</span>.doc = doc;
    <span class="hljs-keyword">if</span> (caseFold == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> query == <span class="hljs-string">"string"</span>) caseFold = <span class="hljs-literal">false</span>;

    pos = pos ? doc.clipPos(pos) : Pos(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">this</span>.pos = {from: pos, to: pos};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The matches method is filled in based on the type of query.
It takes a position and a direction, and returns an object
describing the next occurrence of the query, or null if no
more matches were found.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> query != <span class="hljs-string">"string"</span>) { <span class="hljs-comment">// Regexp match</span>
      <span class="hljs-keyword">if</span> (!query.global) query = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(query.source, query.ignoreCase ? <span class="hljs-string">"ig"</span> : <span class="hljs-string">"g"</span>);
      <span class="hljs-keyword">this</span>.matches = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reverse, pos</span>) </span>{
        <span class="hljs-keyword">if</span> (reverse) {
          query.lastIndex = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> line = doc.getLine(pos.line).slice(<span class="hljs-number">0</span>, pos.ch), cutOff = <span class="hljs-number">0</span>, match, start;
          <span class="hljs-keyword">for</span> (;;) {
            query.lastIndex = cutOff;
            <span class="hljs-keyword">var</span> newMatch = query.exec(line);
            <span class="hljs-keyword">if</span> (!newMatch) <span class="hljs-keyword">break</span>;
            match = newMatch;
            start = match.index;
            cutOff = match.index + (match[<span class="hljs-number">0</span>].length || <span class="hljs-number">1</span>);
            <span class="hljs-keyword">if</span> (cutOff == line.length) <span class="hljs-keyword">break</span>;
          }
          <span class="hljs-keyword">var</span> matchLen = (match &amp;&amp; match[<span class="hljs-number">0</span>].length) || <span class="hljs-number">0</span>;
          <span class="hljs-keyword">if</span> (!matchLen) {
            <span class="hljs-keyword">if</span> (start == <span class="hljs-number">0</span> &amp;&amp; line.length == <span class="hljs-number">0</span>) {match = <span class="hljs-literal">undefined</span>;}
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start != doc.getLine(pos.line).length) {
              matchLen++;
            }
          }
        } <span class="hljs-keyword">else</span> {
          query.lastIndex = pos.ch;
          <span class="hljs-keyword">var</span> line = doc.getLine(pos.line), match = query.exec(line);
          <span class="hljs-keyword">var</span> matchLen = (match &amp;&amp; match[<span class="hljs-number">0</span>].length) || <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> start = match &amp;&amp; match.index;
          <span class="hljs-keyword">if</span> (start + matchLen != line.length &amp;&amp; !matchLen) matchLen = <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">if</span> (match &amp;&amp; matchLen)
          <span class="hljs-keyword">return</span> {from: Pos(pos.line, start),
                  to: Pos(pos.line, start + matchLen),
                  match: match};
      };
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// String query</span>
      <span class="hljs-keyword">var</span> origQuery = query;
      <span class="hljs-keyword">if</span> (caseFold) query = query.toLowerCase();
      <span class="hljs-keyword">var</span> fold = caseFold ? <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>)</span>{<span class="hljs-keyword">return</span> str.toLowerCase();} : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>)</span>{<span class="hljs-keyword">return</span> str;};
      <span class="hljs-keyword">var</span> target = query.split(<span class="hljs-string">"\n"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Different methods for single-line and multi-line queries</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (target.length == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (!query.length) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Empty string would match anything and never progress, so
we define it to match nothing instead.</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">this</span>.matches = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">this</span>.matches = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reverse, pos</span>) </span>{
            <span class="hljs-keyword">if</span> (reverse) {
              <span class="hljs-keyword">var</span> orig = doc.getLine(pos.line).slice(<span class="hljs-number">0</span>, pos.ch), line = fold(orig);
              <span class="hljs-keyword">var</span> match = line.lastIndexOf(query);
              <span class="hljs-keyword">if</span> (match &gt; -<span class="hljs-number">1</span>) {
                match = adjustPos(orig, line, match);
                <span class="hljs-keyword">return</span> {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
              }
             } <span class="hljs-keyword">else</span> {
               <span class="hljs-keyword">var</span> orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);
               <span class="hljs-keyword">var</span> match = line.indexOf(query);
               <span class="hljs-keyword">if</span> (match &gt; -<span class="hljs-number">1</span>) {
                 match = adjustPos(orig, line, match) + pos.ch;
                 <span class="hljs-keyword">return</span> {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
               }
            }
          };
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> origTarget = origQuery.split(<span class="hljs-string">"\n"</span>);
        <span class="hljs-keyword">this</span>.matches = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reverse, pos</span>) </span>{
          <span class="hljs-keyword">var</span> last = target.length - <span class="hljs-number">1</span>;
          <span class="hljs-keyword">if</span> (reverse) {
            <span class="hljs-keyword">if</span> (pos.line - (target.length - <span class="hljs-number">1</span>) &lt; doc.firstLine()) <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">if</span> (fold(doc.getLine(pos.line).slice(<span class="hljs-number">0</span>, origTarget[last].length)) != target[target.length - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">var</span> to = Pos(pos.line, origTarget[last].length);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> ln = pos.line - <span class="hljs-number">1</span>, i = last - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; --i, --ln)
              <span class="hljs-keyword">if</span> (target[i] != fold(doc.getLine(ln))) <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">var</span> line = doc.getLine(ln), cut = line.length - origTarget[<span class="hljs-number">0</span>].length;
            <span class="hljs-keyword">if</span> (fold(line.slice(cut)) != target[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">return</span> {from: Pos(ln, cut), to: to};
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (pos.line + (target.length - <span class="hljs-number">1</span>) &gt; doc.lastLine()) <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">var</span> line = doc.getLine(pos.line), cut = line.length - origTarget[<span class="hljs-number">0</span>].length;
            <span class="hljs-keyword">if</span> (fold(line.slice(cut)) != target[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">var</span> from = Pos(pos.line, cut);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> ln = pos.line + <span class="hljs-number">1</span>, i = <span class="hljs-number">1</span>; i &lt; last; ++i, ++ln)
              <span class="hljs-keyword">if</span> (target[i] != fold(doc.getLine(ln))) <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">if</span> (fold(doc.getLine(ln).slice(<span class="hljs-number">0</span>, origTarget[last].length)) != target[last]) <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">return</span> {from: from, to: Pos(ln, origTarget[last].length)};
          }
        };
      }
    }
  }

  SearchCursor.prototype = {
    findNext: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find(<span class="hljs-literal">false</span>);},
    findPrevious: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find(<span class="hljs-literal">true</span>);},

    find: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reverse</span>) </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, pos = <span class="hljs-keyword">this</span>.doc.clipPos(reverse ? <span class="hljs-keyword">this</span>.pos.from : <span class="hljs-keyword">this</span>.pos.to);
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">savePosAndFail</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">var</span> pos = Pos(line, <span class="hljs-number">0</span>);
        self.pos = {from: pos, to: pos};
        self.atOccurrence = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">for</span> (;;) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pos = <span class="hljs-keyword">this</span>.matches(reverse, pos)) {
          <span class="hljs-keyword">this</span>.atOccurrence = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pos.match || <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">if</span> (reverse) {
          <span class="hljs-keyword">if</span> (!pos.line) <span class="hljs-keyword">return</span> savePosAndFail(<span class="hljs-number">0</span>);
          pos = Pos(pos.line-<span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.doc.getLine(pos.line-<span class="hljs-number">1</span>).length);
        }
        <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> maxLine = <span class="hljs-keyword">this</span>.doc.lineCount();
          <span class="hljs-keyword">if</span> (pos.line == maxLine - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> savePosAndFail(maxLine);
          pos = Pos(pos.line + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
        }
      }
    },

    from: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.atOccurrence) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pos.from;},
    to: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.atOccurrence) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pos.to;},

    replace: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newText, origin</span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.atOccurrence) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">var</span> lines = CodeMirror.splitLines(newText);
      <span class="hljs-keyword">this</span>.doc.replaceRange(lines, <span class="hljs-keyword">this</span>.pos.from, <span class="hljs-keyword">this</span>.pos.to, origin);
      <span class="hljs-keyword">this</span>.pos.to = Pos(<span class="hljs-keyword">this</span>.pos.from.line + lines.length - <span class="hljs-number">1</span>,
                        lines[lines.length - <span class="hljs-number">1</span>].length + (lines.length == <span class="hljs-number">1</span> ? <span class="hljs-keyword">this</span>.pos.from.ch : <span class="hljs-number">0</span>));
    }
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Maps a position in a case-folded line back to a position in the original line
(compensating for codepoints increasing in number during folding)</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adjustPos</span>(<span class="hljs-params">orig, folded, pos</span>) </span>{
    <span class="hljs-keyword">if</span> (orig.length == folded.length) <span class="hljs-keyword">return</span> pos;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> pos1 = <span class="hljs-built_in">Math</span>.min(pos, orig.length);;) {
      <span class="hljs-keyword">var</span> len1 = orig.slice(<span class="hljs-number">0</span>, pos1).toLowerCase().length;
      <span class="hljs-keyword">if</span> (len1 &lt; pos) ++pos1;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len1 &gt; pos) --pos1;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> pos1;
    }
  }

  CodeMirror.defineExtension(<span class="hljs-string">"getSearchCursor"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">query, pos, caseFold</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SearchCursor(<span class="hljs-keyword">this</span>.doc, query, pos, caseFold);
  });
  CodeMirror.defineDocExtension(<span class="hljs-string">"getSearchCursor"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">query, pos, caseFold</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SearchCursor(<span class="hljs-keyword">this</span>, query, pos, caseFold);
  });

  CodeMirror.defineExtension(<span class="hljs-string">"selectMatches"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">query, caseFold</span>) </span>{
    <span class="hljs-keyword">var</span> ranges = [];
    <span class="hljs-keyword">var</span> cur = <span class="hljs-keyword">this</span>.getSearchCursor(query, <span class="hljs-keyword">this</span>.getCursor(<span class="hljs-string">"from"</span>), caseFold);
    <span class="hljs-keyword">while</span> (cur.findNext()) {
      <span class="hljs-keyword">if</span> (CodeMirror.cmpPos(cur.to(), <span class="hljs-keyword">this</span>.getCursor(<span class="hljs-string">"to"</span>)) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
      ranges.push({anchor: cur.from(), head: cur.to()});
    }
    <span class="hljs-keyword">if</span> (ranges.length)
      <span class="hljs-keyword">this</span>.setSelections(ranges, <span class="hljs-number">0</span>);
  });
});</div></div></div></div></body></html>
<!DOCTYPE html><html lang="en"><head><title>dashboard/apps/editor.fma/js/codemirror</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../"><meta name="groc-document-path" content="dashboard/apps/editor.fma/js/codemirror"><meta name="groc-project-path" content="dashboard/apps/editor.fma/js/codemirror.js"><link rel="stylesheet" type="text/css" media="all" href="../../../../assets/style.css"><script type="text/javascript" src="../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">dashboard/apps/editor.fma/js/codemirror.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>CodeMirror, copyright (c) by Marijn Haverbeke and others
Distributed under an MIT license: <a href="http://codemirror.net/LICENSE">http://codemirror.net/LICENSE</a></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is CodeMirror (<a href="http://codemirror.net">http://codemirror.net</a>), a code editor
implemented in JavaScript on top of the browser&#39;s DOM.</p>
<p>You can find some technical background for some of the code below
at <a href="http://marijnhaverbeke.nl/blog/#cm-internals">http://marijnhaverbeke.nl/blog/#cm-internals</a> .</p></div></div><div class="code"><div class="wrapper">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mod</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports == <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> == <span class="hljs-string">"object"</span>) <span class="hljs-comment">// CommonJS</span>
    <span class="hljs-built_in">module</span>.exports = mod();
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define == <span class="hljs-string">"function"</span> &amp;&amp; define.amd) <span class="hljs-comment">// AMD</span>
    <span class="hljs-keyword">return</span> define([], mod);
  <span class="hljs-keyword">else</span> <span class="hljs-comment">// Plain browser env</span>
    (<span class="hljs-keyword">this</span> || <span class="hljs-built_in">window</span>).CodeMirror = mod();
})(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-pi">  "use strict"</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>BROWSER SNIFFING</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Kludges for bugs and behavior differences that can&#39;t be feature
detected are enabled based on userAgent etc sniffing.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> userAgent = navigator.userAgent;
  <span class="hljs-keyword">var</span> platform = navigator.platform;

  <span class="hljs-keyword">var</span> gecko = <span class="hljs-regexp">/gecko\/\d/i</span>.test(userAgent);
  <span class="hljs-keyword">var</span> ie_upto10 = <span class="hljs-regexp">/MSIE \d/</span>.test(userAgent);
  <span class="hljs-keyword">var</span> ie_11up = <span class="hljs-regexp">/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/</span>.exec(userAgent);
  <span class="hljs-keyword">var</span> ie = ie_upto10 || ie_11up;
  <span class="hljs-keyword">var</span> ie_version = ie &amp;&amp; (ie_upto10 ? <span class="hljs-built_in">document</span>.documentMode || <span class="hljs-number">6</span> : ie_11up[<span class="hljs-number">1</span>]);
  <span class="hljs-keyword">var</span> webkit = <span class="hljs-regexp">/WebKit\//</span>.test(userAgent);
  <span class="hljs-keyword">var</span> qtwebkit = webkit &amp;&amp; <span class="hljs-regexp">/Qt\/\d+\.\d+/</span>.test(userAgent);
  <span class="hljs-keyword">var</span> chrome = <span class="hljs-regexp">/Chrome\//</span>.test(userAgent);
  <span class="hljs-keyword">var</span> presto = <span class="hljs-regexp">/Opera\//</span>.test(userAgent);
  <span class="hljs-keyword">var</span> safari = <span class="hljs-regexp">/Apple Computer/</span>.test(navigator.vendor);
  <span class="hljs-keyword">var</span> mac_geMountainLion = <span class="hljs-regexp">/Mac OS X 1\d\D([8-9]|\d\d)\D/</span>.test(userAgent);
  <span class="hljs-keyword">var</span> phantom = <span class="hljs-regexp">/PhantomJS/</span>.test(userAgent);

  <span class="hljs-keyword">var</span> ios = <span class="hljs-regexp">/AppleWebKit/</span>.test(userAgent) &amp;&amp; <span class="hljs-regexp">/Mobile\/\w+/</span>.test(userAgent);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is woefully incomplete. Suggestions for alternative methods welcome.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> mobile = ios || <span class="hljs-regexp">/Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i</span>.test(userAgent);
  <span class="hljs-keyword">var</span> mac = ios || <span class="hljs-regexp">/Mac/</span>.test(platform);
  <span class="hljs-keyword">var</span> chromeOS = <span class="hljs-regexp">/\bCrOS\b/</span>.test(userAgent);
  <span class="hljs-keyword">var</span> windows = <span class="hljs-regexp">/win/i</span>.test(platform);

  <span class="hljs-keyword">var</span> presto_version = presto &amp;&amp; userAgent.match(<span class="hljs-regexp">/Version\/(\d*\.\d*)/</span>);
  <span class="hljs-keyword">if</span> (presto_version) presto_version = <span class="hljs-built_in">Number</span>(presto_version[<span class="hljs-number">1</span>]);
  <span class="hljs-keyword">if</span> (presto_version &amp;&amp; presto_version &gt;= <span class="hljs-number">15</span>) { presto = <span class="hljs-literal">false</span>; webkit = <span class="hljs-literal">true</span>; }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Some browsers use the wrong event properties to signal cmd/ctrl on OS X</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> flipCtrlCmd = mac &amp;&amp; (qtwebkit || presto &amp;&amp; (presto_version == <span class="hljs-literal">null</span> || presto_version &lt; <span class="hljs-number">12.11</span>));
  <span class="hljs-keyword">var</span> captureRightClick = gecko || (ie &amp;&amp; ie_version &gt;= <span class="hljs-number">9</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Optimize some code when these features are not used.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> sawReadOnlySpans = <span class="hljs-literal">false</span>, sawCollapsedSpans = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>EDITOR CONSTRUCTOR</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A CodeMirror instance represents an editor. This is the object
that user code is usually dealing with.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CodeMirror</span>(<span class="hljs-params">place, options</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> CodeMirror)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CodeMirror(place, options);

    <span class="hljs-keyword">this</span>.options = options = options ? copyObj(options) : {};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Determine effective options based on given values and defaults.</p></div></div><div class="code"><div class="wrapper">    copyObj(defaults, options, <span class="hljs-literal">false</span>);
    setGuttersForLineNumbers(options);

    <span class="hljs-keyword">var</span> doc = options.value;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> doc == <span class="hljs-string">"string"</span>) doc = <span class="hljs-keyword">new</span> Doc(doc, options.mode, <span class="hljs-literal">null</span>, options.lineSeparator);
    <span class="hljs-keyword">this</span>.doc = doc;

    <span class="hljs-keyword">var</span> input = <span class="hljs-keyword">new</span> CodeMirror.inputStyles[options.inputStyle](<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">var</span> display = <span class="hljs-keyword">this</span>.display = <span class="hljs-keyword">new</span> Display(place, doc, input);
    display.wrapper.CodeMirror = <span class="hljs-keyword">this</span>;
    updateGutters(<span class="hljs-keyword">this</span>);
    themeChanged(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">if</span> (options.lineWrapping)
      <span class="hljs-keyword">this</span>.display.wrapper.className += <span class="hljs-string">" CodeMirror-wrap"</span>;
    <span class="hljs-keyword">if</span> (options.autofocus &amp;&amp; !mobile) display.input.focus();
    initScrollbars(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">this</span>.state = {
      keyMaps: [],  <span class="hljs-comment">// stores maps added by addKeyMap</span>
      overlays: [], <span class="hljs-comment">// highlighting overlays, as added by addOverlay</span>
      modeGen: <span class="hljs-number">0</span>,   <span class="hljs-comment">// bumped when mode/overlay changes, used to invalidate highlighting info</span>
      overwrite: <span class="hljs-literal">false</span>,
      delayingBlurEvent: <span class="hljs-literal">false</span>,
      focused: <span class="hljs-literal">false</span>,
      suppressEdits: <span class="hljs-literal">false</span>, <span class="hljs-comment">// used to disable editing during key handlers when in readOnly mode</span>
      pasteIncoming: <span class="hljs-literal">false</span>, cutIncoming: <span class="hljs-literal">false</span>, <span class="hljs-comment">// help recognize paste/cut edits in input.poll</span>
      selectingText: <span class="hljs-literal">false</span>,
      draggingText: <span class="hljs-literal">false</span>,
      highlight: <span class="hljs-keyword">new</span> Delayed(), <span class="hljs-comment">// stores highlight worker timeout</span>
      keySeq: <span class="hljs-literal">null</span>,  <span class="hljs-comment">// Unfinished key sequence</span>
      specialChars: <span class="hljs-literal">null</span>
    };

    <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Override magic textarea content restore that IE sometimes does
on our hidden textarea on reload</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">11</span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ cm.display.input.reset(<span class="hljs-literal">true</span>); }, <span class="hljs-number">20</span>);

    registerEventHandlers(<span class="hljs-keyword">this</span>);
    ensureGlobalHandlers();

    startOperation(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.curOp.forceUpdate = <span class="hljs-literal">true</span>;
    attachDoc(<span class="hljs-keyword">this</span>, doc);

    <span class="hljs-keyword">if</span> ((options.autofocus &amp;&amp; !mobile) || cm.hasFocus())
      setTimeout(bind(onFocus, <span class="hljs-keyword">this</span>), <span class="hljs-number">20</span>);
    <span class="hljs-keyword">else</span>
      onBlur(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> opt <span class="hljs-keyword">in</span> optionHandlers) <span class="hljs-keyword">if</span> (optionHandlers.hasOwnProperty(opt))
      optionHandlers[opt](<span class="hljs-keyword">this</span>, options[opt], Init);
    maybeUpdateLineNumberWidth(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">if</span> (options.finishInit) options.finishInit(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; initHooks.length; ++i) initHooks[i](<span class="hljs-keyword">this</span>);
    endOperation(<span class="hljs-keyword">this</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Suppress optimizelegibility in Webkit, since it breaks text
measuring on line wrapping boundaries.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (webkit &amp;&amp; options.lineWrapping &amp;&amp;
        getComputedStyle(display.lineDiv).textRendering == <span class="hljs-string">"optimizelegibility"</span>)
      display.lineDiv.style.textRendering = <span class="hljs-string">"auto"</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DISPLAY CONSTRUCTOR</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The display handles the DOM integration, both for input reading
and content drawing. It holds references to DOM nodes and
display-related state.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Display</span>(<span class="hljs-params">place, doc, input</span>) </span>{
    <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.input = input;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Covers bottom-right square when both scrollbars are present.</p></div></div><div class="code"><div class="wrapper">    d.scrollbarFiller = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-scrollbar-filler"</span>);
    d.scrollbarFiller.setAttribute(<span class="hljs-string">"cm-not-content"</span>, <span class="hljs-string">"true"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Covers bottom of gutter when coverGutterNextToScrollbar is on
and h scrollbar is present.</p></div></div><div class="code"><div class="wrapper">    d.gutterFiller = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-gutter-filler"</span>);
    d.gutterFiller.setAttribute(<span class="hljs-string">"cm-not-content"</span>, <span class="hljs-string">"true"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Will contain the actual code, positioned to cover the viewport.</p></div></div><div class="code"><div class="wrapper">    d.lineDiv = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-code"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Elements are added to these to represent selection and cursors.</p></div></div><div class="code"><div class="wrapper">    d.selectionDiv = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"position: relative; z-index: 1"</span>);
    d.cursorDiv = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-cursors"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A visibility: hidden element used to find the size of things.</p></div></div><div class="code"><div class="wrapper">    d.measure = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-measure"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When lines outside of the viewport are measured, they are drawn in this.</p></div></div><div class="code"><div class="wrapper">    d.lineMeasure = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-measure"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Wraps everything that needs to exist inside the vertically-padded coordinate system</p></div></div><div class="code"><div class="wrapper">    d.lineSpace = elt(<span class="hljs-string">"div"</span>, [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      <span class="hljs-literal">null</span>, <span class="hljs-string">"position: relative; outline: none"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Moved around its parent to cover visible view.</p></div></div><div class="code"><div class="wrapper">    d.mover = elt(<span class="hljs-string">"div"</span>, [elt(<span class="hljs-string">"div"</span>, [d.lineSpace], <span class="hljs-string">"CodeMirror-lines"</span>)], <span class="hljs-literal">null</span>, <span class="hljs-string">"position: relative"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set to the height of the document, allowing scrolling.</p></div></div><div class="code"><div class="wrapper">    d.sizer = elt(<span class="hljs-string">"div"</span>, [d.mover], <span class="hljs-string">"CodeMirror-sizer"</span>);
    d.sizerWidth = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Behavior of elts with overflow: auto and padding is
inconsistent across browsers. This is used to ensure the
scrollable area is big enough.</p></div></div><div class="code"><div class="wrapper">    d.heightForcer = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"position: absolute; height: "</span> + scrollerGap + <span class="hljs-string">"px; width: 1px;"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Will contain the gutters, if any.</p></div></div><div class="code"><div class="wrapper">    d.gutters = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-gutters"</span>);
    d.lineGutter = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Actual scrollable element.</p></div></div><div class="code"><div class="wrapper">    d.scroller = elt(<span class="hljs-string">"div"</span>, [d.sizer, d.heightForcer, d.gutters], <span class="hljs-string">"CodeMirror-scroll"</span>);
    d.scroller.setAttribute(<span class="hljs-string">"tabIndex"</span>, <span class="hljs-string">"-1"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The element in which the editor lives.</p></div></div><div class="code"><div class="wrapper">    d.wrapper = elt(<span class="hljs-string">"div"</span>, [d.scrollbarFiller, d.gutterFiller, d.scroller], <span class="hljs-string">"CodeMirror"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">8</span>) { d.gutters.style.zIndex = -<span class="hljs-number">1</span>; d.scroller.style.paddingRight = <span class="hljs-number">0</span>; }
    <span class="hljs-keyword">if</span> (!webkit &amp;&amp; !(gecko &amp;&amp; mobile)) d.scroller.draggable = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">if</span> (place) {
      <span class="hljs-keyword">if</span> (place.appendChild) place.appendChild(d.wrapper);
      <span class="hljs-keyword">else</span> place(d.wrapper);
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Current rendered range (may be bigger than the view window).</p></div></div><div class="code"><div class="wrapper">    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Information about the rendered lines.</p></div></div><div class="code"><div class="wrapper">    d.view = [];
    d.renderedView = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Holds info about a single rendered line when it was rendered
for measurement, while not in view.</p></div></div><div class="code"><div class="wrapper">    d.externalMeasured = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Empty space (in pixels) above the view</p></div></div><div class="code"><div class="wrapper">    d.viewOffset = <span class="hljs-number">0</span>;
    d.lastWrapHeight = d.lastWrapWidth = <span class="hljs-number">0</span>;
    d.updateLineNumbers = <span class="hljs-literal">null</span>;

    d.nativeBarWidth = d.barHeight = d.barWidth = <span class="hljs-number">0</span>;
    d.scrollbarsClipped = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to only resize the line number gutter when necessary (when
the amount of lines crosses a boundary that makes its width change)</p></div></div><div class="code"><div class="wrapper">    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set to true when a non-horizontal-scrolling line widget is
added. As an optimization, line widget aligning is skipped when
this is false.</p></div></div><div class="code"><div class="wrapper">    d.alignWidgets = <span class="hljs-literal">false</span>;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Tracks the maximum line length so that the horizontal scrollbar
can be kept static when scrolling.</p></div></div><div class="code"><div class="wrapper">    d.maxLine = <span class="hljs-literal">null</span>;
    d.maxLineLength = <span class="hljs-number">0</span>;
    d.maxLineChanged = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used for measuring wheel scrolling granularity</p></div></div><div class="code"><div class="wrapper">    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>True when shift is held down.</p></div></div><div class="code"><div class="wrapper">    d.shift = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to track whether anything happened since the context menu
was opened.</p></div></div><div class="code"><div class="wrapper">    d.selForContextMenu = <span class="hljs-literal">null</span>;

    d.activeTouch = <span class="hljs-literal">null</span>;

    input.init(d);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>STATE UPDATES</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to get the editor into a consistent state again when options change.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadMode</span>(<span class="hljs-params">cm</span>) </span>{
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetModeState</span>(<span class="hljs-params">cm</span>) </span>{
    cm.doc.iter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">if</span> (line.stateAfter) line.stateAfter = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">if</span> (line.styles) line.styles = <span class="hljs-literal">null</span>;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, <span class="hljs-number">100</span>);
    cm.state.modeGen++;
    <span class="hljs-keyword">if</span> (cm.curOp) regChange(cm);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappingChanged</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">if</span> (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, <span class="hljs-string">"CodeMirror-wrap"</span>);
      cm.display.sizer.style.minWidth = <span class="hljs-string">""</span>;
      cm.display.sizerWidth = <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {
      rmClass(cm.display.wrapper, <span class="hljs-string">"CodeMirror-wrap"</span>);
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{updateScrollbars(cm);}, <span class="hljs-number">100</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns a function that estimates the height of a line, to use as
first approximation until the line becomes visible (and is thus
properly measurable).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">estimateHeight</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    <span class="hljs-keyword">var</span> perLine = wrapping &amp;&amp; <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">5</span>, cm.display.scroller.clientWidth / charWidth(cm.display) - <span class="hljs-number">3</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">if</span> (lineIsHidden(cm.doc, line)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

      <span class="hljs-keyword">var</span> widgetsHeight = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (line.widgets) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; line.widgets.length; i++) {
        <span class="hljs-keyword">if</span> (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      <span class="hljs-keyword">if</span> (wrapping)
        <span class="hljs-keyword">return</span> widgetsHeight + (<span class="hljs-built_in">Math</span>.ceil(line.text.length / perLine) || <span class="hljs-number">1</span>) * th;
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> widgetsHeight + th;
    };
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">estimateLineHeights</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> doc = cm.doc, est = estimateHeight(cm);
    doc.iter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">var</span> estHeight = est(line);
      <span class="hljs-keyword">if</span> (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">themeChanged</span>(<span class="hljs-params">cm</span>) </span>{
    cm.display.wrapper.className = cm.display.wrapper.className.replace(<span class="hljs-regexp">/\s*cm-s-\S+/g</span>, <span class="hljs-string">""</span>) +
      cm.options.theme.replace(<span class="hljs-regexp">/(^|\s)\s*/g</span>, <span class="hljs-string">" cm-s-"</span>);
    clearCaches(cm);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guttersChanged</span>(<span class="hljs-params">cm</span>) </span>{
    updateGutters(cm);
    regChange(cm);
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{alignHorizontally(cm);}, <span class="hljs-number">20</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Rebuild the gutter elements, ensure the margin to the left of the
code matches their width.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateGutters</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; specs.length; ++i) {
      <span class="hljs-keyword">var</span> gutterClass = specs[i];
      <span class="hljs-keyword">var</span> gElt = gutters.appendChild(elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-gutter "</span> + gutterClass));
      <span class="hljs-keyword">if</span> (gutterClass == <span class="hljs-string">"CodeMirror-linenumbers"</span>) {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || <span class="hljs-number">1</span>) + <span class="hljs-string">"px"</span>;
      }
    }
    gutters.style.display = i ? <span class="hljs-string">""</span> : <span class="hljs-string">"none"</span>;
    updateGutterSpace(cm);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateGutterSpace</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + <span class="hljs-string">"px"</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute the character length of a line, taking into account
collapsed ranges (see markText) that might hide parts, and join
other lines onto it.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineLength</span>(<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">if</span> (line.height == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> len = line.text.length, merged, cur = line;
    <span class="hljs-keyword">while</span> (merged = collapsedSpanAtStart(cur)) {
      <span class="hljs-keyword">var</span> found = merged.find(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    <span class="hljs-keyword">while</span> (merged = collapsedSpanAtEnd(cur)) {
      <span class="hljs-keyword">var</span> found = merged.find(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    <span class="hljs-keyword">return</span> len;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the longest line in the document.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findMaxLine</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = <span class="hljs-literal">true</span>;
    doc.iter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">var</span> len = lineLength(line);
      <span class="hljs-keyword">if</span> (len &gt; d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make sure the gutters options contains the element
&quot;CodeMirror-linenumbers&quot; when the lineNumbers option is true.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setGuttersForLineNumbers</span>(<span class="hljs-params">options</span>) </span>{
    <span class="hljs-keyword">var</span> found = indexOf(options.gutters, <span class="hljs-string">"CodeMirror-linenumbers"</span>);
    <span class="hljs-keyword">if</span> (found == -<span class="hljs-number">1</span> &amp;&amp; options.lineNumbers) {
      options.gutters = options.gutters.concat([<span class="hljs-string">"CodeMirror-linenumbers"</span>]);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (found &gt; -<span class="hljs-number">1</span> &amp;&amp; !options.lineNumbers) {
      options.gutters = options.gutters.slice(<span class="hljs-number">0</span>);
      options.gutters.splice(found, <span class="hljs-number">1</span>);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>SCROLLBARS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prepare DOM reads needed to update the scrollbars. Done in one
shot to minimize update/measure roundtrips.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">measureForScrollbars</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> d = cm.display, gutterW = d.gutters.offsetWidth;
    <span class="hljs-keyword">var</span> docH = <span class="hljs-built_in">Math</span>.round(cm.doc.height + paddingVert(cm.display));
    <span class="hljs-keyword">return</span> {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : <span class="hljs-number">0</span>,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NativeScrollbars</span>(<span class="hljs-params">place, scroll, cm</span>) </span>{
    <span class="hljs-keyword">this</span>.cm = cm;
    <span class="hljs-keyword">var</span> vert = <span class="hljs-keyword">this</span>.vert = elt(<span class="hljs-string">"div"</span>, [elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"min-width: 1px"</span>)], <span class="hljs-string">"CodeMirror-vscrollbar"</span>);
    <span class="hljs-keyword">var</span> horiz = <span class="hljs-keyword">this</span>.horiz = elt(<span class="hljs-string">"div"</span>, [elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"height: 100%; min-height: 1px"</span>)], <span class="hljs-string">"CodeMirror-hscrollbar"</span>);
    place(vert); place(horiz);

    on(vert, <span class="hljs-string">"scroll"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (vert.clientHeight) scroll(vert.scrollTop, <span class="hljs-string">"vertical"</span>);
    });
    on(horiz, <span class="hljs-string">"scroll"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (horiz.clientWidth) scroll(horiz.scrollLeft, <span class="hljs-string">"horizontal"</span>);
    });

    <span class="hljs-keyword">this</span>.checkedZeroWidth = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">8</span>) <span class="hljs-keyword">this</span>.horiz.style.minHeight = <span class="hljs-keyword">this</span>.vert.style.minWidth = <span class="hljs-string">"18px"</span>;
  }

  NativeScrollbars.prototype = copyObj({
    update: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">measure</span>) </span>{
      <span class="hljs-keyword">var</span> needsH = measure.scrollWidth &gt; measure.clientWidth + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">var</span> needsV = measure.scrollHeight &gt; measure.clientHeight + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">var</span> sWidth = measure.nativeBarWidth;

      <span class="hljs-keyword">if</span> (needsV) {
        <span class="hljs-keyword">this</span>.vert.style.display = <span class="hljs-string">"block"</span>;
        <span class="hljs-keyword">this</span>.vert.style.bottom = needsH ? sWidth + <span class="hljs-string">"px"</span> : <span class="hljs-string">"0"</span>;
        <span class="hljs-keyword">var</span> totalHeight = measure.viewHeight - (needsH ? sWidth : <span class="hljs-number">0</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A bug in IE8 can cause this value to be negative, so guard it.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">this</span>.vert.firstChild.style.height =
          <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, measure.scrollHeight - measure.clientHeight + totalHeight) + <span class="hljs-string">"px"</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.vert.style.display = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">this</span>.vert.firstChild.style.height = <span class="hljs-string">"0"</span>;
      }

      <span class="hljs-keyword">if</span> (needsH) {
        <span class="hljs-keyword">this</span>.horiz.style.display = <span class="hljs-string">"block"</span>;
        <span class="hljs-keyword">this</span>.horiz.style.right = needsV ? sWidth + <span class="hljs-string">"px"</span> : <span class="hljs-string">"0"</span>;
        <span class="hljs-keyword">this</span>.horiz.style.left = measure.barLeft + <span class="hljs-string">"px"</span>;
        <span class="hljs-keyword">var</span> totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : <span class="hljs-number">0</span>);
        <span class="hljs-keyword">this</span>.horiz.firstChild.style.width =
          (measure.scrollWidth - measure.clientWidth + totalWidth) + <span class="hljs-string">"px"</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.horiz.style.display = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">this</span>.horiz.firstChild.style.width = <span class="hljs-string">"0"</span>;
      }

      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.checkedZeroWidth &amp;&amp; measure.clientHeight &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (sWidth == <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>.zeroWidthHack();
        <span class="hljs-keyword">this</span>.checkedZeroWidth = <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">return</span> {right: needsV ? sWidth : <span class="hljs-number">0</span>, bottom: needsH ? sWidth : <span class="hljs-number">0</span>};
    },
    setScrollLeft: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.horiz.scrollLeft != pos) <span class="hljs-keyword">this</span>.horiz.scrollLeft = pos;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.disableHoriz) <span class="hljs-keyword">this</span>.enableZeroWidthBar(<span class="hljs-keyword">this</span>.horiz, <span class="hljs-keyword">this</span>.disableHoriz);
    },
    setScrollTop: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.vert.scrollTop != pos) <span class="hljs-keyword">this</span>.vert.scrollTop = pos;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.disableVert) <span class="hljs-keyword">this</span>.enableZeroWidthBar(<span class="hljs-keyword">this</span>.vert, <span class="hljs-keyword">this</span>.disableVert);
    },
    zeroWidthHack: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> w = mac &amp;&amp; !mac_geMountainLion ? <span class="hljs-string">"12px"</span> : <span class="hljs-string">"18px"</span>;
      <span class="hljs-keyword">this</span>.horiz.style.height = <span class="hljs-keyword">this</span>.vert.style.width = w;
      <span class="hljs-keyword">this</span>.horiz.style.pointerEvents = <span class="hljs-keyword">this</span>.vert.style.pointerEvents = <span class="hljs-string">"none"</span>;
      <span class="hljs-keyword">this</span>.disableHoriz = <span class="hljs-keyword">new</span> Delayed;
      <span class="hljs-keyword">this</span>.disableVert = <span class="hljs-keyword">new</span> Delayed;
    },
    enableZeroWidthBar: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bar, delay</span>) </span>{
      bar.style.pointerEvents = <span class="hljs-string">"auto"</span>;
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybeDisable</span>(<span class="hljs-params"></span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>To find out whether the scrollbar is still visible, we
check whether the element under the pixel in the bottom
left corner of the scrollbar box is the scrollbar box
itself (when the bar is still visible) or its filler child
(when the bar is hidden). If it is still visible, we keep
it enabled, if it&#39;s hidden, we disable pointer events.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">var</span> box = bar.getBoundingClientRect();
        <span class="hljs-keyword">var</span> elt = <span class="hljs-built_in">document</span>.elementFromPoint(box.left + <span class="hljs-number">1</span>, box.bottom - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (elt != bar) bar.style.pointerEvents = <span class="hljs-string">"none"</span>;
        <span class="hljs-keyword">else</span> delay.set(<span class="hljs-number">1000</span>, maybeDisable);
      }
      delay.set(<span class="hljs-number">1000</span>, maybeDisable);
    },
    clear: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">this</span>.horiz.parentNode;
      parent.removeChild(<span class="hljs-keyword">this</span>.horiz);
      parent.removeChild(<span class="hljs-keyword">this</span>.vert);
    }
  }, NativeScrollbars.prototype);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NullScrollbars</span>(<span class="hljs-params"></span>) </span>{}

  NullScrollbars.prototype = copyObj({
    update: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> {bottom: <span class="hljs-number">0</span>, right: <span class="hljs-number">0</span>}; },
    setScrollLeft: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{},
    setScrollTop: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{},
    clear: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}
  }, NullScrollbars.prototype);

  CodeMirror.scrollbarModel = {<span class="hljs-string">"native"</span>: NativeScrollbars, <span class="hljs-string">"null"</span>: NullScrollbars};

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initScrollbars</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">if</span> (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      <span class="hljs-keyword">if</span> (cm.display.scrollbars.addClass)
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }

    cm.display.scrollbars = <span class="hljs-keyword">new</span> CodeMirror.scrollbarModel[cm.options.scrollbarStyle](<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prevent clicks in the scrollbars from killing focus</p></div></div><div class="code"><div class="wrapper">      on(node, <span class="hljs-string">"mousedown"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (cm.state.focused) setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ cm.display.input.focus(); }, <span class="hljs-number">0</span>);
      });
      node.setAttribute(<span class="hljs-string">"cm-not-content"</span>, <span class="hljs-string">"true"</span>);
    }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, axis</span>) </span>{
      <span class="hljs-keyword">if</span> (axis == <span class="hljs-string">"horizontal"</span>) setScrollLeft(cm, pos);
      <span class="hljs-keyword">else</span> setScrollTop(cm, pos);
    }, cm);
    <span class="hljs-keyword">if</span> (cm.display.scrollbars.addClass)
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateScrollbars</span>(<span class="hljs-params">cm, measure</span>) </span>{
    <span class="hljs-keyword">if</span> (!measure) measure = measureForScrollbars(cm);
    <span class="hljs-keyword">var</span> startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span> &amp;&amp; startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      <span class="hljs-keyword">if</span> (startWidth != cm.display.barWidth &amp;&amp; cm.options.lineWrapping)
        updateHeightsInViewport(cm);
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Re-synchronize the fake scrollbars with the actual size of the
content.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateScrollbarsInner</span>(<span class="hljs-params">cm, measure</span>) </span>{
    <span class="hljs-keyword">var</span> d = cm.display;
    <span class="hljs-keyword">var</span> sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + <span class="hljs-string">"px"</span>;
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + <span class="hljs-string">"px"</span>;
    d.heightForcer.style.borderBottom = sizes.bottom + <span class="hljs-string">"px solid transparent"</span>

    <span class="hljs-keyword">if</span> (sizes.right &amp;&amp; sizes.bottom) {
      d.scrollbarFiller.style.display = <span class="hljs-string">"block"</span>;
      d.scrollbarFiller.style.height = sizes.bottom + <span class="hljs-string">"px"</span>;
      d.scrollbarFiller.style.width = sizes.right + <span class="hljs-string">"px"</span>;
    } <span class="hljs-keyword">else</span> d.scrollbarFiller.style.display = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">if</span> (sizes.bottom &amp;&amp; cm.options.coverGutterNextToScrollbar &amp;&amp; cm.options.fixedGutter) {
      d.gutterFiller.style.display = <span class="hljs-string">"block"</span>;
      d.gutterFiller.style.height = sizes.bottom + <span class="hljs-string">"px"</span>;
      d.gutterFiller.style.width = measure.gutterWidth + <span class="hljs-string">"px"</span>;
    } <span class="hljs-keyword">else</span> d.gutterFiller.style.display = <span class="hljs-string">""</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute the lines that are visible in a given viewport (defaults
the the current scroll position). viewport may contain top,
height, and ensure (see op.scrollToPos) properties.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visibleLines</span>(<span class="hljs-params">display, doc, viewport</span>) </span>{
    <span class="hljs-keyword">var</span> top = viewport &amp;&amp; viewport.top != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, viewport.top) : display.scroller.scrollTop;
    top = <span class="hljs-built_in">Math</span>.floor(top - paddingTop(display));
    <span class="hljs-keyword">var</span> bottom = viewport &amp;&amp; viewport.bottom != <span class="hljs-literal">null</span> ? viewport.bottom : top + display.wrapper.clientHeight;

    <span class="hljs-keyword">var</span> from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure is a {from: {line, ch}, to: {line, ch}} object, and
forces those lines into the viewport (if possible).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (viewport &amp;&amp; viewport.ensure) {
      <span class="hljs-keyword">var</span> ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      <span class="hljs-keyword">if</span> (ensureFrom &lt; from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.min(ensureTo, doc.lastLine()) &gt;= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    <span class="hljs-keyword">return</span> {from: from, to: <span class="hljs-built_in">Math</span>.max(to, from + <span class="hljs-number">1</span>)};
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LINE NUMBERS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Re-align line numbers and gutter marks to compensate for
horizontal scrolling.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alignHorizontally</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display, view = display.view;
    <span class="hljs-keyword">if</span> (!display.alignWidgets &amp;&amp; (!display.gutters.firstChild || !cm.options.fixedGutter)) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    <span class="hljs-keyword">var</span> gutterW = display.gutters.offsetWidth, left = comp + <span class="hljs-string">"px"</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; view.length; i++) <span class="hljs-keyword">if</span> (!view[i].hidden) {
      <span class="hljs-keyword">if</span> (cm.options.fixedGutter &amp;&amp; view[i].gutter)
        view[i].gutter.style.left = left;
      <span class="hljs-keyword">var</span> align = view[i].alignable;
      <span class="hljs-keyword">if</span> (align) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; align.length; j++)
        align[j].style.left = left;
    }
    <span class="hljs-keyword">if</span> (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + <span class="hljs-string">"px"</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to ensure that the line number gutter is still the right
size for the current document size. Returns true when an update
is needed.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybeUpdateLineNumberWidth</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">if</span> (!cm.options.lineNumbers) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - <span class="hljs-number">1</span>), display = cm.display;
    <span class="hljs-keyword">if</span> (last.length != display.lineNumChars) {
      <span class="hljs-keyword">var</span> test = display.measure.appendChild(elt(<span class="hljs-string">"div"</span>, [elt(<span class="hljs-string">"div"</span>, last)],
                                                 <span class="hljs-string">"CodeMirror-linenumber CodeMirror-gutter-elt"</span>));
      <span class="hljs-keyword">var</span> innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = <span class="hljs-string">""</span>;
      display.lineNumInnerWidth = <span class="hljs-built_in">Math</span>.max(innerW, display.lineGutter.offsetWidth - padding) + <span class="hljs-number">1</span>;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -<span class="hljs-number">1</span>;
      display.lineGutter.style.width = display.lineNumWidth + <span class="hljs-string">"px"</span>;
      updateGutterSpace(cm);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineNumberFor</span>(<span class="hljs-params">options, i</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(options.lineNumberFormatter(i + options.firstLineNumber));
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
but using getBoundingClientRect to get a sub-pixel-accurate
result.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compensateForHScroll</span>(<span class="hljs-params">display</span>) </span>{
    <span class="hljs-keyword">return</span> display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DISPLAY DRAWING</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DisplayUpdate</span>(<span class="hljs-params">cm, viewport, force</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display;

    <span class="hljs-keyword">this</span>.viewport = viewport;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store some values that we&#39;ll need later (but don&#39;t want to force a relayout for)</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.visible = visibleLines(display, cm.doc, viewport);
    <span class="hljs-keyword">this</span>.editorIsHidden = !display.wrapper.offsetWidth;
    <span class="hljs-keyword">this</span>.wrapperHeight = display.wrapper.clientHeight;
    <span class="hljs-keyword">this</span>.wrapperWidth = display.wrapper.clientWidth;
    <span class="hljs-keyword">this</span>.oldDisplayWidth = displayWidth(cm);
    <span class="hljs-keyword">this</span>.force = force;
    <span class="hljs-keyword">this</span>.dims = getDimensions(cm);
    <span class="hljs-keyword">this</span>.events = [];
  }

  DisplayUpdate.prototype.signal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">emitter, type</span>) </span>{
    <span class="hljs-keyword">if</span> (hasHandler(emitter, type))
      <span class="hljs-keyword">this</span>.events.push(<span class="hljs-built_in">arguments</span>);
  };
  DisplayUpdate.prototype.finish = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.events.length; i++)
      signal.apply(<span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>.events[i]);
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybeClipScrollbars</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display;
    <span class="hljs-keyword">if</span> (!display.scrollbarsClipped &amp;&amp; display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + <span class="hljs-string">"px"</span>;
      display.sizer.style.marginBottom = -display.nativeBarWidth + <span class="hljs-string">"px"</span>;
      display.sizer.style.borderRightWidth = scrollGap(cm) + <span class="hljs-string">"px"</span>;
      display.scrollbarsClipped = <span class="hljs-literal">true</span>;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Does the actual updating of the line display. Bails out
(returning false) when there is nothing to be done and forced is
false.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateDisplayIfNeeded</span>(<span class="hljs-params">cm, update</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display, doc = cm.doc;

    <span class="hljs-keyword">if</span> (update.editorIsHidden) {
      resetView(cm);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Bail out if the visible area is already rendered and nothing changed.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (!update.force &amp;&amp;
        update.visible.from &gt;= display.viewFrom &amp;&amp; update.visible.to &lt;= display.viewTo &amp;&amp;
        (display.updateLineNumbers == <span class="hljs-literal">null</span> || display.updateLineNumbers &gt;= display.viewTo) &amp;&amp;
        display.renderedView == display.view &amp;&amp; countDirtyView(cm) == <span class="hljs-number">0</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute a suitable new viewport (from &amp; to)</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> end = doc.first + doc.size;
    <span class="hljs-keyword">var</span> from = <span class="hljs-built_in">Math</span>.max(update.visible.from - cm.options.viewportMargin, doc.first);
    <span class="hljs-keyword">var</span> to = <span class="hljs-built_in">Math</span>.min(end, update.visible.to + cm.options.viewportMargin);
    <span class="hljs-keyword">if</span> (display.viewFrom &lt; from &amp;&amp; from - display.viewFrom &lt; <span class="hljs-number">20</span>) from = <span class="hljs-built_in">Math</span>.max(doc.first, display.viewFrom);
    <span class="hljs-keyword">if</span> (display.viewTo &gt; to &amp;&amp; display.viewTo - to &lt; <span class="hljs-number">20</span>) to = <span class="hljs-built_in">Math</span>.min(end, display.viewTo);
    <span class="hljs-keyword">if</span> (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    <span class="hljs-keyword">var</span> different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Position the mover div to align with the current scroll position</p></div></div><div class="code"><div class="wrapper">    cm.display.mover.style.top = display.viewOffset + <span class="hljs-string">"px"</span>;

    <span class="hljs-keyword">var</span> toUpdate = countDirtyView(cm);
    <span class="hljs-keyword">if</span> (!different &amp;&amp; toUpdate == <span class="hljs-number">0</span> &amp;&amp; !update.force &amp;&amp; display.renderedView == display.view &amp;&amp;
        (display.updateLineNumbers == <span class="hljs-literal">null</span> || display.updateLineNumbers &gt;= display.viewTo))
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For big changes, we hide the enclosing element during the
update, since that speeds up the operations on most browsers.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> focused = activeElt();
    <span class="hljs-keyword">if</span> (toUpdate &gt; <span class="hljs-number">4</span>) display.lineDiv.style.display = <span class="hljs-string">"none"</span>;
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    <span class="hljs-keyword">if</span> (toUpdate &gt; <span class="hljs-number">4</span>) display.lineDiv.style.display = <span class="hljs-string">""</span>;
    display.renderedView = display.view;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>There might have been a widget with a focused element that got
hidden or updated, if so re-focus it.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (focused &amp;&amp; activeElt() != focused &amp;&amp; focused.offsetHeight) focused.focus();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prevent selection and cursors from interfering with the scroll
width and height.</p></div></div><div class="code"><div class="wrapper">    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, <span class="hljs-number">400</span>);
    }

    display.updateLineNumbers = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postUpdateDisplay</span>(<span class="hljs-params">cm, update</span>) </span>{
    <span class="hljs-keyword">var</span> viewport = update.viewport;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> first = <span class="hljs-literal">true</span>;; first = <span class="hljs-literal">false</span>) {
      <span class="hljs-keyword">if</span> (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Clip forced viewport to actual scrollable area.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (viewport &amp;&amp; viewport.top != <span class="hljs-literal">null</span>)
          viewport = {top: <span class="hljs-built_in">Math</span>.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Updated line heights might result in the drawn area not
actually covering the viewport. Keep looping until it does.</p></div></div><div class="code"><div class="wrapper">        update.visible = visibleLines(cm.display, cm.doc, viewport);
        <span class="hljs-keyword">if</span> (update.visible.from &gt;= cm.display.viewFrom &amp;&amp; update.visible.to &lt;= cm.display.viewTo)
          <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">if</span> (!updateDisplayIfNeeded(cm, update)) <span class="hljs-keyword">break</span>;
      updateHeightsInViewport(cm);
      <span class="hljs-keyword">var</span> barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
    }

    update.signal(cm, <span class="hljs-string">"update"</span>, cm);
    <span class="hljs-keyword">if</span> (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, <span class="hljs-string">"viewportChange"</span>, cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateDisplaySimple</span>(<span class="hljs-params">cm, viewport</span>) </span>{
    <span class="hljs-keyword">var</span> update = <span class="hljs-keyword">new</span> DisplayUpdate(cm, viewport);
    <span class="hljs-keyword">if</span> (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      <span class="hljs-keyword">var</span> barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDocumentHeight</span>(<span class="hljs-params">cm, measure</span>) </span>{
    cm.display.sizer.style.minHeight = measure.docHeight + <span class="hljs-string">"px"</span>;
    cm.display.heightForcer.style.top = measure.docHeight + <span class="hljs-string">"px"</span>;
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + <span class="hljs-string">"px"</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Read the actual heights of the rendered lines, and update their
stored heights to match.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHeightsInViewport</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display;
    <span class="hljs-keyword">var</span> prevBottom = display.lineDiv.offsetTop;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; display.view.length; i++) {
      <span class="hljs-keyword">var</span> cur = display.view[i], height;
      <span class="hljs-keyword">if</span> (cur.hidden) <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">8</span>) {
        <span class="hljs-keyword">var</span> bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      <span class="hljs-keyword">var</span> diff = cur.line.height - height;
      <span class="hljs-keyword">if</span> (height &lt; <span class="hljs-number">2</span>) height = textHeight(display);
      <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">.001</span> || diff &lt; -<span class="hljs-number">.001</span>) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        <span class="hljs-keyword">if</span> (cur.rest) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Read and store the height of line widgets associated with the
given line.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateWidgetHeight</span>(<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">if</span> (line.widgets) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Do a bulk-read of the DOM positions and sizes needed to draw the
view, so that we don&#39;t interleave reading and writing to the DOM.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDimensions</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> d = cm.display, left = {}, width = {};
    <span class="hljs-keyword">var</span> gutterLeft = d.gutters.clientLeft;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = d.gutters.firstChild, i = <span class="hljs-number">0</span>; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    <span class="hljs-keyword">return</span> {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sync the actual display DOM structure with display.view, removing
nodes for lines that are no longer in view, and creating the ones
that are not there yet, and updating the ones that are out of
date.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patchDisplay</span>(<span class="hljs-params">cm, updateNumbersFrom, dims</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display, lineNumbers = cm.options.lineNumbers;
    <span class="hljs-keyword">var</span> container = display.lineDiv, cur = container.firstChild;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rm</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">var</span> next = node.nextSibling;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Works around a throw-scroll bug in OS X Webkit</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (webkit &amp;&amp; mac &amp;&amp; cm.display.currentWheelTarget == node)
        node.style.display = <span class="hljs-string">"none"</span>;
      <span class="hljs-keyword">else</span>
        node.parentNode.removeChild(node);
      <span class="hljs-keyword">return</span> next;
    }

    <span class="hljs-keyword">var</span> view = display.view, lineN = display.viewFrom;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Loop over the elements in the view, syncing cur (the DOM nodes
in display.lineDiv) with the view as we go.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; view.length; i++) {
      <span class="hljs-keyword">var</span> lineView = view[i];
      <span class="hljs-keyword">if</span> (lineView.hidden) {
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!lineView.node || lineView.node.parentNode != container) { <span class="hljs-comment">// Not drawn yet</span>
        <span class="hljs-keyword">var</span> node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// Already drawn</span>
        <span class="hljs-keyword">while</span> (cur != lineView.node) cur = rm(cur);
        <span class="hljs-keyword">var</span> updateNumber = lineNumbers &amp;&amp; updateNumbersFrom != <span class="hljs-literal">null</span> &amp;&amp;
          updateNumbersFrom &lt;= lineN &amp;&amp; lineView.lineNumber;
        <span class="hljs-keyword">if</span> (lineView.changes) {
          <span class="hljs-keyword">if</span> (indexOf(lineView.changes, <span class="hljs-string">"gutter"</span>) &gt; -<span class="hljs-number">1</span>) updateNumber = <span class="hljs-literal">false</span>;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        <span class="hljs-keyword">if</span> (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(<span class="hljs-built_in">document</span>.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    <span class="hljs-keyword">while</span> (cur) cur = rm(cur);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When an aspect of a line changes, a string is added to
lineView.changes. This updates the relevant part of the line&#39;s
DOM structure.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateLineForChanges</span>(<span class="hljs-params">cm, lineView, lineN, dims</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; lineView.changes.length; j++) {
      <span class="hljs-keyword">var</span> type = lineView.changes[j];
      <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"text"</span>) updateLineText(cm, lineView);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"gutter"</span>) updateLineGutter(cm, lineView, lineN, dims);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"class"</span>) updateLineClasses(lineView);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"widget"</span>) updateLineWidgets(cm, lineView, dims);
    }
    lineView.changes = <span class="hljs-literal">null</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Lines with gutter elements, widgets or a background class need to
be wrapped, and have the extra elements added to the wrapper div</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureLineWrapped</span>(<span class="hljs-params">lineView</span>) </span>{
    <span class="hljs-keyword">if</span> (lineView.node == lineView.text) {
      lineView.node = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"position: relative"</span>);
      <span class="hljs-keyword">if</span> (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">8</span>) lineView.node.style.zIndex = <span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">return</span> lineView.node;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateLineBackground</span>(<span class="hljs-params">lineView</span>) </span>{
    <span class="hljs-keyword">var</span> cls = lineView.bgClass ? lineView.bgClass + <span class="hljs-string">" "</span> + (lineView.line.bgClass || <span class="hljs-string">""</span>) : lineView.line.bgClass;
    <span class="hljs-keyword">if</span> (cls) cls += <span class="hljs-string">" CodeMirror-linebackground"</span>;
    <span class="hljs-keyword">if</span> (lineView.background) {
      <span class="hljs-keyword">if</span> (cls) lineView.background.className = cls;
      <span class="hljs-keyword">else</span> { lineView.background.parentNode.removeChild(lineView.background); lineView.background = <span class="hljs-literal">null</span>; }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cls) {
      <span class="hljs-keyword">var</span> wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, cls), wrap.firstChild);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Wrapper around buildLineContent which will reuse the structure
in display.externalMeasured when possible.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLineContent</span>(<span class="hljs-params">cm, lineView</span>) </span>{
    <span class="hljs-keyword">var</span> ext = cm.display.externalMeasured;
    <span class="hljs-keyword">if</span> (ext &amp;&amp; ext.line == lineView.line) {
      cm.display.externalMeasured = <span class="hljs-literal">null</span>;
      lineView.measure = ext.measure;
      <span class="hljs-keyword">return</span> ext.built;
    }
    <span class="hljs-keyword">return</span> buildLineContent(cm, lineView);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Redraw the line&#39;s text. Interacts with the background and text
classes because the mode may output tokens that influence these
classes.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateLineText</span>(<span class="hljs-params">cm, lineView</span>) </span>{
    <span class="hljs-keyword">var</span> cls = lineView.text.className;
    <span class="hljs-keyword">var</span> built = getLineContent(cm, lineView);
    <span class="hljs-keyword">if</span> (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    <span class="hljs-keyword">if</span> (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cls) {
      lineView.text.className = cls;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateLineClasses</span>(<span class="hljs-params">lineView</span>) </span>{
    updateLineBackground(lineView);
    <span class="hljs-keyword">if</span> (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lineView.node != lineView.text)
      lineView.node.className = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">var</span> textClass = lineView.textClass ? lineView.textClass + <span class="hljs-string">" "</span> + (lineView.line.textClass || <span class="hljs-string">""</span>) : lineView.line.textClass;
    lineView.text.className = textClass || <span class="hljs-string">""</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateLineGutter</span>(<span class="hljs-params">cm, lineView, lineN, dims</span>) </span>{
    <span class="hljs-keyword">if</span> (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">if</span> (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">if</span> (lineView.line.gutterClass) {
      <span class="hljs-keyword">var</span> wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-gutter-background "</span> + lineView.line.gutterClass,
                                      <span class="hljs-string">"left: "</span> + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
                                      <span class="hljs-string">"px; width: "</span> + dims.gutterTotalWidth + <span class="hljs-string">"px"</span>);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    <span class="hljs-keyword">var</span> markers = lineView.line.gutterMarkers;
    <span class="hljs-keyword">if</span> (cm.options.lineNumbers || markers) {
      <span class="hljs-keyword">var</span> wrap = ensureLineWrapped(lineView);
      <span class="hljs-keyword">var</span> gutterWrap = lineView.gutter = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-gutter-wrapper"</span>, <span class="hljs-string">"left: "</span> +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + <span class="hljs-string">"px"</span>);
      cm.display.input.setUneditable(gutterWrap);
      wrap.insertBefore(gutterWrap, lineView.text);
      <span class="hljs-keyword">if</span> (lineView.line.gutterClass)
        gutterWrap.className += <span class="hljs-string">" "</span> + lineView.line.gutterClass;
      <span class="hljs-keyword">if</span> (cm.options.lineNumbers &amp;&amp; (!markers || !markers[<span class="hljs-string">"CodeMirror-linenumbers"</span>]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt(<span class="hljs-string">"div"</span>, lineNumberFor(cm.options, lineN),
              <span class="hljs-string">"CodeMirror-linenumber CodeMirror-gutter-elt"</span>,
              <span class="hljs-string">"left: "</span> + dims.gutterLeft[<span class="hljs-string">"CodeMirror-linenumbers"</span>] + <span class="hljs-string">"px; width: "</span>
              + cm.display.lineNumInnerWidth + <span class="hljs-string">"px"</span>));
      <span class="hljs-keyword">if</span> (markers) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt; cm.options.gutters.length; ++k) {
        <span class="hljs-keyword">var</span> id = cm.options.gutters[k], found = markers.hasOwnProperty(id) &amp;&amp; markers[id];
        <span class="hljs-keyword">if</span> (found)
          gutterWrap.appendChild(elt(<span class="hljs-string">"div"</span>, [found], <span class="hljs-string">"CodeMirror-gutter-elt"</span>, <span class="hljs-string">"left: "</span> +
                                     dims.gutterLeft[id] + <span class="hljs-string">"px; width: "</span> + dims.gutterWidth[id] + <span class="hljs-string">"px"</span>));
      }
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateLineWidgets</span>(<span class="hljs-params">cm, lineView, dims</span>) </span>{
    <span class="hljs-keyword">if</span> (lineView.alignable) lineView.alignable = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> node = lineView.node.firstChild, next; node; node = next) {
      <span class="hljs-keyword">var</span> next = node.nextSibling;
      <span class="hljs-keyword">if</span> (node.className == <span class="hljs-string">"CodeMirror-linewidget"</span>)
        lineView.node.removeChild(node);
    }
    insertLineWidgets(cm, lineView, dims);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build a line&#39;s DOM representation from scratch</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildLineElement</span>(<span class="hljs-params">cm, lineView, lineN, dims</span>) </span>{
    <span class="hljs-keyword">var</span> built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    <span class="hljs-keyword">if</span> (built.bgClass) lineView.bgClass = built.bgClass;
    <span class="hljs-keyword">if</span> (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    <span class="hljs-keyword">return</span> lineView.node;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A lineView may contain multiple logical lines (when merged by
collapsed spans). The widgets for all of them need to be drawn.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertLineWidgets</span>(<span class="hljs-params">cm, lineView, dims</span>) </span>{
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (lineView.rest) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lineView.rest.length; i++)
      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, <span class="hljs-literal">false</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertLineWidgetsFor</span>(<span class="hljs-params">cm, line, lineView, dims, allowAbove</span>) </span>{
    <span class="hljs-keyword">if</span> (!line.widgets) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> wrap = ensureLineWrapped(lineView);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, ws = line.widgets; i &lt; ws.length; ++i) {
      <span class="hljs-keyword">var</span> widget = ws[i], node = elt(<span class="hljs-string">"div"</span>, [widget.node], <span class="hljs-string">"CodeMirror-linewidget"</span>);
      <span class="hljs-keyword">if</span> (!widget.handleMouseEvents) node.setAttribute(<span class="hljs-string">"cm-ignore-events"</span>, <span class="hljs-string">"true"</span>);
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      <span class="hljs-keyword">if</span> (allowAbove &amp;&amp; widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      <span class="hljs-keyword">else</span>
        wrap.appendChild(node);
      signalLater(widget, <span class="hljs-string">"redraw"</span>);
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">positionLineWidget</span>(<span class="hljs-params">widget, node, lineView, dims</span>) </span>{
    <span class="hljs-keyword">if</span> (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      <span class="hljs-keyword">var</span> width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + <span class="hljs-string">"px"</span>;
      <span class="hljs-keyword">if</span> (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + <span class="hljs-string">"px"</span>;
      }
      node.style.width = width + <span class="hljs-string">"px"</span>;
    }
    <span class="hljs-keyword">if</span> (widget.coverGutter) {
      node.style.zIndex = <span class="hljs-number">5</span>;
      node.style.position = <span class="hljs-string">"relative"</span>;
      <span class="hljs-keyword">if</span> (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + <span class="hljs-string">"px"</span>;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>POSITION OBJECT</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A Pos instance represents a position within the text.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> Pos = CodeMirror.Pos = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line, ch</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Pos)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pos(line, ch);
    <span class="hljs-keyword">this</span>.line = line; <span class="hljs-keyword">this</span>.ch = ch;
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compare two positions, return 0 if they are the same, a negative
number when a is less, and a positive number otherwise.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> cmp = CodeMirror.cmpPos = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{ <span class="hljs-keyword">return</span> a.line - b.line || a.ch - b.ch; };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyPos</span>(<span class="hljs-params">x</span>) </span>{<span class="hljs-keyword">return</span> Pos(x.line, x.ch);}
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxPos</span>(<span class="hljs-params">a, b</span>) </span>{ <span class="hljs-keyword">return</span> cmp(a, b) &lt; <span class="hljs-number">0</span> ? b : a; }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minPos</span>(<span class="hljs-params">a, b</span>) </span>{ <span class="hljs-keyword">return</span> cmp(a, b) &lt; <span class="hljs-number">0</span> ? a : b; }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>INPUT HANDLING</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureFocus</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">if</span> (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This will be set to an array of strings when copying, so that,
when pasting, we know what kind of selections the copied text
was made out of.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> lastCopied = <span class="hljs-literal">null</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyTextInput</span>(<span class="hljs-params">cm, inserted, deleted, sel, origin</span>) </span>{
    <span class="hljs-keyword">var</span> doc = cm.doc;
    cm.display.shift = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (!sel) sel = doc.sel;

    <span class="hljs-keyword">var</span> paste = cm.state.pasteIncoming || origin == <span class="hljs-string">"paste"</span>;
    <span class="hljs-keyword">var</span> textLines = doc.splitLines(inserted), multiPaste = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When pasing N lines into N selections, insert one line per selection</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (paste &amp;&amp; sel.ranges.length &gt; <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">if</span> (lastCopied &amp;&amp; lastCopied.join(<span class="hljs-string">"\n"</span>) == inserted) {
        <span class="hljs-keyword">if</span> (sel.ranges.length % lastCopied.length == <span class="hljs-number">0</span>) {
          multiPaste = [];
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lastCopied.length; i++)
            multiPaste.push(doc.splitLines(lastCopied[i]));
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (textLines.length == sel.ranges.length) {
        multiPaste = map(textLines, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l</span>) </span>{ <span class="hljs-keyword">return</span> [l]; });
      }
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Normal behavior is to insert the new text into every selection</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = sel.ranges.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
      <span class="hljs-keyword">var</span> range = sel.ranges[i];
      <span class="hljs-keyword">var</span> from = range.from(), to = range.to();
      <span class="hljs-keyword">if</span> (range.empty()) {
        <span class="hljs-keyword">if</span> (deleted &amp;&amp; deleted &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// Handle deletion</span>
          from = Pos(from.line, from.ch - deleted);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cm.state.overwrite &amp;&amp; !paste) <span class="hljs-comment">// Handle overwrite</span>
          to = Pos(to.line, <span class="hljs-built_in">Math</span>.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      }
      <span class="hljs-keyword">var</span> updateInput = cm.curOp.updateInput;
      <span class="hljs-keyword">var</span> changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                         origin: origin || (paste ? <span class="hljs-string">"paste"</span> : cm.state.cutIncoming ? <span class="hljs-string">"cut"</span> : <span class="hljs-string">"+input"</span>)};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, <span class="hljs-string">"inputRead"</span>, cm, changeEvent);
    }
    <span class="hljs-keyword">if</span> (inserted &amp;&amp; !paste)
      triggerElectric(cm, inserted);

    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = <span class="hljs-literal">true</span>;
    cm.state.pasteIncoming = cm.state.cutIncoming = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePaste</span>(<span class="hljs-params">e, cm</span>) </span>{
    <span class="hljs-keyword">var</span> pasted = e.clipboardData &amp;&amp; e.clipboardData.getData(<span class="hljs-string">"text/plain"</span>);
    <span class="hljs-keyword">if</span> (pasted) {
      e.preventDefault();
      <span class="hljs-keyword">if</span> (!cm.isReadOnly() &amp;&amp; !cm.options.disableInput)
        runInOp(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ applyTextInput(cm, pasted, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"paste"</span>); });
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">triggerElectric</span>(<span class="hljs-params">cm, inserted</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When an &#39;electric&#39; character is inserted, immediately trigger a reindent</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (!cm.options.electricChars || !cm.options.smartIndent) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> sel = cm.doc.sel;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = sel.ranges.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
      <span class="hljs-keyword">var</span> range = sel.ranges[i];
      <span class="hljs-keyword">if</span> (range.head.ch &gt; <span class="hljs-number">100</span> || (i &amp;&amp; sel.ranges[i - <span class="hljs-number">1</span>].head.line == range.head.line)) <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">var</span> mode = cm.getModeAt(range.head);
      <span class="hljs-keyword">var</span> indented = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (mode.electricChars) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; mode.electricChars.length; j++)
          <span class="hljs-keyword">if</span> (inserted.indexOf(mode.electricChars.charAt(j)) &gt; -<span class="hljs-number">1</span>) {
            indented = indentLine(cm, range.head.line, <span class="hljs-string">"smart"</span>);
            <span class="hljs-keyword">break</span>;
          }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode.electricInput) {
        <span class="hljs-keyword">if</span> (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(<span class="hljs-number">0</span>, range.head.ch)))
          indented = indentLine(cm, range.head.line, <span class="hljs-string">"smart"</span>);
      }
      <span class="hljs-keyword">if</span> (indented) signalLater(cm, <span class="hljs-string">"electricInput"</span>, cm, range.head.line);
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyableRanges</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> text = [], ranges = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; cm.doc.sel.ranges.length; i++) {
      <span class="hljs-keyword">var</span> line = cm.doc.sel.ranges[i].head.line;
      <span class="hljs-keyword">var</span> lineRange = {anchor: Pos(line, <span class="hljs-number">0</span>), head: Pos(line + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    <span class="hljs-keyword">return</span> {text: text, ranges: ranges};
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disableBrowserMagic</span>(<span class="hljs-params">field</span>) </span>{
    field.setAttribute(<span class="hljs-string">"autocorrect"</span>, <span class="hljs-string">"off"</span>);
    field.setAttribute(<span class="hljs-string">"autocapitalize"</span>, <span class="hljs-string">"off"</span>);
    field.setAttribute(<span class="hljs-string">"spellcheck"</span>, <span class="hljs-string">"false"</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TEXTAREA INPUT STYLE</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TextareaInput</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">this</span>.cm = cm;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>See input.poll and input.reset</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.prevInput = <span class="hljs-string">""</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag that indicates whether we expect input to appear real soon
now (after some event like &#39;keypress&#39; or &#39;input&#39;) and are
polling intensively.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.pollingFast = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Self-resetting timeout for the poller</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.polling = <span class="hljs-keyword">new</span> Delayed();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Tracks when input.reset has punted to just putting a short
string into the textarea instead of the full selection.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.inaccurateSelection = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to work around IE issue with selection being forgotten when focus moves away from textarea</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.hasSelection = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.composing = <span class="hljs-literal">null</span>;
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hiddenTextarea</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> te = elt(<span class="hljs-string">"textarea"</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"position: absolute; padding: 0; width: 1px; height: 1em; outline: none"</span>);
    <span class="hljs-keyword">var</span> div = elt(<span class="hljs-string">"div"</span>, [te], <span class="hljs-literal">null</span>, <span class="hljs-string">"overflow: hidden; position: relative; width: 3px; height: 0px;"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The textarea is kept positioned near the cursor to prevent the
fact that it&#39;ll be scrolled into view on input from scrolling
our fake cursor out of view. On webkit, when wrap=off, paste is
very slow. So make the area wide instead.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (webkit) te.style.width = <span class="hljs-string">"1000px"</span>;
    <span class="hljs-keyword">else</span> te.setAttribute(<span class="hljs-string">"wrap"</span>, <span class="hljs-string">"off"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If border: 0; -- iOS fails to open keyboard (issue #1287)</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (ios) te.style.border = <span class="hljs-string">"1px solid black"</span>;
    disableBrowserMagic(te);
    <span class="hljs-keyword">return</span> div;
  }

  TextareaInput.prototype = copyObj({
    init: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">display</span>) </span>{
      <span class="hljs-keyword">var</span> input = <span class="hljs-keyword">this</span>, cm = <span class="hljs-keyword">this</span>.cm;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Wraps and hides input textarea</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> div = <span class="hljs-keyword">this</span>.wrapper = hiddenTextarea();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The semihidden textarea that is focused when the editor is
focused, and receives input.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> te = <span class="hljs-keyword">this</span>.textarea = div.firstChild;
      display.wrapper.insertBefore(div, display.wrapper.firstChild);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Needed to hide big blue blinking cursor on Mobile Safari (doesn&#39;t seem to work in iOS 8 anymore)</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (ios) te.style.width = <span class="hljs-string">"0px"</span>;

      on(te, <span class="hljs-string">"input"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &gt;= <span class="hljs-number">9</span> &amp;&amp; input.hasSelection) input.hasSelection = <span class="hljs-literal">null</span>;
        input.poll();
      });

      on(te, <span class="hljs-string">"paste"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (signalDOMEvent(cm, e) || handlePaste(e, cm)) <span class="hljs-keyword">return</span>

        cm.state.pasteIncoming = <span class="hljs-literal">true</span>;
        input.fastPoll();
      });

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepareCopyCut</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (signalDOMEvent(cm, e)) <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">if</span> (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          <span class="hljs-keyword">if</span> (input.inaccurateSelection) {
            input.prevInput = <span class="hljs-string">""</span>;
            input.inaccurateSelection = <span class="hljs-literal">false</span>;
            te.value = lastCopied.join(<span class="hljs-string">"\n"</span>);
            selectInput(te);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!cm.options.lineWiseCopyCut) {
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">"cut"</span>) {
            cm.setSelections(ranges.ranges, <span class="hljs-literal">null</span>, sel_dontScroll);
          } <span class="hljs-keyword">else</span> {
            input.prevInput = <span class="hljs-string">""</span>;
            te.value = ranges.text.join(<span class="hljs-string">"\n"</span>);
            selectInput(te);
          }
        }
        <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">"cut"</span>) cm.state.cutIncoming = <span class="hljs-literal">true</span>;
      }
      on(te, <span class="hljs-string">"cut"</span>, prepareCopyCut);
      on(te, <span class="hljs-string">"copy"</span>, prepareCopyCut);

      on(display.scroller, <span class="hljs-string">"paste"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (eventInWidget(display, e) || signalDOMEvent(cm, e)) <span class="hljs-keyword">return</span>;
        cm.state.pasteIncoming = <span class="hljs-literal">true</span>;
        input.focus();
      });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prevent normal selection in the editor (we handle our own)</p></div></div><div class="code"><div class="wrapper">      on(display.lineSpace, <span class="hljs-string">"selectstart"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (!eventInWidget(display, e)) e_preventDefault(e);
      });

      on(te, <span class="hljs-string">"compositionstart"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> start = cm.getCursor(<span class="hljs-string">"from"</span>);
        <span class="hljs-keyword">if</span> (input.composing) input.composing.range.clear()
        input.composing = {
          start: start,
          range: cm.markText(start, cm.getCursor(<span class="hljs-string">"to"</span>), {className: <span class="hljs-string">"CodeMirror-composing"</span>})
        };
      });
      on(te, <span class="hljs-string">"compositionend"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = <span class="hljs-literal">null</span>;
        }
      });
    },

    prepareSelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Redraw the selection and/or cursor</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>.cm, display = cm.display, doc = cm.doc;
      <span class="hljs-keyword">var</span> result = prepareSelection(cm);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Move the hidden textarea near the cursor to prevent scrolling artifacts</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (cm.options.moveInputWithCursor) {
        <span class="hljs-keyword">var</span> headPos = cursorCoords(cm, doc.sel.primary().head, <span class="hljs-string">"div"</span>);
        <span class="hljs-keyword">var</span> wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.min(display.wrapper.clientHeight - <span class="hljs-number">10</span>,
                                            headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.min(display.wrapper.clientWidth - <span class="hljs-number">10</span>,
                                             headPos.left + lineOff.left - wrapOff.left));
      }

      <span class="hljs-keyword">return</span> result;
    },

    showSelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">drawn</span>) </span>{
      <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      <span class="hljs-keyword">if</span> (drawn.teTop != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">this</span>.wrapper.style.top = drawn.teTop + <span class="hljs-string">"px"</span>;
        <span class="hljs-keyword">this</span>.wrapper.style.left = drawn.teLeft + <span class="hljs-string">"px"</span>;
      }
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reset the input to correspond to the selection (or to be empty,
when not typing and nothing is selected)</p></div></div><div class="code"><div class="wrapper">    reset: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">typing</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.contextMenuPending) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">var</span> minimal, selected, cm = <span class="hljs-keyword">this</span>.cm, doc = cm.doc;
      <span class="hljs-keyword">if</span> (cm.somethingSelected()) {
        <span class="hljs-keyword">this</span>.prevInput = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">var</span> range = doc.sel.primary();
        minimal = hasCopyEvent &amp;&amp;
          (range.to().line - range.from().line &gt; <span class="hljs-number">100</span> || (selected = cm.getSelection()).length &gt; <span class="hljs-number">1000</span>);
        <span class="hljs-keyword">var</span> content = minimal ? <span class="hljs-string">"-"</span> : selected || cm.getSelection();
        <span class="hljs-keyword">this</span>.textarea.value = content;
        <span class="hljs-keyword">if</span> (cm.state.focused) selectInput(<span class="hljs-keyword">this</span>.textarea);
        <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &gt;= <span class="hljs-number">9</span>) <span class="hljs-keyword">this</span>.hasSelection = content;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!typing) {
        <span class="hljs-keyword">this</span>.prevInput = <span class="hljs-keyword">this</span>.textarea.value = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &gt;= <span class="hljs-number">9</span>) <span class="hljs-keyword">this</span>.hasSelection = <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">this</span>.inaccurateSelection = minimal;
    },

    getField: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.textarea; },

    supportsTouch: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; },

    focus: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cm.options.readOnly != <span class="hljs-string">"nocursor"</span> &amp;&amp; (!mobile || activeElt() != <span class="hljs-keyword">this</span>.textarea)) {
        <span class="hljs-keyword">try</span> { <span class="hljs-keyword">this</span>.textarea.focus(); }
        <span class="hljs-keyword">catch</span> (e) {} <span class="hljs-comment">// IE8 will throw if the textarea is display: none or not in DOM</span>
      }
    },

    blur: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>.textarea.blur(); },

    resetPosition: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.wrapper.style.top = <span class="hljs-keyword">this</span>.wrapper.style.left = <span class="hljs-number">0</span>;
    },

    receivedFocus: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>.slowPoll(); },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Poll for input changes, using the normal rate of polling. This
runs as long as the editor is focused.</p></div></div><div class="code"><div class="wrapper">    slowPoll: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> input = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">if</span> (input.pollingFast) <span class="hljs-keyword">return</span>;
      input.polling.set(<span class="hljs-keyword">this</span>.cm.options.pollInterval, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        input.poll();
        <span class="hljs-keyword">if</span> (input.cm.state.focused) input.slowPoll();
      });
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When an event has just come in that is likely to add or change
something in the input textarea, we poll faster, to ensure that
the change appears on the screen quickly.</p></div></div><div class="code"><div class="wrapper">    fastPoll: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> missed = <span class="hljs-literal">false</span>, input = <span class="hljs-keyword">this</span>;
      input.pollingFast = <span class="hljs-literal">true</span>;
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">p</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> changed = input.poll();
        <span class="hljs-keyword">if</span> (!changed &amp;&amp; !missed) {missed = <span class="hljs-literal">true</span>; input.polling.set(<span class="hljs-number">60</span>, p);}
        <span class="hljs-keyword">else</span> {input.pollingFast = <span class="hljs-literal">false</span>; input.slowPoll();}
      }
      input.polling.set(<span class="hljs-number">20</span>, p);
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Read input from the textarea, and update the document to match.
When something is selected, it is present in the textarea, and
selected (unless it is huge, in which case a placeholder is
used). When nothing is selected, the cursor sits after previously
seen text (can be empty), which is stored in prevInput (we must
not reset the textarea when typing, because that breaks IME).</p></div></div><div class="code"><div class="wrapper">    poll: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>.cm, input = <span class="hljs-keyword">this</span>.textarea, prevInput = <span class="hljs-keyword">this</span>.prevInput;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Since this is called a <em>lot</em>, try to bail out as cheaply as
possible when it is clear that nothing happened. hasSelection
will be the case when there is a lot of text in the textarea,
in which case reading its value would be expensive.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.contextMenuPending || !cm.state.focused ||
          (hasSelection(input) &amp;&amp; !prevInput &amp;&amp; !<span class="hljs-keyword">this</span>.composing) ||
          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">var</span> text = input.value;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If nothing changed, bail.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (text == prevInput &amp;&amp; !cm.somethingSelected()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Work around nonsensical selection resetting in IE9/10, and
inexplicable appearance of private area unicode characters on
some key combos in Mac (#2689).</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &gt;= <span class="hljs-number">9</span> &amp;&amp; <span class="hljs-keyword">this</span>.hasSelection === text ||
          mac &amp;&amp; <span class="hljs-regexp">/[\uf700-\uf7ff]/</span>.test(text)) {
        cm.display.input.reset();
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">if</span> (cm.doc.sel == cm.display.selForContextMenu) {
        <span class="hljs-keyword">var</span> first = text.charCodeAt(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (first == <span class="hljs-number">0x200b</span> &amp;&amp; !prevInput) prevInput = <span class="hljs-string">"\u200b"</span>;
        <span class="hljs-keyword">if</span> (first == <span class="hljs-number">0x21da</span>) { <span class="hljs-keyword">this</span>.reset(); <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cm.execCommand(<span class="hljs-string">"undo"</span>); }
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the part of the input that is actually new</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> same = <span class="hljs-number">0</span>, l = <span class="hljs-built_in">Math</span>.min(prevInput.length, text.length);
      <span class="hljs-keyword">while</span> (same &lt; l &amp;&amp; prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;

      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
      runInOp(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        applyTextInput(cm, text.slice(same), prevInput.length - same,
                       <span class="hljs-literal">null</span>, self.composing ? <span class="hljs-string">"*compose"</span> : <span class="hljs-literal">null</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Don&#39;t leave long text in the textarea, since it makes further polling slow</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (text.length &gt; <span class="hljs-number">1000</span> || text.indexOf(<span class="hljs-string">"\n"</span>) &gt; -<span class="hljs-number">1</span>) input.value = self.prevInput = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">else</span> self.prevInput = text;

        <span class="hljs-keyword">if</span> (self.composing) {
          self.composing.range.clear();
          self.composing.range = cm.markText(self.composing.start, cm.getCursor(<span class="hljs-string">"to"</span>),
                                             {className: <span class="hljs-string">"CodeMirror-composing"</span>});
        }
      });
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    },

    ensurePolled: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pollingFast &amp;&amp; <span class="hljs-keyword">this</span>.poll()) <span class="hljs-keyword">this</span>.pollingFast = <span class="hljs-literal">false</span>;
    },

    onKeyPress: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &gt;= <span class="hljs-number">9</span>) <span class="hljs-keyword">this</span>.hasSelection = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.fastPoll();
    },

    onContextMenu: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">var</span> input = <span class="hljs-keyword">this</span>, cm = input.cm, display = cm.display, te = input.textarea;
      <span class="hljs-keyword">var</span> pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      <span class="hljs-keyword">if</span> (!pos || presto) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Opera is difficult.</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reset the current text selection only if the click is done outside of the selection
and &#39;resetSelectionOnContextMenu&#39; option is true.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> reset = cm.options.resetSelectionOnContextMenu;
      <span class="hljs-keyword">if</span> (reset &amp;&amp; cm.doc.sel.contains(pos) == -<span class="hljs-number">1</span>)
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

      <span class="hljs-keyword">var</span> oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
      input.wrapper.style.cssText = <span class="hljs-string">"position: absolute"</span>
      <span class="hljs-keyword">var</span> wrapperBox = input.wrapper.getBoundingClientRect()
      te.style.cssText = <span class="hljs-string">"position: absolute; width: 30px; height: 30px; top: "</span> + (e.clientY - wrapperBox.top - <span class="hljs-number">5</span>) +
        <span class="hljs-string">"px; left: "</span> + (e.clientX - wrapperBox.left - <span class="hljs-number">5</span>) + <span class="hljs-string">"px; z-index: 1000; background: "</span> +
        (ie ? <span class="hljs-string">"rgba(255, 255, 255, .05)"</span> : <span class="hljs-string">"transparent"</span>) +
        <span class="hljs-string">"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);"</span>;
      <span class="hljs-keyword">if</span> (webkit) <span class="hljs-keyword">var</span> oldScrollY = <span class="hljs-built_in">window</span>.scrollY; <span class="hljs-comment">// Work around Chrome issue (#2712)</span>
      display.input.focus();
      <span class="hljs-keyword">if</span> (webkit) <span class="hljs-built_in">window</span>.scrollTo(<span class="hljs-literal">null</span>, oldScrollY);
      display.input.reset();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Adds &quot;Select all&quot; to context menu in FF</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (!cm.somethingSelected()) te.value = input.prevInput = <span class="hljs-string">" "</span>;
      input.contextMenuPending = <span class="hljs-literal">true</span>;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Select-all will be greyed out if there&#39;s nothing to select, so
this adds a zero-width space so that we can later check whether
it got selected.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepareSelectAllHack</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (te.selectionStart != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> selected = cm.somethingSelected();
          <span class="hljs-keyword">var</span> extval = <span class="hljs-string">"\u200b"</span> + (selected ? te.value : <span class="hljs-string">""</span>);
          te.value = <span class="hljs-string">"\u21da"</span>; <span class="hljs-comment">// Used to catch context-menu undo</span>
          te.value = extval;
          input.prevInput = selected ? <span class="hljs-string">""</span> : <span class="hljs-string">"\u200b"</span>;
          te.selectionStart = <span class="hljs-number">1</span>; te.selectionEnd = extval.length;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Re-set this, in case some other handler touched the
selection in the meantime.</p></div></div><div class="code"><div class="wrapper">          display.selForContextMenu = cm.doc.sel;
        }
      }
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rehide</span>(<span class="hljs-params"></span>) </span>{
        input.contextMenuPending = <span class="hljs-literal">false</span>;
        input.wrapper.style.cssText = oldWrapperCSS
        te.style.cssText = oldCSS;
        <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">9</span>) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Try to detect the user choosing select-all</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (te.selectionStart != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (!ie || (ie &amp;&amp; ie_version &lt; <span class="hljs-number">9</span>)) prepareSelectAllHack();
          <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, poll = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (display.selForContextMenu == cm.doc.sel &amp;&amp; te.selectionStart == <span class="hljs-number">0</span> &amp;&amp;
                te.selectionEnd &gt; <span class="hljs-number">0</span> &amp;&amp; input.prevInput == <span class="hljs-string">"\u200b"</span>)
              operation(cm, commands.selectAll)(cm);
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i++ <span class="xml"><span class="hljs-tag">&lt; <span class="hljs-attribute">10</span>) <span class="hljs-attribute">display.detectingSelectAll</span> = <span class="hljs-attribute">setTimeout</span>(<span class="hljs-attribute">poll</span>, <span class="hljs-attribute">500</span>);
            <span class="hljs-attribute">else</span> <span class="hljs-attribute">display.input.reset</span>();
          };
          <span class="hljs-attribute">display.detectingSelectAll</span> = <span class="hljs-attribute">setTimeout</span>(<span class="hljs-attribute">poll</span>, <span class="hljs-attribute">200</span>);
        }
      }

      <span class="hljs-attribute">if</span> (<span class="hljs-attribute">ie</span> &amp;&amp; <span class="hljs-attribute">ie_version</span> &gt;</span>= 9) prepareSelectAllHack();
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    },

    readOnlyChanged: function(val) {
      if (!val) this.reset();
    },

    setUneditable: nothing,

    needsContentAttribute: false
  }, TextareaInput.prototype);
</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>CONTENTEDITABLE INPUT STYLE</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ContentEditableInput</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">this</span>.cm = cm;
    <span class="hljs-keyword">this</span>.lastAnchorNode = <span class="hljs-keyword">this</span>.lastAnchorOffset = <span class="hljs-keyword">this</span>.lastFocusNode = <span class="hljs-keyword">this</span>.lastFocusOffset = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.polling = <span class="hljs-keyword">new</span> Delayed();
    <span class="hljs-keyword">this</span>.gracePeriod = <span class="hljs-literal">false</span>;
  }

  ContentEditableInput.prototype = copyObj({
    init: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">display</span>) </span>{
      <span class="hljs-keyword">var</span> input = <span class="hljs-keyword">this</span>, cm = input.cm;
      <span class="hljs-keyword">var</span> div = input.div = display.lineDiv;
      disableBrowserMagic(div);

      on(div, <span class="hljs-string">"paste"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (!signalDOMEvent(cm, e)) handlePaste(e, cm);
      })

      on(div, <span class="hljs-string">"compositionstart"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> data = e.data;
        input.composing = {sel: cm.doc.sel, data: data, startData: data};
        <span class="hljs-keyword">if</span> (!data) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">var</span> prim = cm.doc.sel.primary();
        <span class="hljs-keyword">var</span> line = cm.getLine(prim.head.line);
        <span class="hljs-keyword">var</span> found = line.indexOf(data, <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, prim.head.ch - data.length));
        <span class="hljs-keyword">if</span> (found &gt; -<span class="hljs-number">1</span> &amp;&amp; found &lt;= prim.head.ch)
          input.composing.sel = simpleSelection(Pos(prim.head.line, found),
                                                Pos(prim.head.line, found + data.length));
      });
      on(div, <span class="hljs-string">"compositionupdate"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        input.composing.data = e.data;
      });
      on(div, <span class="hljs-string">"compositionend"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">var</span> ours = input.composing;
        <span class="hljs-keyword">if</span> (!ours) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (e.data != ours.startData &amp;&amp; !<span class="hljs-regexp">/\u200b/</span>.test(e.data))
          ours.data = e.data;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Need a small delay to prevent other code (input event,
selection polling) from doing damage when fired right after
compositionend.</p></div></div><div class="code"><div class="wrapper">        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (!ours.handled)
            input.applyComposition(ours);
          <span class="hljs-keyword">if</span> (input.composing == ours)
            input.composing = <span class="hljs-literal">null</span>;
        }, <span class="hljs-number">50</span>);
      });

      on(div, <span class="hljs-string">"touchstart"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        input.forceCompositionEnd();
      });

      on(div, <span class="hljs-string">"input"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (input.composing) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (cm.isReadOnly() || !input.pollContent())
          runInOp(input.cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{regChange(cm);});
      });

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onCopyCut</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (signalDOMEvent(cm, e)) <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">if</span> (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">"cut"</span>) cm.replaceSelection(<span class="hljs-string">""</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"cut"</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!cm.options.lineWiseCopyCut) {
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          <span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">"cut"</span>) {
            cm.operation(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
              cm.setSelections(ranges.ranges, <span class="hljs-number">0</span>, sel_dontScroll);
              cm.replaceSelection(<span class="hljs-string">""</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"cut"</span>);
            });
          }
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>iOS exposes the clipboard API, but seems to discard content inserted into it</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (e.clipboardData &amp;&amp; !ios) {
          e.preventDefault();
          e.clipboardData.clearData();
          e.clipboardData.setData(<span class="hljs-string">"text/plain"</span>, lastCopied.join(<span class="hljs-string">"\n"</span>));
        } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Old-fashioned briefly-focus-a-textarea hack</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">var</span> kludge = hiddenTextarea(), te = kludge.firstChild;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.join(<span class="hljs-string">"\n"</span>);
          <span class="hljs-keyword">var</span> hadFocus = <span class="hljs-built_in">document</span>.activeElement;
          selectInput(te);
          setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();
          }, <span class="hljs-number">50</span>);
        }
      }
      on(div, <span class="hljs-string">"copy"</span>, onCopyCut);
      on(div, <span class="hljs-string">"cut"</span>, onCopyCut);
    },

    prepareSelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> result = prepareSelection(<span class="hljs-keyword">this</span>.cm, <span class="hljs-literal">false</span>);
      result.focus = <span class="hljs-keyword">this</span>.cm.state.focused;
      <span class="hljs-keyword">return</span> result;
    },

    showSelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">info</span>) </span>{
      <span class="hljs-keyword">if</span> (!info || !<span class="hljs-keyword">this</span>.cm.display.view.length) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">if</span> (info.focus) <span class="hljs-keyword">this</span>.showPrimarySelection();
      <span class="hljs-keyword">this</span>.showMultipleSelections(info);
    },

    showPrimarySelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> sel = <span class="hljs-built_in">window</span>.getSelection(), prim = <span class="hljs-keyword">this</span>.cm.doc.sel.primary();
      <span class="hljs-keyword">var</span> curAnchor = domToPos(<span class="hljs-keyword">this</span>.cm, sel.anchorNode, sel.anchorOffset);
      <span class="hljs-keyword">var</span> curFocus = domToPos(<span class="hljs-keyword">this</span>.cm, sel.focusNode, sel.focusOffset);
      <span class="hljs-keyword">if</span> (curAnchor &amp;&amp; !curAnchor.bad &amp;&amp; curFocus &amp;&amp; !curFocus.bad &amp;&amp;
          cmp(minPos(curAnchor, curFocus), prim.from()) == <span class="hljs-number">0</span> &amp;&amp;
          cmp(maxPos(curAnchor, curFocus), prim.to()) == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">var</span> start = posToDOM(<span class="hljs-keyword">this</span>.cm, prim.from());
      <span class="hljs-keyword">var</span> end = posToDOM(<span class="hljs-keyword">this</span>.cm, prim.to());
      <span class="hljs-keyword">if</span> (!start &amp;&amp; !end) <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">var</span> view = <span class="hljs-keyword">this</span>.cm.display.view;
      <span class="hljs-keyword">var</span> old = sel.rangeCount &amp;&amp; sel.getRangeAt(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">if</span> (!start) {
        start = {node: view[<span class="hljs-number">0</span>].measure.map[<span class="hljs-number">2</span>], offset: <span class="hljs-number">0</span>};
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!end) { <span class="hljs-comment">// FIXME dangerously hacky</span>
        <span class="hljs-keyword">var</span> measure = view[view.length - <span class="hljs-number">1</span>].measure;
        <span class="hljs-keyword">var</span> map = measure.maps ? measure.maps[measure.maps.length - <span class="hljs-number">1</span>] : measure.map;
        end = {node: map[map.length - <span class="hljs-number">1</span>], offset: map[map.length - <span class="hljs-number">2</span>] - map[map.length - <span class="hljs-number">3</span>]};
      }

      <span class="hljs-keyword">try</span> { <span class="hljs-keyword">var</span> rng = range(start.node, start.offset, end.offset, end.node); }
      <span class="hljs-keyword">catch</span>(e) {} <span class="hljs-comment">// Our model of the DOM might be outdated, in which case the range we try to set can be impossible</span>
      <span class="hljs-keyword">if</span> (rng) {
        <span class="hljs-keyword">if</span> (!gecko &amp;&amp; <span class="hljs-keyword">this</span>.cm.state.focused) {
          sel.collapse(start.node, start.offset);
          <span class="hljs-keyword">if</span> (!rng.collapsed) sel.addRange(rng);
        } <span class="hljs-keyword">else</span> {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
        <span class="hljs-keyword">if</span> (old &amp;&amp; sel.anchorNode == <span class="hljs-literal">null</span>) sel.addRange(old);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gecko) <span class="hljs-keyword">this</span>.startGracePeriod();
      }
      <span class="hljs-keyword">this</span>.rememberSelection();
    },

    startGracePeriod: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> input = <span class="hljs-keyword">this</span>;
      clearTimeout(<span class="hljs-keyword">this</span>.gracePeriod);
      <span class="hljs-keyword">this</span>.gracePeriod = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        input.gracePeriod = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (input.selectionChanged())
          input.cm.operation(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ input.cm.curOp.selectionChanged = <span class="hljs-literal">true</span>; });
      }, <span class="hljs-number">20</span>);
    },

    showMultipleSelections: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">info</span>) </span>{
      removeChildrenAndAdd(<span class="hljs-keyword">this</span>.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(<span class="hljs-keyword">this</span>.cm.display.selectionDiv, info.selection);
    },

    rememberSelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> sel = <span class="hljs-built_in">window</span>.getSelection();
      <span class="hljs-keyword">this</span>.lastAnchorNode = sel.anchorNode; <span class="hljs-keyword">this</span>.lastAnchorOffset = sel.anchorOffset;
      <span class="hljs-keyword">this</span>.lastFocusNode = sel.focusNode; <span class="hljs-keyword">this</span>.lastFocusOffset = sel.focusOffset;
    },

    selectionInEditor: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> sel = <span class="hljs-built_in">window</span>.getSelection();
      <span class="hljs-keyword">if</span> (!sel.rangeCount) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> node = sel.getRangeAt(<span class="hljs-number">0</span>).commonAncestorContainer;
      <span class="hljs-keyword">return</span> contains(<span class="hljs-keyword">this</span>.div, node);
    },

    focus: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cm.options.readOnly != <span class="hljs-string">"nocursor"</span>) <span class="hljs-keyword">this</span>.div.focus();
    },
    blur: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>.div.blur(); },
    getField: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.div; },

    supportsTouch: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; },

    receivedFocus: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> input = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.selectionInEditor())
        <span class="hljs-keyword">this</span>.pollSelection();
      <span class="hljs-keyword">else</span>
        runInOp(<span class="hljs-keyword">this</span>.cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ input.cm.curOp.selectionChanged = <span class="hljs-literal">true</span>; });

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">poll</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      <span class="hljs-keyword">this</span>.polling.set(<span class="hljs-keyword">this</span>.cm.options.pollInterval, poll);
    },

    selectionChanged: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> sel = <span class="hljs-built_in">window</span>.getSelection();
      <span class="hljs-keyword">return</span> sel.anchorNode != <span class="hljs-keyword">this</span>.lastAnchorNode || sel.anchorOffset != <span class="hljs-keyword">this</span>.lastAnchorOffset ||
        sel.focusNode != <span class="hljs-keyword">this</span>.lastFocusNode || sel.focusOffset != <span class="hljs-keyword">this</span>.lastFocusOffset;
    },

    pollSelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.composing &amp;&amp; !<span class="hljs-keyword">this</span>.gracePeriod &amp;&amp; <span class="hljs-keyword">this</span>.selectionChanged()) {
        <span class="hljs-keyword">var</span> sel = <span class="hljs-built_in">window</span>.getSelection(), cm = <span class="hljs-keyword">this</span>.cm;
        <span class="hljs-keyword">this</span>.rememberSelection();
        <span class="hljs-keyword">var</span> anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        <span class="hljs-keyword">var</span> head = domToPos(cm, sel.focusNode, sel.focusOffset);
        <span class="hljs-keyword">if</span> (anchor &amp;&amp; head) runInOp(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          <span class="hljs-keyword">if</span> (anchor.bad || head.bad) cm.curOp.selectionChanged = <span class="hljs-literal">true</span>;
        });
      }
    },

    pollContent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>.cm, display = cm.display, sel = cm.doc.sel.primary();
      <span class="hljs-keyword">var</span> from = sel.from(), to = sel.to();
      <span class="hljs-keyword">if</span> (from.line &lt; display.viewFrom || to.line &gt; display.viewTo - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">var</span> fromIndex;
      <span class="hljs-keyword">if</span> (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> fromLine = lineNo(display.view[<span class="hljs-number">0</span>].line);
        <span class="hljs-keyword">var</span> fromNode = display.view[<span class="hljs-number">0</span>].node;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> fromLine = lineNo(display.view[fromIndex].line);
        <span class="hljs-keyword">var</span> fromNode = display.view[fromIndex - <span class="hljs-number">1</span>].node.nextSibling;
      }
      <span class="hljs-keyword">var</span> toIndex = findViewIndex(cm, to.line);
      <span class="hljs-keyword">if</span> (toIndex == display.view.length - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">var</span> toLine = display.viewTo - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> toNode = display.lineDiv.lastChild;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> toLine = lineNo(display.view[toIndex + <span class="hljs-number">1</span>].line) - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> toNode = display.view[toIndex + <span class="hljs-number">1</span>].node.previousSibling;
      }

      <span class="hljs-keyword">var</span> newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      <span class="hljs-keyword">var</span> oldText = getBetween(cm.doc, Pos(fromLine, <span class="hljs-number">0</span>), Pos(toLine, getLine(cm.doc, toLine).text.length));
      <span class="hljs-keyword">while</span> (newText.length &gt; <span class="hljs-number">1</span> &amp;&amp; oldText.length &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newText[<span class="hljs-number">0</span>] == oldText[<span class="hljs-number">0</span>]) { newText.shift(); oldText.shift(); fromLine++; }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-keyword">var</span> cutFront = <span class="hljs-number">0</span>, cutEnd = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> newTop = newText[<span class="hljs-number">0</span>], oldTop = oldText[<span class="hljs-number">0</span>], maxCutFront = <span class="hljs-built_in">Math</span>.min(newTop.length, oldTop.length);
      <span class="hljs-keyword">while</span> (cutFront &lt; maxCutFront &amp;&amp; newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
        ++cutFront;
      <span class="hljs-keyword">var</span> newBot = lst(newText), oldBot = lst(oldText);
      <span class="hljs-keyword">var</span> maxCutEnd = <span class="hljs-built_in">Math</span>.min(newBot.length - (newText.length == <span class="hljs-number">1</span> ? cutFront : <span class="hljs-number">0</span>),
                               oldBot.length - (oldText.length == <span class="hljs-number">1</span> ? cutFront : <span class="hljs-number">0</span>));
      <span class="hljs-keyword">while</span> (cutEnd &lt; maxCutEnd &amp;&amp;
             newBot.charCodeAt(newBot.length - cutEnd - <span class="hljs-number">1</span>) == oldBot.charCodeAt(oldBot.length - cutEnd - <span class="hljs-number">1</span>))
        ++cutEnd;

      newText[newText.length - <span class="hljs-number">1</span>] = newBot.slice(<span class="hljs-number">0</span>, newBot.length - cutEnd);
      newText[<span class="hljs-number">0</span>] = newText[<span class="hljs-number">0</span>].slice(cutFront);

      <span class="hljs-keyword">var</span> chFrom = Pos(fromLine, cutFront);
      <span class="hljs-keyword">var</span> chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : <span class="hljs-number">0</span>);
      <span class="hljs-keyword">if</span> (newText.length &gt; <span class="hljs-number">1</span> || newText[<span class="hljs-number">0</span>] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, <span class="hljs-string">"+input"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    },

    ensurePolled: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.forceCompositionEnd();
    },
    reset: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.forceCompositionEnd();
    },
    forceCompositionEnd: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.composing || <span class="hljs-keyword">this</span>.composing.handled) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">this</span>.applyComposition(<span class="hljs-keyword">this</span>.composing);
      <span class="hljs-keyword">this</span>.composing.handled = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">this</span>.div.blur();
      <span class="hljs-keyword">this</span>.div.focus();
    },
    applyComposition: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">composing</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cm.isReadOnly())
        operation(<span class="hljs-keyword">this</span>.cm, regChange)(<span class="hljs-keyword">this</span>.cm)
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (composing.data &amp;&amp; composing.data != composing.startData)
        operation(<span class="hljs-keyword">this</span>.cm, applyTextInput)(<span class="hljs-keyword">this</span>.cm, composing.data, <span class="hljs-number">0</span>, composing.sel);
    },

    setUneditable: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
      node.contentEditable = <span class="hljs-string">"false"</span>
    },

    onKeyPress: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
      e.preventDefault();
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.cm.isReadOnly())
        operation(<span class="hljs-keyword">this</span>.cm, applyTextInput)(<span class="hljs-keyword">this</span>.cm, <span class="hljs-built_in">String</span>.fromCharCode(e.charCode == <span class="hljs-literal">null</span> ? e.keyCode : e.charCode), <span class="hljs-number">0</span>);
    },

    readOnlyChanged: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
      <span class="hljs-keyword">this</span>.div.contentEditable = <span class="hljs-built_in">String</span>(val != <span class="hljs-string">"nocursor"</span>)
    },

    onContextMenu: nothing,
    resetPosition: nothing,

    needsContentAttribute: <span class="hljs-literal">true</span>
  }, ContentEditableInput.prototype);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">posToDOM</span>(<span class="hljs-params">cm, pos</span>) </span>{
    <span class="hljs-keyword">var</span> view = findViewForLine(cm, pos.line);
    <span class="hljs-keyword">if</span> (!view || view.hidden) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> line = getLine(cm.doc, pos.line);
    <span class="hljs-keyword">var</span> info = mapFromLineView(view, line, pos.line);

    <span class="hljs-keyword">var</span> order = getOrder(line), side = <span class="hljs-string">"left"</span>;
    <span class="hljs-keyword">if</span> (order) {
      <span class="hljs-keyword">var</span> partPos = getBidiPartAt(order, pos.ch);
      side = partPos % <span class="hljs-number">2</span> ? <span class="hljs-string">"right"</span> : <span class="hljs-string">"left"</span>;
    }
    <span class="hljs-keyword">var</span> result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == <span class="hljs-string">"right"</span> ? result.end : result.start;
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">badPos</span>(<span class="hljs-params">pos, bad</span>) </span>{ <span class="hljs-keyword">if</span> (bad) pos.bad = <span class="hljs-literal">true</span>; <span class="hljs-keyword">return</span> pos; }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">domToPos</span>(<span class="hljs-params">cm, node, offset</span>) </span>{
    <span class="hljs-keyword">var</span> lineNode;
    <span class="hljs-keyword">if</span> (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      <span class="hljs-keyword">if</span> (!lineNode) <span class="hljs-keyword">return</span> badPos(cm.clipPos(Pos(cm.display.viewTo - <span class="hljs-number">1</span>)), <span class="hljs-literal">true</span>);
      node = <span class="hljs-literal">null</span>; offset = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">for</span> (lineNode = node;; lineNode = lineNode.parentNode) {
        <span class="hljs-keyword">if</span> (!lineNode || lineNode == cm.display.lineDiv) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (lineNode.parentNode &amp;&amp; lineNode.parentNode == cm.display.lineDiv) <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; cm.display.view.length; i++) {
      <span class="hljs-keyword">var</span> lineView = cm.display.view[i];
      <span class="hljs-keyword">if</span> (lineView.node == lineNode)
        <span class="hljs-keyword">return</span> locateNodeInLineView(lineView, node, offset);
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">locateNodeInLineView</span>(<span class="hljs-params">lineView, node, offset</span>) </span>{
    <span class="hljs-keyword">var</span> wrapper = lineView.text.firstChild, bad = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (!node || !contains(wrapper, node)) <span class="hljs-keyword">return</span> badPos(Pos(lineNo(lineView.line), <span class="hljs-number">0</span>), <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (node == wrapper) {
      bad = <span class="hljs-literal">true</span>;
      node = wrapper.childNodes[offset];
      offset = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (!node) {
        <span class="hljs-keyword">var</span> line = lineView.rest ? lst(lineView.rest) : lineView.line;
        <span class="hljs-keyword">return</span> badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    <span class="hljs-keyword">var</span> textNode = node.nodeType == <span class="hljs-number">3</span> ? node : <span class="hljs-literal">null</span>, topNode = node;
    <span class="hljs-keyword">if</span> (!textNode &amp;&amp; node.childNodes.length == <span class="hljs-number">1</span> &amp;&amp; node.firstChild.nodeType == <span class="hljs-number">3</span>) {
      textNode = node.firstChild;
      <span class="hljs-keyword">if</span> (offset) offset = textNode.nodeValue.length;
    }
    <span class="hljs-keyword">while</span> (topNode.parentNode != wrapper) topNode = topNode.parentNode;
    <span class="hljs-keyword">var</span> measure = lineView.measure, maps = measure.maps;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">textNode, topNode, offset</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>; i &lt; (maps ? maps.length : <span class="hljs-number">0</span>); i++) {
        <span class="hljs-keyword">var</span> map = i &lt; <span class="hljs-number">0</span> ? measure.map : maps[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; map.length; j += <span class="hljs-number">3</span>) {
          <span class="hljs-keyword">var</span> curNode = map[j + <span class="hljs-number">2</span>];
          <span class="hljs-keyword">if</span> (curNode == textNode || curNode == topNode) {
            <span class="hljs-keyword">var</span> line = lineNo(i &lt; <span class="hljs-number">0</span> ? lineView.line : lineView.rest[i]);
            <span class="hljs-keyword">var</span> ch = map[j] + offset;
            <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span> || curNode != textNode) ch = map[j + (offset ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)];
            <span class="hljs-keyword">return</span> Pos(line, ch);
          }
        }
      }
    }
    <span class="hljs-keyword">var</span> found = find(textNode, topNode, offset);
    <span class="hljs-keyword">if</span> (found) <span class="hljs-keyword">return</span> badPos(found, bad);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : <span class="hljs-number">0</span>; after; after = after.nextSibling) {
      found = find(after, after.firstChild, <span class="hljs-number">0</span>);
      <span class="hljs-keyword">if</span> (found)
        <span class="hljs-keyword">return</span> badPos(Pos(found.line, found.ch - dist), bad);
      <span class="hljs-keyword">else</span>
        dist += after.textContent.length;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -<span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (found)
        <span class="hljs-keyword">return</span> badPos(Pos(found.line, found.ch + dist), bad);
      <span class="hljs-keyword">else</span>
        dist += after.textContent.length;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">domTextBetween</span>(<span class="hljs-params">cm, from, to, fromLine, toLine</span>) </span>{
    <span class="hljs-keyword">var</span> text = <span class="hljs-string">""</span>, closing = <span class="hljs-literal">false</span>, lineSep = cm.doc.lineSeparator();
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recognizeMarker</span>(<span class="hljs-params">id</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">marker</span>) </span>{ <span class="hljs-keyword">return</span> marker.id == id; }; }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walk</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">var</span> cmText = node.getAttribute(<span class="hljs-string">"cm-text"</span>);
        <span class="hljs-keyword">if</span> (cmText != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (cmText == <span class="hljs-string">""</span>) cmText = node.textContent.replace(<span class="hljs-regexp">/\u200b/g</span>, <span class="hljs-string">""</span>);
          text += cmText;
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">var</span> markerID = node.getAttribute(<span class="hljs-string">"cm-marker"</span>), range;
        <span class="hljs-keyword">if</span> (markerID) {
          <span class="hljs-keyword">var</span> found = cm.findMarks(Pos(fromLine, <span class="hljs-number">0</span>), Pos(toLine + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), recognizeMarker(+markerID));
          <span class="hljs-keyword">if</span> (found.length &amp;&amp; (range = found[<span class="hljs-number">0</span>].find()))
            text += getBetween(cm.doc, range.from, range.to).join(lineSep);
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">if</span> (node.getAttribute(<span class="hljs-string">"contenteditable"</span>) == <span class="hljs-string">"false"</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.childNodes.length; i++)
          walk(node.childNodes[i]);
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(pre|div|p)$/i</span>.test(node.nodeName))
          closing = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">3</span>) {
        <span class="hljs-keyword">var</span> val = node.nodeValue;
        <span class="hljs-keyword">if</span> (!val) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (closing) {
          text += lineSep;
          closing = <span class="hljs-literal">false</span>;
        }
        text += val;
      }
    }
    <span class="hljs-keyword">for</span> (;;) {
      walk(from);
      <span class="hljs-keyword">if</span> (from == to) <span class="hljs-keyword">break</span>;
      from = from.nextSibling;
    }
    <span class="hljs-keyword">return</span> text;
  }

  CodeMirror.inputStyles = {<span class="hljs-string">"textarea"</span>: TextareaInput, <span class="hljs-string">"contenteditable"</span>: ContentEditableInput};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>SELECTION / CURSOR</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Selection objects are immutable. A new one is created every time
the selection changes. A selection is one or more non-overlapping
(and non-touching) ranges, sorted, and an integer that indicates
which one is the primary selection (the one that&#39;s scrolled into
view, that getCursor returns, etc).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Selection</span>(<span class="hljs-params">ranges, primIndex</span>) </span>{
    <span class="hljs-keyword">this</span>.ranges = ranges;
    <span class="hljs-keyword">this</span>.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ranges[<span class="hljs-keyword">this</span>.primIndex]; },
    equals: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">other</span>) </span>{
      <span class="hljs-keyword">if</span> (other == <span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (other.primIndex != <span class="hljs-keyword">this</span>.primIndex || other.ranges.length != <span class="hljs-keyword">this</span>.ranges.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.ranges.length; i++) {
        <span class="hljs-keyword">var</span> here = <span class="hljs-keyword">this</span>.ranges[i], there = other.ranges[i];
        <span class="hljs-keyword">if</span> (cmp(here.anchor, there.anchor) != <span class="hljs-number">0</span> || cmp(here.head, there.head) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    },
    deepCopy: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> out = [], i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.ranges.length; i++)
        out[i] = <span class="hljs-keyword">new</span> Range(copyPos(<span class="hljs-keyword">this</span>.ranges[i].anchor), copyPos(<span class="hljs-keyword">this</span>.ranges[i].head));
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Selection(out, <span class="hljs-keyword">this</span>.primIndex);
    },
    somethingSelected: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.ranges.length; i++)
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ranges[i].empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    },
    contains: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, end</span>) </span>{
      <span class="hljs-keyword">if</span> (!end) end = pos;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.ranges.length; i++) {
        <span class="hljs-keyword">var</span> range = <span class="hljs-keyword">this</span>.ranges[i];
        <span class="hljs-keyword">if</span> (cmp(end, range.from()) &gt;= <span class="hljs-number">0</span> &amp;&amp; cmp(pos, range.to()) &lt;= <span class="hljs-number">0</span>)
          <span class="hljs-keyword">return</span> i;
      }
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Range</span>(<span class="hljs-params">anchor, head</span>) </span>{
    <span class="hljs-keyword">this</span>.anchor = anchor; <span class="hljs-keyword">this</span>.head = head;
  }

  Range.prototype = {
    from: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> minPos(<span class="hljs-keyword">this</span>.anchor, <span class="hljs-keyword">this</span>.head); },
    to: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> maxPos(<span class="hljs-keyword">this</span>.anchor, <span class="hljs-keyword">this</span>.head); },
    empty: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head.line == <span class="hljs-keyword">this</span>.anchor.line &amp;&amp; <span class="hljs-keyword">this</span>.head.ch == <span class="hljs-keyword">this</span>.anchor.ch;
    }
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Take an unsorted, potentially overlapping set of ranges, and
build a selection out of it. &#39;Consumes&#39; ranges array (modifying
it).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeSelection</span>(<span class="hljs-params">ranges, primIndex</span>) </span>{
    <span class="hljs-keyword">var</span> prim = ranges[primIndex];
    ranges.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{ <span class="hljs-keyword">return</span> cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; ranges.length; i++) {
      <span class="hljs-keyword">var</span> cur = ranges[i], prev = ranges[i - <span class="hljs-number">1</span>];
      <span class="hljs-keyword">if</span> (cmp(prev.to(), cur.from()) &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        <span class="hljs-keyword">var</span> inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        <span class="hljs-keyword">if</span> (i &lt;= primIndex) --primIndex;
        ranges.splice(--i, <span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Range(inv ? to : from, inv ? from : to));
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Selection(ranges, primIndex);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">simpleSelection</span>(<span class="hljs-params">anchor, head</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Selection([<span class="hljs-keyword">new</span> Range(anchor, head || anchor)], <span class="hljs-number">0</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Most of the external API clips given positions to make sure they
actually exist within the document.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clipLine</span>(<span class="hljs-params">doc, n</span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(doc.first, <span class="hljs-built_in">Math</span>.min(n, doc.first + doc.size - <span class="hljs-number">1</span>));}
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clipPos</span>(<span class="hljs-params">doc, pos</span>) </span>{
    <span class="hljs-keyword">if</span> (pos.line &lt; doc.first) <span class="hljs-keyword">return</span> Pos(doc.first, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">var</span> last = doc.first + doc.size - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (pos.line &gt; last) <span class="hljs-keyword">return</span> Pos(last, getLine(doc, last).text.length);
    <span class="hljs-keyword">return</span> clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clipToLen</span>(<span class="hljs-params">pos, linelen</span>) </span>{
    <span class="hljs-keyword">var</span> ch = pos.ch;
    <span class="hljs-keyword">if</span> (ch == <span class="hljs-literal">null</span> || ch &gt; linelen) <span class="hljs-keyword">return</span> Pos(pos.line, linelen);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Pos(pos.line, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> pos;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLine</span>(<span class="hljs-params">doc, l</span>) </span>{<span class="hljs-keyword">return</span> l &gt;= doc.first &amp;&amp; l &lt; doc.first + doc.size;}
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clipPosArray</span>(<span class="hljs-params">doc, array</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> out = [], i = <span class="hljs-number">0</span>; i &lt; array.length; i++) out[i] = clipPos(doc, array[i]);
    <span class="hljs-keyword">return</span> out;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>SELECTION UPDATES</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The &#39;scroll&#39; parameter given to many of these indicated whether
the new cursor position should be scrolled into view after
modifying the selection.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If shift is held or the extend flag is set, extends a range to
include a given position (and optionally a second position).
Otherwise, simply returns the range between the given positions.
Used for cursor motion and such.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extendRange</span>(<span class="hljs-params">doc, range, head, other</span>) </span>{
    <span class="hljs-keyword">if</span> (doc.cm &amp;&amp; doc.cm.display.shift || doc.extend) {
      <span class="hljs-keyword">var</span> anchor = range.anchor;
      <span class="hljs-keyword">if</span> (other) {
        <span class="hljs-keyword">var</span> posBefore = cmp(head, anchor) &lt; <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (posBefore != (cmp(other, anchor) &lt; <span class="hljs-number">0</span>)) {
          anchor = head;
          head = other;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (posBefore != (cmp(head, other) &lt; <span class="hljs-number">0</span>)) {
          head = other;
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Range(anchor, head);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Range(other || head, head);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extend the primary selection range, discard the rest.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extendSelection</span>(<span class="hljs-params">doc, head, other, options</span>) </span>{
    setSelection(doc, <span class="hljs-keyword">new</span> Selection([extendRange(doc, doc.sel.primary(), head, other)], <span class="hljs-number">0</span>), options);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extend all selections (pos is an array of selections with length
equal the number of selections)</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extendSelections</span>(<span class="hljs-params">doc, heads, options</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> out = [], i = <span class="hljs-number">0</span>; i &lt; doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">var</span> newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Updates a single range in the selection.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceOneSelection</span>(<span class="hljs-params">doc, i, range, options</span>) </span>{
    <span class="hljs-keyword">var</span> ranges = doc.sel.ranges.slice(<span class="hljs-number">0</span>);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reset the selection to a single range.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSimpleSelection</span>(<span class="hljs-params">doc, anchor, head, options</span>) </span>{
    setSelection(doc, simpleSelection(anchor, head), options);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Give beforeSelectionChange handlers a change to influence a
selection update.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterSelectionChange</span>(<span class="hljs-params">doc, sel, options</span>) </span>{
    <span class="hljs-keyword">var</span> obj = {
      ranges: sel.ranges,
      update: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ranges</span>) </span>{
        <span class="hljs-keyword">this</span>.ranges = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ranges.length; i++)
          <span class="hljs-keyword">this</span>.ranges[i] = <span class="hljs-keyword">new</span> Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      },
      origin: options &amp;&amp; options.origin
    };
    signal(doc, <span class="hljs-string">"beforeSelectionChange"</span>, doc, obj);
    <span class="hljs-keyword">if</span> (doc.cm) signal(doc.cm, <span class="hljs-string">"beforeSelectionChange"</span>, doc.cm, obj);
    <span class="hljs-keyword">if</span> (obj.ranges != sel.ranges) <span class="hljs-keyword">return</span> normalizeSelection(obj.ranges, obj.ranges.length - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> sel;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSelectionReplaceHistory</span>(<span class="hljs-params">doc, sel, options</span>) </span>{
    <span class="hljs-keyword">var</span> done = doc.history.done, last = lst(done);
    <span class="hljs-keyword">if</span> (last &amp;&amp; last.ranges) {
      done[done.length - <span class="hljs-number">1</span>] = sel;
      setSelectionNoUndo(doc, sel, options);
    } <span class="hljs-keyword">else</span> {
      setSelection(doc, sel, options);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set a new selection.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSelection</span>(<span class="hljs-params">doc, sel, options</span>) </span>{
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : <span class="hljs-literal">NaN</span>, options);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSelectionNoUndo</span>(<span class="hljs-params">doc, sel, options</span>) </span>{
    <span class="hljs-keyword">if</span> (hasHandler(doc, <span class="hljs-string">"beforeSelectionChange"</span>) || doc.cm &amp;&amp; hasHandler(doc.cm, <span class="hljs-string">"beforeSelectionChange"</span>))
      sel = filterSelectionChange(doc, sel, options);

    <span class="hljs-keyword">var</span> bias = options &amp;&amp; options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, <span class="hljs-literal">true</span>));

    <span class="hljs-keyword">if</span> (!(options &amp;&amp; options.scroll === <span class="hljs-literal">false</span>) &amp;&amp; doc.cm)
      ensureCursorVisible(doc.cm);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSelectionInner</span>(<span class="hljs-params">doc, sel</span>) </span>{
    <span class="hljs-keyword">if</span> (sel.equals(doc.sel)) <span class="hljs-keyword">return</span>;

    doc.sel = sel;

    <span class="hljs-keyword">if</span> (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = <span class="hljs-literal">true</span>;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, <span class="hljs-string">"cursorActivity"</span>, doc);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Verify that the selection does not partially select any atomic
marked ranges.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reCheckSelection</span>(<span class="hljs-params">doc</span>) </span>{
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>), sel_dontScroll);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return a selection that does not partially select any atomic
ranges.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipAtomicInSelection</span>(<span class="hljs-params">doc, sel, bias, mayClear</span>) </span>{
    <span class="hljs-keyword">var</span> out;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; sel.ranges.length; i++) {
      <span class="hljs-keyword">var</span> range = sel.ranges[i];
      <span class="hljs-keyword">var</span> old = sel.ranges.length == doc.sel.ranges.length &amp;&amp; doc.sel.ranges[i];
      <span class="hljs-keyword">var</span> newAnchor = skipAtomic(doc, range.anchor, old &amp;&amp; old.anchor, bias, mayClear);
      <span class="hljs-keyword">var</span> newHead = skipAtomic(doc, range.head, old &amp;&amp; old.head, bias, mayClear);
      <span class="hljs-keyword">if</span> (out || newAnchor != range.anchor || newHead != range.head) {
        <span class="hljs-keyword">if</span> (!out) out = sel.ranges.slice(<span class="hljs-number">0</span>, i);
        out[i] = <span class="hljs-keyword">new</span> Range(newAnchor, newHead);
      }
    }
    <span class="hljs-keyword">return</span> out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipAtomicInner</span>(<span class="hljs-params">doc, pos, oldPos, dir, mayClear</span>) </span>{
    <span class="hljs-keyword">var</span> line = getLine(doc, pos.line);
    <span class="hljs-keyword">if</span> (line.markedSpans) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; line.markedSpans.length; ++i) {
      <span class="hljs-keyword">var</span> sp = line.markedSpans[i], m = sp.marker;
      <span class="hljs-keyword">if</span> ((sp.from == <span class="hljs-literal">null</span> || (m.inclusiveLeft ? sp.from &lt;= pos.ch : sp.from &lt; pos.ch)) &amp;&amp;
          (sp.to == <span class="hljs-literal">null</span> || (m.inclusiveRight ? sp.to &gt;= pos.ch : sp.to &gt; pos.ch))) {
        <span class="hljs-keyword">if</span> (mayClear) {
          signal(m, <span class="hljs-string">"beforeCursorEnter"</span>);
          <span class="hljs-keyword">if</span> (m.explicitlyCleared) {
            <span class="hljs-keyword">if</span> (!line.markedSpans) <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">else</span> {--i; <span class="hljs-keyword">continue</span>;}
          }
        }
        <span class="hljs-keyword">if</span> (!m.atomic) <span class="hljs-keyword">continue</span>;

        <span class="hljs-keyword">if</span> (oldPos) {
          <span class="hljs-keyword">var</span> near = m.find(dir &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>), diff;
          <span class="hljs-keyword">if</span> (dir &lt; <span class="hljs-number">0</span> ? m.inclusiveRight : m.inclusiveLeft)
            near = movePos(doc, near, -dir, near &amp;&amp; near.line == pos.line ? line : <span class="hljs-literal">null</span>);
          <span class="hljs-keyword">if</span> (near &amp;&amp; near.line == pos.line &amp;&amp; (diff = cmp(near, oldPos)) &amp;&amp; (dir &lt; <span class="hljs-number">0</span> ? diff &lt; <span class="hljs-number">0</span> : diff &gt; <span class="hljs-number">0</span>))
            <span class="hljs-keyword">return</span> skipAtomicInner(doc, near, pos, dir, mayClear);
        }

        <span class="hljs-keyword">var</span> far = m.find(dir &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (dir &lt; <span class="hljs-number">0</span> ? m.inclusiveLeft : m.inclusiveRight)
          far = movePos(doc, far, dir, far.line == pos.line ? line : <span class="hljs-literal">null</span>);
        <span class="hljs-keyword">return</span> far ? skipAtomicInner(doc, far, pos, dir, mayClear) : <span class="hljs-literal">null</span>;
      }
    }
    <span class="hljs-keyword">return</span> pos;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure a given position is not inside an atomic range.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipAtomic</span>(<span class="hljs-params">doc, pos, oldPos, bias, mayClear</span>) </span>{
    <span class="hljs-keyword">var</span> dir = bias || <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear &amp;&amp; skipAtomicInner(doc, pos, oldPos, dir, <span class="hljs-literal">true</span>)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear &amp;&amp; skipAtomicInner(doc, pos, oldPos, -dir, <span class="hljs-literal">true</span>));
    <span class="hljs-keyword">if</span> (!found) {
      doc.cantEdit = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> Pos(doc.first, <span class="hljs-number">0</span>);
    }
    <span class="hljs-keyword">return</span> found;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">movePos</span>(<span class="hljs-params">doc, pos, dir, line</span>) </span>{
    <span class="hljs-keyword">if</span> (dir &lt; <span class="hljs-number">0</span> &amp;&amp; pos.ch == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span> (pos.line &gt; doc.first) <span class="hljs-keyword">return</span> clipPos(doc, Pos(pos.line - <span class="hljs-number">1</span>));
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dir &gt; <span class="hljs-number">0</span> &amp;&amp; pos.ch == (line || getLine(doc, pos.line)).text.length) {
      <span class="hljs-keyword">if</span> (pos.line &lt; doc.first + doc.size - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Pos(pos.line + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pos(pos.line, pos.ch + dir);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>SELECTION DRAWING</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateSelection</span>(<span class="hljs-params">cm</span>) </span>{
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepareSelection</span>(<span class="hljs-params">cm, primary</span>) </span>{
    <span class="hljs-keyword">var</span> doc = cm.doc, result = {};
    <span class="hljs-keyword">var</span> curFragment = result.cursors = <span class="hljs-built_in">document</span>.createDocumentFragment();
    <span class="hljs-keyword">var</span> selFragment = result.selection = <span class="hljs-built_in">document</span>.createDocumentFragment();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; doc.sel.ranges.length; i++) {
      <span class="hljs-keyword">if</span> (primary === <span class="hljs-literal">false</span> &amp;&amp; i == doc.sel.primIndex) <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">var</span> range = doc.sel.ranges[i];
      <span class="hljs-keyword">if</span> (range.from().line &gt;= cm.display.viewTo || range.to().line &lt; cm.display.viewFrom) <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">var</span> collapsed = range.empty();
      <span class="hljs-keyword">if</span> (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range.head, curFragment);
      <span class="hljs-keyword">if</span> (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }
    <span class="hljs-keyword">return</span> result;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Draws a cursor for the given range</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawSelectionCursor</span>(<span class="hljs-params">cm, head, output</span>) </span>{
    <span class="hljs-keyword">var</span> pos = cursorCoords(cm, head, <span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, !cm.options.singleCursorHeightPerLine);

    <span class="hljs-keyword">var</span> cursor = output.appendChild(elt(<span class="hljs-string">"div"</span>, <span class="hljs-string">"\u00a0"</span>, <span class="hljs-string">"CodeMirror-cursor"</span>));
    cursor.style.left = pos.left + <span class="hljs-string">"px"</span>;
    cursor.style.top = pos.top + <span class="hljs-string">"px"</span>;
    cursor.style.height = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, pos.bottom - pos.top) * cm.options.cursorHeight + <span class="hljs-string">"px"</span>;

    <span class="hljs-keyword">if</span> (pos.other) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Secondary cursor, shown when on a &#39;jump&#39; in bi-directional text</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> otherCursor = output.appendChild(elt(<span class="hljs-string">"div"</span>, <span class="hljs-string">"\u00a0"</span>, <span class="hljs-string">"CodeMirror-cursor CodeMirror-secondarycursor"</span>));
      otherCursor.style.display = <span class="hljs-string">""</span>;
      otherCursor.style.left = pos.other.left + <span class="hljs-string">"px"</span>;
      otherCursor.style.top = pos.other.top + <span class="hljs-string">"px"</span>;
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * <span class="hljs-number">.85</span> + <span class="hljs-string">"px"</span>;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Draws the given range as a highlighted selection</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawSelectionRange</span>(<span class="hljs-params">cm, range, output</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display, doc = cm.doc;
    <span class="hljs-keyword">var</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();
    <span class="hljs-keyword">var</span> padding = paddingH(cm.display), leftSide = padding.left;
    <span class="hljs-keyword">var</span> rightSide = <span class="hljs-built_in">Math</span>.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">left, top, width, bottom</span>) </span>{
      <span class="hljs-keyword">if</span> (top &lt; <span class="hljs-number">0</span>) top = <span class="hljs-number">0</span>;
      top = <span class="hljs-built_in">Math</span>.round(top);
      bottom = <span class="hljs-built_in">Math</span>.round(bottom);
      fragment.appendChild(elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-selected"</span>, <span class="hljs-string">"position: absolute; left: "</span> + left +
                               <span class="hljs-string">"px; top: "</span> + top + <span class="hljs-string">"px; width: "</span> + (width == <span class="hljs-literal">null</span> ? rightSide - left : width) +
                               <span class="hljs-string">"px; height: "</span> + (bottom - top) + <span class="hljs-string">"px"</span>));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawForLine</span>(<span class="hljs-params">line, fromArg, toArg</span>) </span>{
      <span class="hljs-keyword">var</span> lineObj = getLine(doc, line);
      <span class="hljs-keyword">var</span> lineLen = lineObj.text.length;
      <span class="hljs-keyword">var</span> start, end;
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coords</span>(<span class="hljs-params">ch, bias</span>) </span>{
        <span class="hljs-keyword">return</span> charCoords(cm, Pos(line, ch), <span class="hljs-string">"div"</span>, lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || <span class="hljs-number">0</span>, toArg == <span class="hljs-literal">null</span> ? lineLen : toArg, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, to, dir</span>) </span>{
        <span class="hljs-keyword">var</span> leftPos = coords(from, <span class="hljs-string">"left"</span>), rightPos, left, right;
        <span class="hljs-keyword">if</span> (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } <span class="hljs-keyword">else</span> {
          rightPos = coords(to - <span class="hljs-number">1</span>, <span class="hljs-string">"right"</span>);
          <span class="hljs-keyword">if</span> (dir == <span class="hljs-string">"rtl"</span>) { <span class="hljs-keyword">var</span> tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        <span class="hljs-keyword">if</span> (fromArg == <span class="hljs-literal">null</span> &amp;&amp; from == <span class="hljs-number">0</span>) left = leftSide;
        <span class="hljs-keyword">if</span> (rightPos.top - leftPos.top &gt; <span class="hljs-number">3</span>) { <span class="hljs-comment">// Different lines, draw top part</span>
          add(left, leftPos.top, <span class="hljs-literal">null</span>, leftPos.bottom);
          left = leftSide;
          <span class="hljs-keyword">if</span> (leftPos.bottom &lt; rightPos.top) add(left, leftPos.bottom, <span class="hljs-literal">null</span>, rightPos.top);
        }
        <span class="hljs-keyword">if</span> (toArg == <span class="hljs-literal">null</span> &amp;&amp; to == lineLen) right = rightSide;
        <span class="hljs-keyword">if</span> (!start || leftPos.top &lt; start.top || leftPos.top == start.top &amp;&amp; leftPos.left &lt; start.left)
          start = leftPos;
        <span class="hljs-keyword">if</span> (!end || rightPos.bottom &gt; end.bottom || rightPos.bottom == end.bottom &amp;&amp; rightPos.right &gt; end.right)
          end = rightPos;
        <span class="hljs-keyword">if</span> (left &lt; leftSide + <span class="hljs-number">1</span>) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      <span class="hljs-keyword">return</span> {start: start, end: end};
    }

    <span class="hljs-keyword">var</span> sFrom = range.from(), sTo = range.to();
    <span class="hljs-keyword">if</span> (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      <span class="hljs-keyword">var</span> singleVLine = visualLine(fromLine) == visualLine(toLine);
      <span class="hljs-keyword">var</span> leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + <span class="hljs-number">1</span> : <span class="hljs-literal">null</span>).end;
      <span class="hljs-keyword">var</span> rightStart = drawForLine(sTo.line, singleVLine ? <span class="hljs-number">0</span> : <span class="hljs-literal">null</span>, sTo.ch).start;
      <span class="hljs-keyword">if</span> (singleVLine) {
        <span class="hljs-keyword">if</span> (leftEnd.top &lt; rightStart.top - <span class="hljs-number">2</span>) {
          add(leftEnd.right, leftEnd.top, <span class="hljs-literal">null</span>, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } <span class="hljs-keyword">else</span> {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      <span class="hljs-keyword">if</span> (leftEnd.bottom &lt; rightStart.top)
        add(leftSide, leftEnd.bottom, <span class="hljs-literal">null</span>, rightStart.top);
    }

    output.appendChild(fragment);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cursor-blinking</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restartBlink</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">if</span> (!cm.state.focused) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> display = cm.display;
    clearInterval(display.blinker);
    <span class="hljs-keyword">var</span> on = <span class="hljs-literal">true</span>;
    display.cursorDiv.style.visibility = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">if</span> (cm.options.cursorBlinkRate &gt; <span class="hljs-number">0</span>)
      display.blinker = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        display.cursorDiv.style.visibility = (on = !on) ? <span class="hljs-string">""</span> : <span class="hljs-string">"hidden"</span>;
      }, cm.options.cursorBlinkRate);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cm.options.cursorBlinkRate &lt; <span class="hljs-number">0</span>)
      display.cursorDiv.style.visibility = <span class="hljs-string">"hidden"</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>HIGHLIGHT WORKER</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startWorker</span>(<span class="hljs-params">cm, time</span>) </span>{
    <span class="hljs-keyword">if</span> (cm.doc.mode.startState &amp;&amp; cm.doc.frontier &lt; cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">highlightWorker</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> doc = cm.doc;
    <span class="hljs-keyword">if</span> (doc.frontier &lt; doc.first) doc.frontier = doc.first;
    <span class="hljs-keyword">if</span> (doc.frontier &gt;= cm.display.viewTo) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> end = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> + cm.options.workTime;
    <span class="hljs-keyword">var</span> state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    <span class="hljs-keyword">var</span> changedLines = [];

    doc.iter(doc.frontier, <span class="hljs-built_in">Math</span>.min(doc.first + doc.size, cm.display.viewTo + <span class="hljs-number">500</span>), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">if</span> (doc.frontier &gt;= cm.display.viewFrom) { <span class="hljs-comment">// Visible</span>
        <span class="hljs-keyword">var</span> oldStyles = line.styles, tooLong = line.text.length &gt; cm.options.maxHighlightLength;
        <span class="hljs-keyword">var</span> highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, <span class="hljs-literal">true</span>);
        line.styles = highlighted.styles;
        <span class="hljs-keyword">var</span> oldCls = line.styleClasses, newCls = highlighted.classes;
        <span class="hljs-keyword">if</span> (newCls) line.styleClasses = newCls;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldCls) line.styleClasses = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls &amp;&amp; (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; !ischange &amp;&amp; i &lt; oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        <span class="hljs-keyword">if</span> (ischange) changedLines.push(doc.frontier);
        line.stateAfter = tooLong ? state : copyState(doc.mode, state);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (line.text.length &lt;= cm.options.maxHighlightLength)
          processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> ? copyState(doc.mode, state) : <span class="hljs-literal">null</span>;
      }
      ++doc.frontier;
      <span class="hljs-keyword">if</span> (+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> &gt; end) {
        startWorker(cm, cm.options.workDelay);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    });
    <span class="hljs-keyword">if</span> (changedLines.length) runInOp(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; changedLines.length; i++)
        regLineChange(cm, changedLines[i], <span class="hljs-string">"text"</span>);
    });
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finds the line to start with when starting a parse. Tries to
find a line with a stateAfter, so that it can start with a
valid state. If that fails, it returns the line with the
smallest indentation, which tends to need the least context to
parse correctly.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findStartLine</span>(<span class="hljs-params">cm, n, precise</span>) </span>{
    <span class="hljs-keyword">var</span> minindent, minline, doc = cm.doc;
    <span class="hljs-keyword">var</span> lim = precise ? -<span class="hljs-number">1</span> : n - (cm.doc.mode.innerMode ? <span class="hljs-number">1000</span> : <span class="hljs-number">100</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> search = n; search &gt; lim; --search) {
      <span class="hljs-keyword">if</span> (search &lt;= doc.first) <span class="hljs-keyword">return</span> doc.first;
      <span class="hljs-keyword">var</span> line = getLine(doc, search - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (line.stateAfter &amp;&amp; (!precise || search &lt;= doc.frontier)) <span class="hljs-keyword">return</span> search;
      <span class="hljs-keyword">var</span> indented = countColumn(line.text, <span class="hljs-literal">null</span>, cm.options.tabSize);
      <span class="hljs-keyword">if</span> (minline == <span class="hljs-literal">null</span> || minindent &gt; indented) {
        minline = search - <span class="hljs-number">1</span>;
        minindent = indented;
      }
    }
    <span class="hljs-keyword">return</span> minline;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStateBefore</span>(<span class="hljs-params">cm, n, precise</span>) </span>{
    <span class="hljs-keyword">var</span> doc = cm.doc, display = cm.display;
    <span class="hljs-keyword">if</span> (!doc.mode.startState) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> pos = findStartLine(cm, n, precise), state = pos &gt; doc.first &amp;&amp; getLine(doc, pos-<span class="hljs-number">1</span>).stateAfter;
    <span class="hljs-keyword">if</span> (!state) state = startState(doc.mode);
    <span class="hljs-keyword">else</span> state = copyState(doc.mode, state);
    doc.iter(pos, n, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      processLine(cm, line.text, state);
      <span class="hljs-keyword">var</span> save = pos == n - <span class="hljs-number">1</span> || pos % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> || pos &gt;= display.viewFrom &amp;&amp; pos &lt; display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : <span class="hljs-literal">null</span>;
      ++pos;
    });
    <span class="hljs-keyword">if</span> (precise) doc.frontier = pos;
    <span class="hljs-keyword">return</span> state;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>POSITION MEASUREMENT</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">paddingTop</span>(<span class="hljs-params">display</span>) </span>{<span class="hljs-keyword">return</span> display.lineSpace.offsetTop;}
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">paddingVert</span>(<span class="hljs-params">display</span>) </span>{<span class="hljs-keyword">return</span> display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">paddingH</span>(<span class="hljs-params">display</span>) </span>{
    <span class="hljs-keyword">if</span> (display.cachedPaddingH) <span class="hljs-keyword">return</span> display.cachedPaddingH;
    <span class="hljs-keyword">var</span> e = removeChildrenAndAdd(display.measure, elt(<span class="hljs-string">"pre"</span>, <span class="hljs-string">"x"</span>));
    <span class="hljs-keyword">var</span> style = <span class="hljs-built_in">window</span>.getComputedStyle ? <span class="hljs-built_in">window</span>.getComputedStyle(e) : e.currentStyle;
    <span class="hljs-keyword">var</span> data = {left: <span class="hljs-built_in">parseInt</span>(style.paddingLeft), right: <span class="hljs-built_in">parseInt</span>(style.paddingRight)};
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(data.left) &amp;&amp; !<span class="hljs-built_in">isNaN</span>(data.right)) display.cachedPaddingH = data;
    <span class="hljs-keyword">return</span> data;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scrollGap</span>(<span class="hljs-params">cm</span>) </span>{ <span class="hljs-keyword">return</span> scrollerGap - cm.display.nativeBarWidth; }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayWidth</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">return</span> cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayHeight</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">return</span> cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure the lineView.wrapping.heights array is populated. This is
an array of bottom offsets for the lines that make up a drawn
line. When lineWrapping is on, there might be more than one
height.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureLineHeights</span>(<span class="hljs-params">cm, lineView, rect</span>) </span>{
    <span class="hljs-keyword">var</span> wrapping = cm.options.lineWrapping;
    <span class="hljs-keyword">var</span> curWidth = wrapping &amp;&amp; displayWidth(cm);
    <span class="hljs-keyword">if</span> (!lineView.measure.heights || wrapping &amp;&amp; lineView.measure.width != curWidth) {
      <span class="hljs-keyword">var</span> heights = lineView.measure.heights = [];
      <span class="hljs-keyword">if</span> (wrapping) {
        lineView.measure.width = curWidth;
        <span class="hljs-keyword">var</span> rects = lineView.text.firstChild.getClientRects();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; rects.length - <span class="hljs-number">1</span>; i++) {
          <span class="hljs-keyword">var</span> cur = rects[i], next = rects[i + <span class="hljs-number">1</span>];
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(cur.bottom - next.bottom) &gt; <span class="hljs-number">2</span>)
            heights.push((cur.bottom + next.top) / <span class="hljs-number">2</span> - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find a line map (mapping character offsets to text nodes) and a
measurement cache for the given line number. (A line view might
contain multiple lines when collapsed ranges are present.)</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapFromLineView</span>(<span class="hljs-params">lineView, line, lineN</span>) </span>{
    <span class="hljs-keyword">if</span> (lineView.line == line)
      <span class="hljs-keyword">return</span> {map: lineView.measure.map, cache: lineView.measure.cache};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lineView.rest.length; i++)
      <span class="hljs-keyword">if</span> (lineView.rest[i] == line)
        <span class="hljs-keyword">return</span> {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lineView.rest.length; i++)
      <span class="hljs-keyword">if</span> (lineNo(lineView.rest[i]) &gt; lineN)
        <span class="hljs-keyword">return</span> {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: <span class="hljs-literal">true</span>};
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Render a line into the hidden node display.externalMeasured. Used
when measurement is needed for a line that&#39;s not in the viewport.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateExternalMeasurement</span>(<span class="hljs-params">cm, line</span>) </span>{
    line = visualLine(line);
    <span class="hljs-keyword">var</span> lineN = lineNo(line);
    <span class="hljs-keyword">var</span> view = cm.display.externalMeasured = <span class="hljs-keyword">new</span> LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    <span class="hljs-keyword">var</span> built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    <span class="hljs-keyword">return</span> view;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get a {top, bottom, left, right} box (in line-local coordinates)
for a given character.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">measureChar</span>(<span class="hljs-params">cm, line, ch, bias</span>) </span>{
    <span class="hljs-keyword">return</span> measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find a line view that corresponds to the given line number.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findViewForLine</span>(<span class="hljs-params">cm, lineN</span>) </span>{
    <span class="hljs-keyword">if</span> (lineN &gt;= cm.display.viewFrom &amp;&amp; lineN &lt; cm.display.viewTo)
      <span class="hljs-keyword">return</span> cm.display.view[findViewIndex(cm, lineN)];
    <span class="hljs-keyword">var</span> ext = cm.display.externalMeasured;
    <span class="hljs-keyword">if</span> (ext &amp;&amp; lineN &gt;= ext.lineN &amp;&amp; lineN &lt; ext.lineN + ext.size)
      <span class="hljs-keyword">return</span> ext;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Measurement can be split in two steps, the set-up work that
applies to the whole line, and the measurement of the actual
character. Functions like coordsChar, that need to do a lot of
measurements in a row, can thus ensure that the set-up work is
only done once.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepareMeasureForLine</span>(<span class="hljs-params">cm, line</span>) </span>{
    <span class="hljs-keyword">var</span> lineN = lineNo(line);
    <span class="hljs-keyword">var</span> view = findViewForLine(cm, lineN);
    <span class="hljs-keyword">if</span> (view &amp;&amp; !view.text) {
      view = <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (view &amp;&amp; view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">if</span> (!view)
      view = updateExternalMeasurement(cm, line);

    <span class="hljs-keyword">var</span> info = mapFromLineView(view, line, lineN);
    <span class="hljs-keyword">return</span> {
      line: line, view: view, rect: <span class="hljs-literal">null</span>,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: <span class="hljs-literal">false</span>
    };
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a prepared measurement object, measures the position of an
actual character (or fetches it from the cache).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">measureCharPrepared</span>(<span class="hljs-params">cm, prepared, ch, bias, varHeight</span>) </span>{
    <span class="hljs-keyword">if</span> (prepared.before) ch = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> key = ch + (bias || <span class="hljs-string">""</span>), found;
    <span class="hljs-keyword">if</span> (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      <span class="hljs-keyword">if</span> (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = <span class="hljs-literal">true</span>;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      <span class="hljs-keyword">if</span> (!found.bogus) prepared.cache[key] = found;
    }
    <span class="hljs-keyword">return</span> {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom};
  }

  <span class="hljs-keyword">var</span> nullRect = {left: <span class="hljs-number">0</span>, right: <span class="hljs-number">0</span>, top: <span class="hljs-number">0</span>, bottom: <span class="hljs-number">0</span>};

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nodeAndOffsetInLineMap</span>(<span class="hljs-params">map, ch, bias</span>) </span>{
    <span class="hljs-keyword">var</span> node, start, end, collapse;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>First, search the line map for the text node corresponding to,
or closest to, the target character.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; map.length; i += <span class="hljs-number">3</span>) {
      <span class="hljs-keyword">var</span> mStart = map[i], mEnd = map[i + <span class="hljs-number">1</span>];
      <span class="hljs-keyword">if</span> (ch &lt; mStart) {
        start = <span class="hljs-number">0</span>; end = <span class="hljs-number">1</span>;
        collapse = <span class="hljs-string">"left"</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch &lt; mEnd) {
        start = ch - mStart;
        end = start + <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == map.length - <span class="hljs-number">3</span> || ch == mEnd &amp;&amp; map[i + <span class="hljs-number">3</span>] &gt; ch) {
        end = mEnd - mStart;
        start = end - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (ch &gt;= mEnd) collapse = <span class="hljs-string">"right"</span>;
      }
      <span class="hljs-keyword">if</span> (start != <span class="hljs-literal">null</span>) {
        node = map[i + <span class="hljs-number">2</span>];
        <span class="hljs-keyword">if</span> (mStart == mEnd &amp;&amp; bias == (node.insertLeft ? <span class="hljs-string">"left"</span> : <span class="hljs-string">"right"</span>))
          collapse = bias;
        <span class="hljs-keyword">if</span> (bias == <span class="hljs-string">"left"</span> &amp;&amp; start == <span class="hljs-number">0</span>)
          <span class="hljs-keyword">while</span> (i &amp;&amp; map[i - <span class="hljs-number">2</span>] == map[i - <span class="hljs-number">3</span>] &amp;&amp; map[i - <span class="hljs-number">1</span>].insertLeft) {
            node = map[(i -= <span class="hljs-number">3</span>) + <span class="hljs-number">2</span>];
            collapse = <span class="hljs-string">"left"</span>;
          }
        <span class="hljs-keyword">if</span> (bias == <span class="hljs-string">"right"</span> &amp;&amp; start == mEnd - mStart)
          <span class="hljs-keyword">while</span> (i &lt; map.length - <span class="hljs-number">3</span> &amp;&amp; map[i + <span class="hljs-number">3</span>] == map[i + <span class="hljs-number">4</span>] &amp;&amp; !map[i + <span class="hljs-number">5</span>].insertLeft) {
            node = map[(i += <span class="hljs-number">3</span>) + <span class="hljs-number">2</span>];
            collapse = <span class="hljs-string">"right"</span>;
          }
        <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">return</span> {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">measureCharInner</span>(<span class="hljs-params">cm, prepared, ch, bias</span>) </span>{
    <span class="hljs-keyword">var</span> place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    <span class="hljs-keyword">var</span> node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    <span class="hljs-keyword">var</span> rect;
    <span class="hljs-keyword">if</span> (node.nodeType == <span class="hljs-number">3</span>) { <span class="hljs-comment">// If it is a text node, use a range to retrieve the coordinates.</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) { <span class="hljs-comment">// Retry a maximum of 4 times when nonsense rectangles are returned</span>
        <span class="hljs-keyword">while</span> (start &amp;&amp; isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
        <span class="hljs-keyword">while</span> (place.coverStart + end &lt; place.coverEnd &amp;&amp; isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
        <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">9</span> &amp;&amp; start == <span class="hljs-number">0</span> &amp;&amp; end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ie &amp;&amp; cm.options.lineWrapping) {
          <span class="hljs-keyword">var</span> rects = range(node, start, end).getClientRects();
          <span class="hljs-keyword">if</span> (rects.length)
            rect = rects[bias == <span class="hljs-string">"right"</span> ? rects.length - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];
          <span class="hljs-keyword">else</span>
            rect = nullRect;
        } <span class="hljs-keyword">else</span> {
          rect = range(node, start, end).getBoundingClientRect() || nullRect;
        }
        <span class="hljs-keyword">if</span> (rect.left || rect.right || start == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
        end = start;
        start = start - <span class="hljs-number">1</span>;
        collapse = <span class="hljs-string">"right"</span>;
      }
      <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">11</span>) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// If it is a widget, simply get the box for the whole widget.</span>
      <span class="hljs-keyword">if</span> (start &gt; <span class="hljs-number">0</span>) collapse = bias = <span class="hljs-string">"right"</span>;
      <span class="hljs-keyword">var</span> rects;
      <span class="hljs-keyword">if</span> (cm.options.lineWrapping &amp;&amp; (rects = node.getClientRects()).length &gt; <span class="hljs-number">1</span>)
        rect = rects[bias == <span class="hljs-string">"right"</span> ? rects.length - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];
      <span class="hljs-keyword">else</span>
        rect = node.getBoundingClientRect();
    }
    <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">9</span> &amp;&amp; !start &amp;&amp; (!rect || !rect.left &amp;&amp; !rect.right)) {
      <span class="hljs-keyword">var</span> rSpan = node.parentNode.getClientRects()[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">if</span> (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      <span class="hljs-keyword">else</span>
        rect = nullRect;
    }

    <span class="hljs-keyword">var</span> rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    <span class="hljs-keyword">var</span> mid = (rtop + rbot) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> heights = prepared.view.measure.heights;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; heights.length - <span class="hljs-number">1</span>; i++)
      <span class="hljs-keyword">if</span> (mid &lt; heights[i]) <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">var</span> top = i ? heights[i - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>, bot = heights[i];
    <span class="hljs-keyword">var</span> result = {left: (collapse == <span class="hljs-string">"right"</span> ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == <span class="hljs-string">"left"</span> ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    <span class="hljs-keyword">if</span> (!rect.left &amp;&amp; !rect.right) result.bogus = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    <span class="hljs-keyword">return</span> result;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Work around problem with bounding client rects on ranges being
returned incorrectly when zoomed on IE10 and below.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybeUpdateRectForZooming</span>(<span class="hljs-params">measure, rect</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.screen || screen.logicalXDPI == <span class="hljs-literal">null</span> ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      <span class="hljs-keyword">return</span> rect;
    <span class="hljs-keyword">var</span> scaleX = screen.logicalXDPI / screen.deviceXDPI;
    <span class="hljs-keyword">var</span> scaleY = screen.logicalYDPI / screen.deviceYDPI;
    <span class="hljs-keyword">return</span> {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearLineMeasurementCacheFor</span>(<span class="hljs-params">lineView</span>) </span>{
    <span class="hljs-keyword">if</span> (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">if</span> (lineView.rest) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearLineMeasurementCache</span>(<span class="hljs-params">cm</span>) </span>{
    cm.display.externalMeasure = <span class="hljs-literal">null</span>;
    removeChildren(cm.display.lineMeasure);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearCaches</span>(<span class="hljs-params">cm</span>) </span>{
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (!cm.options.lineWrapping) cm.display.maxLineChanged = <span class="hljs-literal">true</span>;
    cm.display.lineNumChars = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pageScrollX</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.pageXOffset || (<span class="hljs-built_in">document</span>.documentElement || <span class="hljs-built_in">document</span>.body).scrollLeft; }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pageScrollY</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.pageYOffset || (<span class="hljs-built_in">document</span>.documentElement || <span class="hljs-built_in">document</span>.body).scrollTop; }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Converts a {top, bottom, left, right} box from line-local
coordinates into another coordinate system. Context may be one of
&quot;line&quot;, &quot;div&quot; (display.lineDiv), &quot;local&quot;/null (editor), &quot;window&quot;,
or &quot;page&quot;.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intoCoordSystem</span>(<span class="hljs-params">cm, lineObj, rect, context</span>) </span>{
    <span class="hljs-keyword">if</span> (lineObj.widgets) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lineObj.widgets.length; ++i) <span class="hljs-keyword">if</span> (lineObj.widgets[i].above) {
      <span class="hljs-keyword">var</span> size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    <span class="hljs-keyword">if</span> (context == <span class="hljs-string">"line"</span>) <span class="hljs-keyword">return</span> rect;
    <span class="hljs-keyword">if</span> (!context) context = <span class="hljs-string">"local"</span>;
    <span class="hljs-keyword">var</span> yOff = heightAtLine(lineObj);
    <span class="hljs-keyword">if</span> (context == <span class="hljs-string">"local"</span>) yOff += paddingTop(cm.display);
    <span class="hljs-keyword">else</span> yOff -= cm.display.viewOffset;
    <span class="hljs-keyword">if</span> (context == <span class="hljs-string">"page"</span> || context == <span class="hljs-string">"window"</span>) {
      <span class="hljs-keyword">var</span> lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == <span class="hljs-string">"window"</span> ? <span class="hljs-number">0</span> : pageScrollY());
      <span class="hljs-keyword">var</span> xOff = lOff.left + (context == <span class="hljs-string">"window"</span> ? <span class="hljs-number">0</span> : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    <span class="hljs-keyword">return</span> rect;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Coverts a box from &quot;div&quot; coords to another coordinate system.
Context may be &quot;window&quot;, &quot;page&quot;, &quot;div&quot;, or &quot;local&quot;/null.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromCoordSystem</span>(<span class="hljs-params">cm, coords, context</span>) </span>{
    <span class="hljs-keyword">if</span> (context == <span class="hljs-string">"div"</span>) <span class="hljs-keyword">return</span> coords;
    <span class="hljs-keyword">var</span> left = coords.left, top = coords.top;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>First move into &quot;page&quot; coordinate system</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (context == <span class="hljs-string">"page"</span>) {
      left -= pageScrollX();
      top -= pageScrollY();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context == <span class="hljs-string">"local"</span> || !context) {
      <span class="hljs-keyword">var</span> localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    <span class="hljs-keyword">var</span> lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    <span class="hljs-keyword">return</span> {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">charCoords</span>(<span class="hljs-params">cm, pos, context, lineObj, bias</span>) </span>{
    <span class="hljs-keyword">if</span> (!lineObj) lineObj = getLine(cm.doc, pos.line);
    <span class="hljs-keyword">return</span> intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns a box for a given cursor position, which may have an
&#39;other&#39; property containing the position of the secondary cursor
on a bidi boundary.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cursorCoords</span>(<span class="hljs-params">cm, pos, context, lineObj, preparedMeasure, varHeight</span>) </span>{
    lineObj = lineObj || getLine(cm.doc, pos.line);
    <span class="hljs-keyword">if</span> (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">ch, right</span>) </span>{
      <span class="hljs-keyword">var</span> m = measureCharPrepared(cm, preparedMeasure, ch, right ? <span class="hljs-string">"right"</span> : <span class="hljs-string">"left"</span>, varHeight);
      <span class="hljs-keyword">if</span> (right) m.left = m.right; <span class="hljs-keyword">else</span> m.right = m.left;
      <span class="hljs-keyword">return</span> intoCoordSystem(cm, lineObj, m, context);
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBidi</span>(<span class="hljs-params">ch, partPos</span>) </span>{
      <span class="hljs-keyword">var</span> part = order[partPos], right = part.level % <span class="hljs-number">2</span>;
      <span class="hljs-keyword">if</span> (ch == bidiLeft(part) &amp;&amp; partPos &amp;&amp; part.level &lt; order[partPos - <span class="hljs-number">1</span>].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % <span class="hljs-number">2</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);
        right = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == bidiRight(part) &amp;&amp; partPos &lt; order.length - <span class="hljs-number">1</span> &amp;&amp; part.level &lt; order[partPos + <span class="hljs-number">1</span>].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % <span class="hljs-number">2</span>;
        right = <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">if</span> (right &amp;&amp; ch == part.to &amp;&amp; ch &gt; part.from) <span class="hljs-keyword">return</span> get(ch - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> get(ch, right);
    }
    <span class="hljs-keyword">var</span> order = getOrder(lineObj), ch = pos.ch;
    <span class="hljs-keyword">if</span> (!order) <span class="hljs-keyword">return</span> get(ch);
    <span class="hljs-keyword">var</span> partPos = getBidiPartAt(order, ch);
    <span class="hljs-keyword">var</span> val = getBidi(ch, partPos);
    <span class="hljs-keyword">if</span> (bidiOther != <span class="hljs-literal">null</span>) val.other = getBidi(ch, bidiOther);
    <span class="hljs-keyword">return</span> val;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to cheaply estimate the coordinates for a position. Used for
intermediate scroll updates.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">estimateCoords</span>(<span class="hljs-params">cm, pos</span>) </span>{
    <span class="hljs-keyword">var</span> left = <span class="hljs-number">0</span>, pos = clipPos(cm.doc, pos);
    <span class="hljs-keyword">if</span> (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    <span class="hljs-keyword">var</span> lineObj = getLine(cm.doc, pos.line);
    <span class="hljs-keyword">var</span> top = heightAtLine(lineObj) + paddingTop(cm.display);
    <span class="hljs-keyword">return</span> {left: left, right: left, top: top, bottom: top + lineObj.height};
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Positions returned by coordsChar contain some extra information.
xRel is the relative x position of the input coordinates compared
to the found position (so xRel &gt; 0 means the coordinates are to
the right of the character position, for example). When outside
is true, that means the coordinates lie outside the line&#39;s
vertical range.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PosWithInfo</span>(<span class="hljs-params">line, ch, outside, xRel</span>) </span>{
    <span class="hljs-keyword">var</span> pos = Pos(line, ch);
    pos.xRel = xRel;
    <span class="hljs-keyword">if</span> (outside) pos.outside = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> pos;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute the character position closest to the given coordinates.
Input must be lineSpace-local (&quot;div&quot; coordinate system).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coordsChar</span>(<span class="hljs-params">cm, x, y</span>) </span>{
    <span class="hljs-keyword">var</span> doc = cm.doc;
    y += cm.display.viewOffset;
    <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> PosWithInfo(doc.first, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, -<span class="hljs-number">1</span>);
    <span class="hljs-keyword">var</span> lineN = lineAtHeight(doc, y), last = doc.first + doc.size - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (lineN &gt; last)
      <span class="hljs-keyword">return</span> PosWithInfo(doc.first + doc.size - <span class="hljs-number">1</span>, getLine(doc, last).text.length, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">var</span> lineObj = getLine(doc, lineN);
    <span class="hljs-keyword">for</span> (;;) {
      <span class="hljs-keyword">var</span> found = coordsCharInner(cm, lineObj, lineN, x, y);
      <span class="hljs-keyword">var</span> merged = collapsedSpanAtEnd(lineObj);
      <span class="hljs-keyword">var</span> mergedPos = merged &amp;&amp; merged.find(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);
      <span class="hljs-keyword">if</span> (merged &amp;&amp; (found.ch &gt; mergedPos.from.ch || found.ch == mergedPos.from.ch &amp;&amp; found.xRel &gt; <span class="hljs-number">0</span>))
        lineN = lineNo(lineObj = mergedPos.to.line);
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> found;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coordsCharInner</span>(<span class="hljs-params">cm, lineObj, lineNo, x, y</span>) </span>{
    <span class="hljs-keyword">var</span> innerOff = y - heightAtLine(lineObj);
    <span class="hljs-keyword">var</span> wrongLine = <span class="hljs-literal">false</span>, adjust = <span class="hljs-number">2</span> * cm.display.wrapper.clientWidth;
    <span class="hljs-keyword">var</span> preparedMeasure = prepareMeasureForLine(cm, lineObj);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getX</span>(<span class="hljs-params">ch</span>) </span>{
      <span class="hljs-keyword">var</span> sp = cursorCoords(cm, Pos(lineNo, ch), <span class="hljs-string">"line"</span>, lineObj, preparedMeasure);
      wrongLine = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (innerOff &gt; sp.bottom) <span class="hljs-keyword">return</span> sp.left - adjust;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (innerOff &lt; sp.top) <span class="hljs-keyword">return</span> sp.left + adjust;
      <span class="hljs-keyword">else</span> wrongLine = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">return</span> sp.left;
    }

    <span class="hljs-keyword">var</span> bidi = getOrder(lineObj), dist = lineObj.text.length;
    <span class="hljs-keyword">var</span> from = lineLeft(lineObj), to = lineRight(lineObj);
    <span class="hljs-keyword">var</span> fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    <span class="hljs-keyword">if</span> (x &gt; toX) <span class="hljs-keyword">return</span> PosWithInfo(lineNo, to, toOutside, <span class="hljs-number">1</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Do a binary search between these bounds.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (;;) {
      <span class="hljs-keyword">if</span> (bidi ? to == from || to == moveVisually(lineObj, from, <span class="hljs-number">1</span>) : to - from &lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">var</span> ch = x &lt; fromX || x - fromX &lt;= toX - x ? from : to;
        <span class="hljs-keyword">var</span> xDiff = x - (ch == from ? fromX : toX);
        <span class="hljs-keyword">while</span> (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        <span class="hljs-keyword">var</span> pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff &lt; -<span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : xDiff &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> pos;
      }
      <span class="hljs-keyword">var</span> step = <span class="hljs-built_in">Math</span>.ceil(dist / <span class="hljs-number">2</span>), middle = from + step;
      <span class="hljs-keyword">if</span> (bidi) {
        middle = from;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; step; ++i) middle = moveVisually(lineObj, middle, <span class="hljs-number">1</span>);
      }
      <span class="hljs-keyword">var</span> middleX = getX(middle);
      <span class="hljs-keyword">if</span> (middleX &gt; x) {to = middle; toX = middleX; <span class="hljs-keyword">if</span> (toOutside = wrongLine) toX += <span class="hljs-number">1000</span>; dist = step;}
      <span class="hljs-keyword">else</span> {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  <span class="hljs-keyword">var</span> measureText;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute the default text height.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">textHeight</span>(<span class="hljs-params">display</span>) </span>{
    <span class="hljs-keyword">if</span> (display.cachedTextHeight != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> display.cachedTextHeight;
    <span class="hljs-keyword">if</span> (measureText == <span class="hljs-literal">null</span>) {
      measureText = elt(<span class="hljs-string">"pre"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Measure a bunch of lines, for browsers that compute
fractional heights.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">49</span>; ++i) {
        measureText.appendChild(<span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">"x"</span>));
        measureText.appendChild(elt(<span class="hljs-string">"br"</span>));
      }
      measureText.appendChild(<span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">"x"</span>));
    }
    removeChildrenAndAdd(display.measure, measureText);
    <span class="hljs-keyword">var</span> height = measureText.offsetHeight / <span class="hljs-number">50</span>;
    <span class="hljs-keyword">if</span> (height &gt; <span class="hljs-number">3</span>) display.cachedTextHeight = height;
    removeChildren(display.measure);
    <span class="hljs-keyword">return</span> height || <span class="hljs-number">1</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute the default character width.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">charWidth</span>(<span class="hljs-params">display</span>) </span>{
    <span class="hljs-keyword">if</span> (display.cachedCharWidth != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> display.cachedCharWidth;
    <span class="hljs-keyword">var</span> anchor = elt(<span class="hljs-string">"span"</span>, <span class="hljs-string">"xxxxxxxxxx"</span>);
    <span class="hljs-keyword">var</span> pre = elt(<span class="hljs-string">"pre"</span>, [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    <span class="hljs-keyword">var</span> rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / <span class="hljs-number">10</span>;
    <span class="hljs-keyword">if</span> (width &gt; <span class="hljs-number">2</span>) display.cachedCharWidth = width;
    <span class="hljs-keyword">return</span> width || <span class="hljs-number">10</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>OPERATIONS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Operations are used to wrap a series of changes to the editor
state in such a way that each change won&#39;t have to update the
cursor and display (which would be awkward, slow, and
error-prone). Instead, display updates are batched and then all
combined and executed at once.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> operationGroup = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">var</span> nextOpId = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Start a new operation.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startOperation</span>(<span class="hljs-params">cm</span>) </span>{
    cm.curOp = {
      cm: cm,
      viewChanged: <span class="hljs-literal">false</span>,      <span class="hljs-comment">// Flag that indicates that lines might need to be redrawn</span>
      startHeight: cm.doc.height, <span class="hljs-comment">// Used to detect need to update scrollbar</span>
      forceUpdate: <span class="hljs-literal">false</span>,      <span class="hljs-comment">// Used to force a redraw</span>
      updateInput: <span class="hljs-literal">null</span>,       <span class="hljs-comment">// Whether to reset the input textarea</span>
      typing: <span class="hljs-literal">false</span>,           <span class="hljs-comment">// Whether this reset should be careful to leave existing text (for compositing)</span>
      changeObjs: <span class="hljs-literal">null</span>,        <span class="hljs-comment">// Accumulated changes, for firing change events</span>
      cursorActivityHandlers: <span class="hljs-literal">null</span>, <span class="hljs-comment">// Set of handlers to fire cursorActivity on</span>
      cursorActivityCalled: <span class="hljs-number">0</span>, <span class="hljs-comment">// Tracks which cursorActivity handlers have been called already</span>
      selectionChanged: <span class="hljs-literal">false</span>, <span class="hljs-comment">// Whether the selection needs to be redrawn</span>
      updateMaxLine: <span class="hljs-literal">false</span>,    <span class="hljs-comment">// Set when the widest line needs to be determined anew</span>
      scrollLeft: <span class="hljs-literal">null</span>, scrollTop: <span class="hljs-literal">null</span>, <span class="hljs-comment">// Intermediate scroll position, not pushed to DOM yet</span>
      scrollToPos: <span class="hljs-literal">null</span>,       <span class="hljs-comment">// Used to scroll to a specific position</span>
      focus: <span class="hljs-literal">false</span>,
      id: ++nextOpId           <span class="hljs-comment">// Unique ID</span>
    };
    <span class="hljs-keyword">if</span> (operationGroup) {
      operationGroup.ops.push(cm.curOp);
    } <span class="hljs-keyword">else</span> {
      cm.curOp.ownsGroup = operationGroup = {
        ops: [cm.curOp],
        delayedCallbacks: []
      };
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fireCallbacksForOps</span>(<span class="hljs-params">group</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calls delayed callbacks and cursorActivity handlers until no
new ones appear</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> callbacks = group.delayedCallbacks, i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">for</span> (; i &lt; callbacks.length; i++)
        callbacks[i].call(<span class="hljs-literal">null</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; group.ops.length; j++) {
        <span class="hljs-keyword">var</span> op = group.ops[j];
        <span class="hljs-keyword">if</span> (op.cursorActivityHandlers)
          <span class="hljs-keyword">while</span> (op.cursorActivityCalled &lt; op.cursorActivityHandlers.length)
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(<span class="hljs-literal">null</span>, op.cm);
      }
    } <span class="hljs-keyword">while</span> (i &lt; callbacks.length);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finish an operation, updating the display and signalling delayed events</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endOperation</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> op = cm.curOp, group = op.ownsGroup;
    <span class="hljs-keyword">if</span> (!group) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">try</span> { fireCallbacksForOps(group); }
    <span class="hljs-keyword">finally</span> {
      operationGroup = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; group.ops.length; i++)
        group.ops[i].cm.curOp = <span class="hljs-literal">null</span>;
      endOperations(group);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The DOM updates done when an operation finishes are batched so
that the minimum number of relayouts are required.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endOperations</span>(<span class="hljs-params">group</span>) </span>{
    <span class="hljs-keyword">var</span> ops = group.ops;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ops.length; i++) <span class="hljs-comment">// Read DOM</span>
      endOperation_R1(ops[i]);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ops.length; i++) <span class="hljs-comment">// Write DOM (maybe)</span>
      endOperation_W1(ops[i]);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ops.length; i++) <span class="hljs-comment">// Read DOM</span>
      endOperation_R2(ops[i]);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ops.length; i++) <span class="hljs-comment">// Write DOM (maybe)</span>
      endOperation_W2(ops[i]);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ops.length; i++) <span class="hljs-comment">// Read DOM</span>
      endOperation_finish(ops[i]);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endOperation_R1</span>(<span class="hljs-params">op</span>) </span>{
    <span class="hljs-keyword">var</span> cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    <span class="hljs-keyword">if</span> (op.updateMaxLine) findMaxLine(cm);

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != <span class="hljs-literal">null</span> ||
      op.scrollToPos &amp;&amp; (op.scrollToPos.from.line &lt; display.viewFrom ||
                         op.scrollToPos.to.line &gt;= display.viewTo) ||
      display.maxLineChanged &amp;&amp; cm.options.lineWrapping;
    op.update = op.mustUpdate &amp;&amp;
      <span class="hljs-keyword">new</span> DisplayUpdate(cm, op.mustUpdate &amp;&amp; {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endOperation_W1</span>(<span class="hljs-params">op</span>) </span>{
    op.updatedDisplay = op.mustUpdate &amp;&amp; updateDisplayIfNeeded(op.cm, op.update);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endOperation_R2</span>(<span class="hljs-params">op</span>) </span>{
    <span class="hljs-keyword">var</span> cm = op.cm, display = cm.display;
    <span class="hljs-keyword">if</span> (op.updatedDisplay) updateHeightsInViewport(cm);

    op.barMeasure = measureForScrollbars(cm);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the max line changed since it was last measured, measure it,
and ensure the document&#39;s width matches it.
updateDisplay_W2 will use these properties to do the actual resizing</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (display.maxLineChanged &amp;&amp; !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + <span class="hljs-number">3</span>;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        <span class="hljs-built_in">Math</span>.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    <span class="hljs-keyword">if</span> (op.updatedDisplay || op.selectionChanged)
      op.preparedSelection = display.input.prepareSelection();
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endOperation_W2</span>(<span class="hljs-params">op</span>) </span>{
    <span class="hljs-keyword">var</span> cm = op.cm;

    <span class="hljs-keyword">if</span> (op.adjustWidthTo != <span class="hljs-literal">null</span>) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + <span class="hljs-string">"px"</span>;
      <span class="hljs-keyword">if</span> (op.maxScrollLeft &lt; cm.doc.scrollLeft)
        setScrollLeft(cm, <span class="hljs-built_in">Math</span>.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), <span class="hljs-literal">true</span>);
      cm.display.maxLineChanged = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (op.preparedSelection)
      cm.display.input.showSelection(op.preparedSelection);
    <span class="hljs-keyword">if</span> (op.updatedDisplay || op.startHeight != cm.doc.height)
      updateScrollbars(cm, op.barMeasure);
    <span class="hljs-keyword">if</span> (op.updatedDisplay)
      setDocumentHeight(cm, op.barMeasure);

    <span class="hljs-keyword">if</span> (op.selectionChanged) restartBlink(cm);

    <span class="hljs-keyword">if</span> (cm.state.focused &amp;&amp; op.updateInput)
      cm.display.input.reset(op.typing);
    <span class="hljs-keyword">if</span> (op.focus &amp;&amp; op.focus == activeElt() &amp;&amp; (!<span class="hljs-built_in">document</span>.hasFocus || <span class="hljs-built_in">document</span>.hasFocus()))
      ensureFocus(op.cm);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endOperation_finish</span>(<span class="hljs-params">op</span>) </span>{
    <span class="hljs-keyword">var</span> cm = op.cm, display = cm.display, doc = cm.doc;

    <span class="hljs-keyword">if</span> (op.updatedDisplay) postUpdateDisplay(cm, op.update);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Abort mouse wheel delta measurement, when scrolling explicitly</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (display.wheelStartX != <span class="hljs-literal">null</span> &amp;&amp; (op.scrollTop != <span class="hljs-literal">null</span> || op.scrollLeft != <span class="hljs-literal">null</span> || op.scrollToPos))
      display.wheelStartX = display.wheelStartY = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Propagate the scroll position to the actual DOM scroller</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (op.scrollTop != <span class="hljs-literal">null</span> &amp;&amp; (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
      doc.scrollTop = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scrollbars.setScrollTop(doc.scrollTop);
      display.scroller.scrollTop = doc.scrollTop;
    }
    <span class="hljs-keyword">if</span> (op.scrollLeft != <span class="hljs-literal">null</span> &amp;&amp; (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
      doc.scrollLeft = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
      display.scrollbars.setScrollLeft(doc.scrollLeft);
      display.scroller.scrollLeft = doc.scrollLeft;
      alignHorizontally(cm);
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we need to scroll a specific position into view, do so.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (op.scrollToPos) {
      <span class="hljs-keyword">var</span> coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      <span class="hljs-keyword">if</span> (op.scrollToPos.isCursor &amp;&amp; cm.state.focused) maybeScrollWindow(cm, coords);
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fire events for markers that are hidden/unidden by editing or
undoing</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    <span class="hljs-keyword">if</span> (hidden) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; hidden.length; ++i)
      <span class="hljs-keyword">if</span> (!hidden[i].lines.length) signal(hidden[i], <span class="hljs-string">"hide"</span>);
    <span class="hljs-keyword">if</span> (unhidden) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; unhidden.length; ++i)
      <span class="hljs-keyword">if</span> (unhidden[i].lines.length) signal(unhidden[i], <span class="hljs-string">"unhide"</span>);

    <span class="hljs-keyword">if</span> (display.wrapper.offsetHeight)
      doc.scrollTop = cm.display.scroller.scrollTop;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fire change events, and delayed event handlers</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (op.changeObjs)
      signal(cm, <span class="hljs-string">"changes"</span>, cm, op.changeObjs);
    <span class="hljs-keyword">if</span> (op.update)
      op.update.finish();
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Run the given function in an operation</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runInOp</span>(<span class="hljs-params">cm, f</span>) </span>{
    <span class="hljs-keyword">if</span> (cm.curOp) <span class="hljs-keyword">return</span> f();
    startOperation(cm);
    <span class="hljs-keyword">try</span> { <span class="hljs-keyword">return</span> f(); }
    <span class="hljs-keyword">finally</span> { endOperation(cm); }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Wraps a function in an operation. Returns the wrapped function.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">operation</span>(<span class="hljs-params">cm, f</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (cm.curOp) <span class="hljs-keyword">return</span> f.apply(cm, <span class="hljs-built_in">arguments</span>);
      startOperation(cm);
      <span class="hljs-keyword">try</span> { <span class="hljs-keyword">return</span> f.apply(cm, <span class="hljs-built_in">arguments</span>); }
      <span class="hljs-keyword">finally</span> { endOperation(cm); }
    };
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to add methods to editor and doc instances, wrapping them in
operations.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">methodOp</span>(<span class="hljs-params">f</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curOp) <span class="hljs-keyword">return</span> f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      startOperation(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">try</span> { <span class="hljs-keyword">return</span> f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>); }
      <span class="hljs-keyword">finally</span> { endOperation(<span class="hljs-keyword">this</span>); }
    };
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">docMethodOp</span>(<span class="hljs-params">f</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>.cm;
      <span class="hljs-keyword">if</span> (!cm || cm.curOp) <span class="hljs-keyword">return</span> f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      startOperation(cm);
      <span class="hljs-keyword">try</span> { <span class="hljs-keyword">return</span> f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>); }
      <span class="hljs-keyword">finally</span> { endOperation(cm); }
    };
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>VIEW TRACKING</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>These objects are used to represent the visible (currently drawn)
part of the document. A LineView may correspond to multiple
logical lines, if those are connected by collapsed ranges.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LineView</span>(<span class="hljs-params">doc, line, lineN</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The starting line</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.line = line;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Continuing lines, if any</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.rest = visualLineContinued(line);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Number of logical lines in this visual line</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">this</span>.rest ? lineNo(lst(<span class="hljs-keyword">this</span>.rest)) - lineN + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
    <span class="hljs-keyword">this</span>.node = <span class="hljs-keyword">this</span>.text = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.hidden = lineIsHidden(doc, line);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a range of LineView objects for the given lines.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildViewArray</span>(<span class="hljs-params">cm, from, to</span>) </span>{
    <span class="hljs-keyword">var</span> array = [], nextPos;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> pos = from; pos &lt; to; pos = nextPos) {
      <span class="hljs-keyword">var</span> view = <span class="hljs-keyword">new</span> LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    <span class="hljs-keyword">return</span> array;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Updates the display.view data structure for a given change to the
document. From and to are in pre-change coordinates. Lendiff is
the amount of lines added or subtracted by the change. This is
used for changes that span multiple lines, or change the way
lines are divided into visual lines. regLineChange (below)
registers single-line changes.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">regChange</span>(<span class="hljs-params">cm, from, to, lendiff</span>) </span>{
    <span class="hljs-keyword">if</span> (from == <span class="hljs-literal">null</span>) from = cm.doc.first;
    <span class="hljs-keyword">if</span> (to == <span class="hljs-literal">null</span>) to = cm.doc.first + cm.doc.size;
    <span class="hljs-keyword">if</span> (!lendiff) lendiff = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">var</span> display = cm.display;
    <span class="hljs-keyword">if</span> (lendiff &amp;&amp; to &lt; display.viewTo &amp;&amp;
        (display.updateLineNumbers == <span class="hljs-literal">null</span> || display.updateLineNumbers &gt; from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">if</span> (from &gt;= display.viewTo) { <span class="hljs-comment">// Change after</span>
      <span class="hljs-keyword">if</span> (sawCollapsedSpans &amp;&amp; visualLineNo(cm.doc, from) &lt; display.viewTo)
        resetView(cm);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (to &lt;= display.viewFrom) { <span class="hljs-comment">// Change before</span>
      <span class="hljs-keyword">if</span> (sawCollapsedSpans &amp;&amp; visualLineEndNo(cm.doc, to + lendiff) &gt; display.viewFrom) {
        resetView(cm);
      } <span class="hljs-keyword">else</span> {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (from &lt;= display.viewFrom &amp;&amp; to &gt;= display.viewTo) { <span class="hljs-comment">// Full overlap</span>
      resetView(cm);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (from &lt;= display.viewFrom) { <span class="hljs-comment">// Top overlap</span>
      <span class="hljs-keyword">var</span> cut = viewCuttingPoint(cm, to, to + lendiff, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } <span class="hljs-keyword">else</span> {
        resetView(cm);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (to &gt;= display.viewTo) { <span class="hljs-comment">// Bottom overlap</span>
      <span class="hljs-keyword">var</span> cut = viewCuttingPoint(cm, from, from, -<span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (cut) {
        display.view = display.view.slice(<span class="hljs-number">0</span>, cut.index);
        display.viewTo = cut.lineN;
      } <span class="hljs-keyword">else</span> {
        resetView(cm);
      }
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// Gap in the middle</span>
      <span class="hljs-keyword">var</span> cutTop = viewCuttingPoint(cm, from, from, -<span class="hljs-number">1</span>);
      <span class="hljs-keyword">var</span> cutBot = viewCuttingPoint(cm, to, to + lendiff, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (cutTop &amp;&amp; cutBot) {
        display.view = display.view.slice(<span class="hljs-number">0</span>, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } <span class="hljs-keyword">else</span> {
        resetView(cm);
      }
    }

    <span class="hljs-keyword">var</span> ext = display.externalMeasured;
    <span class="hljs-keyword">if</span> (ext) {
      <span class="hljs-keyword">if</span> (to &lt; ext.lineN)
        ext.lineN += lendiff;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (from &lt; ext.lineN + ext.size)
        display.externalMeasured = <span class="hljs-literal">null</span>;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Register a change to a single line. Type must be one of &quot;text&quot;,
&quot;gutter&quot;, &quot;class&quot;, &quot;widget&quot;</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">regLineChange</span>(<span class="hljs-params">cm, line, type</span>) </span>{
    cm.curOp.viewChanged = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> display = cm.display, ext = cm.display.externalMeasured;
    <span class="hljs-keyword">if</span> (ext &amp;&amp; line &gt;= ext.lineN &amp;&amp; line &lt; ext.lineN + ext.size)
      display.externalMeasured = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (line &lt; display.viewFrom || line &gt;= display.viewTo) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> lineView = display.view[findViewIndex(cm, line)];
    <span class="hljs-keyword">if</span> (lineView.node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> arr = lineView.changes || (lineView.changes = []);
    <span class="hljs-keyword">if</span> (indexOf(arr, type) == -<span class="hljs-number">1</span>) arr.push(type);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Clear the view.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetView</span>(<span class="hljs-params">cm</span>) </span>{
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = <span class="hljs-number">0</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the view element corresponding to a given line. Return null
when the line isn&#39;t visible.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findViewIndex</span>(<span class="hljs-params">cm, n</span>) </span>{
    <span class="hljs-keyword">if</span> (n &gt;= cm.display.viewTo) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    n -= cm.display.viewFrom;
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> view = cm.display.view;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; view.length; i++) {
      n -= view[i].size;
      <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">viewCuttingPoint</span>(<span class="hljs-params">cm, oldN, newN, dir</span>) </span>{
    <span class="hljs-keyword">var</span> index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    <span class="hljs-keyword">if</span> (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      <span class="hljs-keyword">return</span> {index: index, lineN: newN};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, n = cm.display.viewFrom; i &lt; index; i++)
      n += view[i].size;
    <span class="hljs-keyword">if</span> (n != oldN) {
      <span class="hljs-keyword">if</span> (dir &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (index == view.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        diff = (n + view[index].size) - oldN;
        index++;
      } <span class="hljs-keyword">else</span> {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    <span class="hljs-keyword">while</span> (visualLineNo(cm.doc, newN) != newN) {
      <span class="hljs-keyword">if</span> (index == (dir &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : view.length - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      newN += dir * view[index - (dir &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)].size;
      index += dir;
    }
    <span class="hljs-keyword">return</span> {index: index, lineN: newN};
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Force the view to cover a given range, adding empty view element
or clipping off existing ones as needed.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adjustView</span>(<span class="hljs-params">cm, from, to</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display, view = display.view;
    <span class="hljs-keyword">if</span> (view.length == <span class="hljs-number">0</span> || from &gt;= display.viewTo || to &lt;= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (display.viewFrom &gt; from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (display.viewFrom &lt; from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      <span class="hljs-keyword">if</span> (display.viewTo &lt; to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (display.viewTo &gt; to)
        display.view = display.view.slice(<span class="hljs-number">0</span>, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Count the number of lines in the view whose DOM representation is
out of date (or nonexistent).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDirtyView</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> view = cm.display.view, dirty = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; view.length; i++) {
      <span class="hljs-keyword">var</span> lineView = view[i];
      <span class="hljs-keyword">if</span> (!lineView.hidden &amp;&amp; (!lineView.node || lineView.changes)) ++dirty;
    }
    <span class="hljs-keyword">return</span> dirty;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>EVENT HANDLERS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attach the necessary event handlers when initializing the editor</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerEventHandlers</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> d = cm.display;
    on(d.scroller, <span class="hljs-string">"mousedown"</span>, operation(cm, onMouseDown));</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Older IE&#39;s will not fire a second mousedown for a double click</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">11</span>)
      on(d.scroller, <span class="hljs-string">"dblclick"</span>, operation(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-keyword">if</span> (signalDOMEvent(cm, e)) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">var</span> pos = posFromMouse(cm, e);
        <span class="hljs-keyword">if</span> (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) <span class="hljs-keyword">return</span>;
        e_preventDefault(e);
        <span class="hljs-keyword">var</span> word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    <span class="hljs-keyword">else</span>
      on(d.scroller, <span class="hljs-string">"dblclick"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{ signalDOMEvent(cm, e) || e_preventDefault(e); });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Some browsers fire contextmenu <em>after</em> opening the menu, at
which point we can&#39;t mess with it anymore. Context menu is
handled in onMouseDown for these browsers.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (!captureRightClick) on(d.scroller, <span class="hljs-string">"contextmenu"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{onContextMenu(cm, e);});</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to suppress mouse event handling when a touch happens</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> touchFinished, prevTouch = {end: <span class="hljs-number">0</span>};
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finishTouch</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (d.activeTouch) {
        touchFinished = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{d.activeTouch = <span class="hljs-literal">null</span>;}, <span class="hljs-number">1000</span>);
        prevTouch = d.activeTouch;
        prevTouch.end = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;
      }
    };
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isMouseLikeTouchEvent</span>(<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">if</span> (e.touches.length != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> touch = e.touches[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">return</span> touch.radiusX &lt;= <span class="hljs-number">1</span> &amp;&amp; touch.radiusY &lt;= <span class="hljs-number">1</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">farAway</span>(<span class="hljs-params">touch, other</span>) </span>{
      <span class="hljs-keyword">if</span> (other.left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">var</span> dx = other.left - touch.left, dy = other.top - touch.top;
      <span class="hljs-keyword">return</span> dx * dx + dy * dy &gt; <span class="hljs-number">20</span> * <span class="hljs-number">20</span>;
    }
    on(d.scroller, <span class="hljs-string">"touchstart"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">if</span> (!signalDOMEvent(cm, e) &amp;&amp; !isMouseLikeTouchEvent(e)) {
        clearTimeout(touchFinished);
        <span class="hljs-keyword">var</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;
        d.activeTouch = {start: now, moved: <span class="hljs-literal">false</span>,
                         prev: now - prevTouch.end &lt;= <span class="hljs-number">300</span> ? prevTouch : <span class="hljs-literal">null</span>};
        <span class="hljs-keyword">if</span> (e.touches.length == <span class="hljs-number">1</span>) {
          d.activeTouch.left = e.touches[<span class="hljs-number">0</span>].pageX;
          d.activeTouch.top = e.touches[<span class="hljs-number">0</span>].pageY;
        }
      }
    });
    on(d.scroller, <span class="hljs-string">"touchmove"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (d.activeTouch) d.activeTouch.moved = <span class="hljs-literal">true</span>;
    });
    on(d.scroller, <span class="hljs-string">"touchend"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">var</span> touch = d.activeTouch;
      <span class="hljs-keyword">if</span> (touch &amp;&amp; !eventInWidget(d, e) &amp;&amp; touch.left != <span class="hljs-literal">null</span> &amp;&amp;
          !touch.moved &amp;&amp; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - touch.start &lt; <span class="hljs-number">300</span>) {
        <span class="hljs-keyword">var</span> pos = cm.coordsChar(d.activeTouch, <span class="hljs-string">"page"</span>), range;
        <span class="hljs-keyword">if</span> (!touch.prev || farAway(touch, touch.prev)) <span class="hljs-comment">// Single tap</span>
          range = <span class="hljs-keyword">new</span> Range(pos, pos);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!touch.prev.prev || farAway(touch, touch.prev.prev)) <span class="hljs-comment">// Double tap</span>
          range = cm.findWordAt(pos);
        <span class="hljs-keyword">else</span> <span class="hljs-comment">// Triple tap</span>
          range = <span class="hljs-keyword">new</span> Range(Pos(pos.line, <span class="hljs-number">0</span>), clipPos(cm.doc, Pos(pos.line + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, <span class="hljs-string">"touchcancel"</span>, finishTouch);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sync scrolling between fake scrollbars and real scrollable
area, ensure viewport is updated when scrolling.</p></div></div><div class="code"><div class="wrapper">    on(d.scroller, <span class="hljs-string">"scroll"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, <span class="hljs-literal">true</span>);
        signal(cm, <span class="hljs-string">"scroll"</span>, cm);
      }
    });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Listen to wheel events in order to try and update the viewport on time.</p></div></div><div class="code"><div class="wrapper">    on(d.scroller, <span class="hljs-string">"mousewheel"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{onScrollWheel(cm, e);});
    on(d.scroller, <span class="hljs-string">"DOMMouseScroll"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{onScrollWheel(cm, e);});</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prevent wrapper from ever scrolling</p></div></div><div class="code"><div class="wrapper">    on(d.wrapper, <span class="hljs-string">"scroll"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ d.wrapper.scrollTop = d.wrapper.scrollLeft = <span class="hljs-number">0</span>; });

    d.dragFunctions = {
      enter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{<span class="hljs-keyword">if</span> (!signalDOMEvent(cm, e)) e_stop(e);},
      over: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{<span class="hljs-keyword">if</span> (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{onDragStart(cm, e);},
      drop: operation(cm, onDrop),
      leave: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{<span class="hljs-keyword">if</span> (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    <span class="hljs-keyword">var</span> inp = d.input.getField();
    on(inp, <span class="hljs-string">"keyup"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{ onKeyUp.call(cm, e); });
    on(inp, <span class="hljs-string">"keydown"</span>, operation(cm, onKeyDown));
    on(inp, <span class="hljs-string">"keypress"</span>, operation(cm, onKeyPress));
    on(inp, <span class="hljs-string">"focus"</span>, bind(onFocus, cm));
    on(inp, <span class="hljs-string">"blur"</span>, bind(onBlur, cm));
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dragDropChanged</span>(<span class="hljs-params">cm, value, old</span>) </span>{
    <span class="hljs-keyword">var</span> wasOn = old &amp;&amp; old != CodeMirror.Init;
    <span class="hljs-keyword">if</span> (!value != !wasOn) {
      <span class="hljs-keyword">var</span> funcs = cm.display.dragFunctions;
      <span class="hljs-keyword">var</span> toggle = value ? on : off;
      toggle(cm.display.scroller, <span class="hljs-string">"dragstart"</span>, funcs.start);
      toggle(cm.display.scroller, <span class="hljs-string">"dragenter"</span>, funcs.enter);
      toggle(cm.display.scroller, <span class="hljs-string">"dragover"</span>, funcs.over);
      toggle(cm.display.scroller, <span class="hljs-string">"dragleave"</span>, funcs.leave);
      toggle(cm.display.scroller, <span class="hljs-string">"drop"</span>, funcs.drop);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Called when the window resizes</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onResize</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> d = cm.display;
    <span class="hljs-keyword">if</span> (d.lastWrapHeight == d.wrapper.clientHeight &amp;&amp; d.lastWrapWidth == d.wrapper.clientWidth)
      <span class="hljs-keyword">return</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Might be a text scaling operation, clear size caches.</p></div></div><div class="code"><div class="wrapper">    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = <span class="hljs-literal">null</span>;
    d.scrollbarsClipped = <span class="hljs-literal">false</span>;
    cm.setSize();
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>MOUSE EVENTS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return true when the given mouse event happened in a widget</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventInWidget</span>(<span class="hljs-params">display, e</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = e_target(e); n != display.wrapper; n = n.parentNode) {
      <span class="hljs-keyword">if</span> (!n || (n.nodeType == <span class="hljs-number">1</span> &amp;&amp; n.getAttribute(<span class="hljs-string">"cm-ignore-events"</span>) == <span class="hljs-string">"true"</span>) ||
          (n.parentNode == display.sizer &amp;&amp; n != display.mover))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a mouse event, find the corresponding position. If liberal
is false, it checks whether a gutter or scrollbar was clicked,
and returns null if it was. forRect is used by rectangular
selections, and tries to estimate a character position even for
coordinates beyond the right of the text.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">posFromMouse</span>(<span class="hljs-params">cm, e, liberal, forRect</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display;
    <span class="hljs-keyword">if</span> (!liberal &amp;&amp; e_target(e).getAttribute(<span class="hljs-string">"cm-not-content"</span>) == <span class="hljs-string">"true"</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">var</span> x, y, space = display.lineSpace.getBoundingClientRect();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fails unpredictably on IE[67] when mouse is dragged around quickly.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">try</span> { x = e.clientX - space.left; y = e.clientY - space.top; }
    <span class="hljs-keyword">catch</span> (e) { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; }
    <span class="hljs-keyword">var</span> coords = coordsChar(cm, x, y), line;
    <span class="hljs-keyword">if</span> (forRect &amp;&amp; coords.xRel == <span class="hljs-number">1</span> &amp;&amp; (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      <span class="hljs-keyword">var</span> colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    <span class="hljs-keyword">return</span> coords;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A mouse down can be a single click, double click, triple click,
start of selection drag, start of text drag, new cursor
(ctrl-click), rectangle drag (alt-drag), or xwin
middle-click-paste. Or it might be a click on something we should
not interfere with, such as a scrollbar or widget.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onMouseDown</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>, display = cm.display;
    <span class="hljs-keyword">if</span> (signalDOMEvent(cm, e) || display.activeTouch &amp;&amp; display.input.supportsTouch()) <span class="hljs-keyword">return</span>;
    display.shift = e.shiftKey;

    <span class="hljs-keyword">if</span> (eventInWidget(display, e)) {
      <span class="hljs-keyword">if</span> (!webkit) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Briefly turn off draggability, to allow widgets to do
normal dragging things.</p></div></div><div class="code"><div class="wrapper">        display.scroller.draggable = <span class="hljs-literal">false</span>;
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{display.scroller.draggable = <span class="hljs-literal">true</span>;}, <span class="hljs-number">100</span>);
      }
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (clickInGutter(cm, e)) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> start = posFromMouse(cm, e);
    <span class="hljs-built_in">window</span>.focus();

    <span class="hljs-keyword">switch</span> (e_button(e)) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h1 id="3261-make-sure-that-we39re-not-starting-a-second-selection">3261: make sure, that we&#39;re not starting a second selection</h1></div></div></div><div class="segment"><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (cm.state.selectingText)
        cm.state.selectingText(e);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start)
        leftButtonDown(cm, e, start);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e_target(e) == display.scroller)
        e_preventDefault(e);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
      <span class="hljs-keyword">if</span> (webkit) cm.state.lastMiddleDown = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;
      <span class="hljs-keyword">if</span> (start) extendSelection(cm.doc, start);
      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{display.input.focus();}, <span class="hljs-number">20</span>);
      e_preventDefault(e);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
      <span class="hljs-keyword">if</span> (captureRightClick) onContextMenu(cm, e);
      <span class="hljs-keyword">else</span> delayBlurEvent(cm);
      <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">var</span> lastClick, lastDoubleClick;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leftButtonDown</span>(<span class="hljs-params">cm, e, start</span>) </span>{
    <span class="hljs-keyword">if</span> (ie) setTimeout(bind(ensureFocus, cm), <span class="hljs-number">0</span>);
    <span class="hljs-keyword">else</span> cm.curOp.focus = activeElt();

    <span class="hljs-keyword">var</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>, type;
    <span class="hljs-keyword">if</span> (lastDoubleClick &amp;&amp; lastDoubleClick.time &gt; now - <span class="hljs-number">400</span> &amp;&amp; cmp(lastDoubleClick.pos, start) == <span class="hljs-number">0</span>) {
      type = <span class="hljs-string">"triple"</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastClick &amp;&amp; lastClick.time &gt; now - <span class="hljs-number">400</span> &amp;&amp; cmp(lastClick.pos, start) == <span class="hljs-number">0</span>) {
      type = <span class="hljs-string">"double"</span>;
      lastDoubleClick = {time: now, pos: start};
    } <span class="hljs-keyword">else</span> {
      type = <span class="hljs-string">"single"</span>;
      lastClick = {time: now, pos: start};
    }

    <span class="hljs-keyword">var</span> sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
    <span class="hljs-keyword">if</span> (cm.options.dragDrop &amp;&amp; dragAndDrop &amp;&amp; !cm.isReadOnly() &amp;&amp;
        type == <span class="hljs-string">"single"</span> &amp;&amp; (contained = sel.contains(start)) &gt; -<span class="hljs-number">1</span> &amp;&amp;
        (cmp((contained = sel.ranges[contained]).from(), start) &lt; <span class="hljs-number">0</span> || start.xRel &gt; <span class="hljs-number">0</span>) &amp;&amp;
        (cmp(contained.to(), start) &gt; <span class="hljs-number">0</span> || start.xRel &lt; <span class="hljs-number">0</span>))
      leftButtonStartDrag(cm, e, start, modifier);
    <span class="hljs-keyword">else</span>
      leftButtonSelect(cm, e, start, type, modifier);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Start a text drag. When it ends, see if any dragging actually
happen, and treat as a click if it didn&#39;t.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leftButtonStartDrag</span>(<span class="hljs-params">cm, e, start, modifier</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display, startTime = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;
    <span class="hljs-keyword">var</span> dragEnd = operation(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e2</span>) </span>{
      <span class="hljs-keyword">if</span> (webkit) display.scroller.draggable = <span class="hljs-literal">false</span>;
      cm.state.draggingText = <span class="hljs-literal">false</span>;
      off(<span class="hljs-built_in">document</span>, <span class="hljs-string">"mouseup"</span>, dragEnd);
      off(display.scroller, <span class="hljs-string">"drop"</span>, dragEnd);
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(e.clientX - e2.clientX) + <span class="hljs-built_in">Math</span>.abs(e.clientY - e2.clientY) &lt; <span class="hljs-number">10</span>) {
        e_preventDefault(e2);
        <span class="hljs-keyword">if</span> (!modifier &amp;&amp; +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - <span class="hljs-number">200</span> &lt; startTime)
          extendSelection(cm.doc, start);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (webkit || ie &amp;&amp; ie_version == <span class="hljs-number">9</span>)
          setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-built_in">document</span>.body.focus(); display.input.focus();}, <span class="hljs-number">20</span>);
        <span class="hljs-keyword">else</span>
          display.input.focus();
      }
    });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Let the drag handler handle this.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (webkit) display.scroller.draggable = <span class="hljs-literal">true</span>;
    cm.state.draggingText = dragEnd;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IE&#39;s approach to draggable</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (display.scroller.dragDrop) display.scroller.dragDrop();
    on(<span class="hljs-built_in">document</span>, <span class="hljs-string">"mouseup"</span>, dragEnd);
    on(display.scroller, <span class="hljs-string">"drop"</span>, dragEnd);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Normal selection, as opposed to text dragging.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leftButtonSelect</span>(<span class="hljs-params">cm, e, start, type, addNew</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    <span class="hljs-keyword">var</span> ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    <span class="hljs-keyword">if</span> (addNew &amp;&amp; !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      <span class="hljs-keyword">if</span> (ourIndex &gt; -<span class="hljs-number">1</span>)
        ourRange = ranges[ourIndex];
      <span class="hljs-keyword">else</span>
        ourRange = <span class="hljs-keyword">new</span> Range(start, start);
    } <span class="hljs-keyword">else</span> {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    <span class="hljs-keyword">if</span> (chromeOS ? e.shiftKey &amp;&amp; e.metaKey : e.altKey) {
      type = <span class="hljs-string">"rect"</span>;
      <span class="hljs-keyword">if</span> (!addNew) ourRange = <span class="hljs-keyword">new</span> Range(start, start);
      start = posFromMouse(cm, e, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
      ourIndex = -<span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"double"</span>) {
      <span class="hljs-keyword">var</span> word = cm.findWordAt(start);
      <span class="hljs-keyword">if</span> (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      <span class="hljs-keyword">else</span>
        ourRange = word;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"triple"</span>) {
      <span class="hljs-keyword">var</span> line = <span class="hljs-keyword">new</span> Range(Pos(start.line, <span class="hljs-number">0</span>), clipPos(doc, Pos(start.line + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));
      <span class="hljs-keyword">if</span> (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      <span class="hljs-keyword">else</span>
        ourRange = line;
    } <span class="hljs-keyword">else</span> {
      ourRange = extendRange(doc, ourRange, start);
    }

    <span class="hljs-keyword">if</span> (!addNew) {
      ourIndex = <span class="hljs-number">0</span>;
      setSelection(doc, <span class="hljs-keyword">new</span> Selection([ourRange], <span class="hljs-number">0</span>), sel_mouse);
      startSel = doc.sel;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ourIndex == -<span class="hljs-number">1</span>) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                   {scroll: <span class="hljs-literal">false</span>, origin: <span class="hljs-string">"*mouse"</span>});
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ranges.length &gt; <span class="hljs-number">1</span> &amp;&amp; ranges[ourIndex].empty() &amp;&amp; type == <span class="hljs-string">"single"</span> &amp;&amp; !e.shiftKey) {
      setSelection(doc, normalizeSelection(ranges.slice(<span class="hljs-number">0</span>, ourIndex).concat(ranges.slice(ourIndex + <span class="hljs-number">1</span>)), <span class="hljs-number">0</span>),
                   {scroll: <span class="hljs-literal">false</span>, origin: <span class="hljs-string">"*mouse"</span>});
      startSel = doc.sel;
    } <span class="hljs-keyword">else</span> {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    <span class="hljs-keyword">var</span> lastPos = start;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extendTo</span>(<span class="hljs-params">pos</span>) </span>{
      <span class="hljs-keyword">if</span> (cmp(lastPos, pos) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
      lastPos = pos;

      <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"rect"</span>) {
        <span class="hljs-keyword">var</span> ranges = [], tabSize = cm.options.tabSize;
        <span class="hljs-keyword">var</span> startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        <span class="hljs-keyword">var</span> posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        <span class="hljs-keyword">var</span> left = <span class="hljs-built_in">Math</span>.min(startCol, posCol), right = <span class="hljs-built_in">Math</span>.max(startCol, posCol);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> line = <span class="hljs-built_in">Math</span>.min(start.line, pos.line), end = <span class="hljs-built_in">Math</span>.min(cm.lastLine(), <span class="hljs-built_in">Math</span>.max(start.line, pos.line));
             line &lt;= end; line++) {
          <span class="hljs-keyword">var</span> text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          <span class="hljs-keyword">if</span> (left == right)
            ranges.push(<span class="hljs-keyword">new</span> Range(Pos(line, leftPos), Pos(line, leftPos)));
          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (text.length &gt; leftPos)
            ranges.push(<span class="hljs-keyword">new</span> Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        <span class="hljs-keyword">if</span> (!ranges.length) ranges.push(<span class="hljs-keyword">new</span> Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(<span class="hljs-number">0</span>, ourIndex).concat(ranges), ourIndex),
                     {origin: <span class="hljs-string">"*mouse"</span>, scroll: <span class="hljs-literal">false</span>});
        cm.scrollIntoView(pos);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> oldRange = ourRange;
        <span class="hljs-keyword">var</span> anchor = oldRange.anchor, head = pos;
        <span class="hljs-keyword">if</span> (type != <span class="hljs-string">"single"</span>) {
          <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"double"</span>)
            <span class="hljs-keyword">var</span> range = cm.findWordAt(pos);
          <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">var</span> range = <span class="hljs-keyword">new</span> Range(Pos(pos.line, <span class="hljs-number">0</span>), clipPos(doc, Pos(pos.line + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));
          <span class="hljs-keyword">if</span> (cmp(range.anchor, anchor) &gt; <span class="hljs-number">0</span>) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } <span class="hljs-keyword">else</span> {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        <span class="hljs-keyword">var</span> ranges = startSel.ranges.slice(<span class="hljs-number">0</span>);
        ranges[ourIndex] = <span class="hljs-keyword">new</span> Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    <span class="hljs-keyword">var</span> editorSize = display.wrapper.getBoundingClientRect();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to ensure timeout re-tries don&#39;t fire when another extend
happened in the meantime (clearTimeout isn&#39;t reliable -- at
least on Chrome, the timeouts still happen even when cleared,
if the clear happens after their scheduled firing time).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>(<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">var</span> curCount = ++counter;
      <span class="hljs-keyword">var</span> cur = posFromMouse(cm, e, <span class="hljs-literal">true</span>, type == <span class="hljs-string">"rect"</span>);
      <span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">if</span> (cmp(cur, lastPos) != <span class="hljs-number">0</span>) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        <span class="hljs-keyword">var</span> visible = visibleLines(display, doc);
        <span class="hljs-keyword">if</span> (cur.line &gt;= visible.to || cur.line &lt; visible.from)
          setTimeout(operation(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">if</span> (counter == curCount) extend(e);}), <span class="hljs-number">150</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> outside = e.clientY &lt; editorSize.top ? -<span class="hljs-number">20</span> : e.clientY &gt; editorSize.bottom ? <span class="hljs-number">20</span> : <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (outside) setTimeout(operation(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (counter != curCount) <span class="hljs-keyword">return</span>;
          display.scroller.scrollTop += outside;
          extend(e);
        }), <span class="hljs-number">50</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">done</span>(<span class="hljs-params">e</span>) </span>{
      cm.state.selectingText = <span class="hljs-literal">false</span>;
      counter = <span class="hljs-literal">Infinity</span>;
      e_preventDefault(e);
      display.input.focus();
      off(<span class="hljs-built_in">document</span>, <span class="hljs-string">"mousemove"</span>, move);
      off(<span class="hljs-built_in">document</span>, <span class="hljs-string">"mouseup"</span>, up);
      doc.history.lastSelOrigin = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> move = operation(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">if</span> (!e_button(e)) done(e);
      <span class="hljs-keyword">else</span> extend(e);
    });
    <span class="hljs-keyword">var</span> up = operation(cm, done);
    cm.state.selectingText = up;
    on(<span class="hljs-built_in">document</span>, <span class="hljs-string">"mousemove"</span>, move);
    on(<span class="hljs-built_in">document</span>, <span class="hljs-string">"mouseup"</span>, up);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Determines whether an event happened in the gutter, and fires the
handlers for the corresponding event.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gutterEvent</span>(<span class="hljs-params">cm, e, type, prevent</span>) </span>{
    <span class="hljs-keyword">try</span> { <span class="hljs-keyword">var</span> mX = e.clientX, mY = e.clientY; }
    <span class="hljs-keyword">catch</span>(e) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
    <span class="hljs-keyword">if</span> (mX &gt;= <span class="hljs-built_in">Math</span>.floor(cm.display.gutters.getBoundingClientRect().right)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (prevent) e_preventDefault(e);

    <span class="hljs-keyword">var</span> display = cm.display;
    <span class="hljs-keyword">var</span> lineBox = display.lineDiv.getBoundingClientRect();

    <span class="hljs-keyword">if</span> (mY &gt; lineBox.bottom || !hasHandler(cm, type)) <span class="hljs-keyword">return</span> e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; cm.options.gutters.length; ++i) {
      <span class="hljs-keyword">var</span> g = display.gutters.childNodes[i];
      <span class="hljs-keyword">if</span> (g &amp;&amp; g.getBoundingClientRect().right &gt;= mX) {
        <span class="hljs-keyword">var</span> line = lineAtHeight(cm.doc, mY);
        <span class="hljs-keyword">var</span> gutter = cm.options.gutters[i];
        signal(cm, type, cm, line, gutter, e);
        <span class="hljs-keyword">return</span> e_defaultPrevented(e);
      }
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickInGutter</span>(<span class="hljs-params">cm, e</span>) </span>{
    <span class="hljs-keyword">return</span> gutterEvent(cm, e, <span class="hljs-string">"gutterClick"</span>, <span class="hljs-literal">true</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Kludge to work around strange IE behavior where it&#39;ll sometimes
re-fire a series of drag-related events right after the drop (#1551)</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> lastDrop = <span class="hljs-number">0</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onDrop</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>;
    clearDragCursor(cm);
    <span class="hljs-keyword">if</span> (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      <span class="hljs-keyword">return</span>;
    e_preventDefault(e);
    <span class="hljs-keyword">if</span> (ie) lastDrop = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;
    <span class="hljs-keyword">var</span> pos = posFromMouse(cm, e, <span class="hljs-literal">true</span>), files = e.dataTransfer.files;
    <span class="hljs-keyword">if</span> (!pos || cm.isReadOnly()) <span class="hljs-keyword">return</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Might be a file drop, in which case we simply extract the text
and insert it.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (files &amp;&amp; files.length &amp;&amp; <span class="hljs-built_in">window</span>.FileReader &amp;&amp; <span class="hljs-built_in">window</span>.File) {
      <span class="hljs-keyword">var</span> n = files.length, text = <span class="hljs-built_in">Array</span>(n), read = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> loadFile = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">file, i</span>) </span>{
        <span class="hljs-keyword">if</span> (cm.options.allowDropFileTypes &amp;&amp;
            indexOf(cm.options.allowDropFileTypes, file.type) == -<span class="hljs-number">1</span>)
          <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> FileReader;
        reader.onload = operation(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> content = reader.result;
          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/[\x00-\x08\x0e-\x1f]{2}/</span>.test(content)) content = <span class="hljs-string">""</span>;
          text[i] = content;
          <span class="hljs-keyword">if</span> (++read == n) {
            pos = clipPos(cm.doc, pos);
            <span class="hljs-keyword">var</span> change = {from: pos, to: pos,
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                          origin: <span class="hljs-string">"paste"</span>};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) loadFile(files[i], i);
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// Normal drop</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Don&#39;t do a replace if the drop happened inside of the selected text.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (cm.state.draggingText &amp;&amp; cm.doc.sel.contains(pos) &gt; -<span class="hljs-number">1</span>) {
        cm.state.draggingText(e);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure the editor is re-focused</p></div></div><div class="code"><div class="wrapper">        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{cm.display.input.focus();}, <span class="hljs-number">20</span>);
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> text = e.dataTransfer.getData(<span class="hljs-string">"Text"</span>);
        <span class="hljs-keyword">if</span> (text) {
          <span class="hljs-keyword">if</span> (cm.state.draggingText &amp;&amp; !(mac ? e.altKey : e.ctrlKey))
            <span class="hljs-keyword">var</span> selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          <span class="hljs-keyword">if</span> (selected) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; selected.length; ++i)
            replaceRange(cm.doc, <span class="hljs-string">""</span>, selected[i].anchor, selected[i].head, <span class="hljs-string">"drag"</span>);
          cm.replaceSelection(text, <span class="hljs-string">"around"</span>, <span class="hljs-string">"paste"</span>);
          cm.display.input.focus();
        }
      }
      <span class="hljs-keyword">catch</span>(e){}
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onDragStart</span>(<span class="hljs-params">cm, e</span>) </span>{
    <span class="hljs-keyword">if</span> (ie &amp;&amp; (!cm.state.draggingText || +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - lastDrop &lt; <span class="hljs-number">100</span>)) { e_stop(e); <span class="hljs-keyword">return</span>; }
    <span class="hljs-keyword">if</span> (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) <span class="hljs-keyword">return</span>;

    e.dataTransfer.setData(<span class="hljs-string">"Text"</span>, cm.getSelection());
    e.dataTransfer.effectAllowed = <span class="hljs-string">"copyMove"</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use dummy image instead of default browsers image.
Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don&#39;t do it there.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (e.dataTransfer.setDragImage &amp;&amp; !safari) {
      <span class="hljs-keyword">var</span> img = elt(<span class="hljs-string">"img"</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"position: fixed; left: 0; top: 0;"</span>);
      img.src = <span class="hljs-string">"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="</span>;
      <span class="hljs-keyword">if</span> (presto) {
        img.width = img.height = <span class="hljs-number">1</span>;
        cm.display.wrapper.appendChild(img);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Force a relayout, or Opera won&#39;t use our image for some obscure reason</p></div></div><div class="code"><div class="wrapper">        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
      <span class="hljs-keyword">if</span> (presto) img.parentNode.removeChild(img);
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onDragOver</span>(<span class="hljs-params">cm, e</span>) </span>{
    <span class="hljs-keyword">var</span> pos = posFromMouse(cm, e);
    <span class="hljs-keyword">if</span> (!pos) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> frag = <span class="hljs-built_in">document</span>.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    <span class="hljs-keyword">if</span> (!cm.display.dragCursor) {
      cm.display.dragCursor = elt(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"CodeMirror-cursors CodeMirror-dragcursors"</span>);
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearDragCursor</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">if</span> (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = <span class="hljs-literal">null</span>;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>SCROLL EVENTS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sync the scrollable area and scrollbars, ensure the viewport
covers the visible area.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setScrollTop</span>(<span class="hljs-params">cm, val</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(cm.doc.scrollTop - val) &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;
    cm.doc.scrollTop = val;
    <span class="hljs-keyword">if</span> (!gecko) updateDisplaySimple(cm, {top: val});
    <span class="hljs-keyword">if</span> (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    <span class="hljs-keyword">if</span> (gecko) updateDisplaySimple(cm);
    startWorker(cm, <span class="hljs-number">100</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sync scroller and scrollbar, ensure the gutter elements are
aligned.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setScrollLeft</span>(<span class="hljs-params">cm, val, isScroller</span>) </span>{
    <span class="hljs-keyword">if</span> (isScroller ? val == cm.doc.scrollLeft : <span class="hljs-built_in">Math</span>.abs(cm.doc.scrollLeft - val) &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;
    val = <span class="hljs-built_in">Math</span>.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    <span class="hljs-keyword">if</span> (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    cm.display.scrollbars.setScrollLeft(val);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Since the delta values reported on mouse wheel events are
unstandardized between browsers and even browser versions, and
generally horribly unpredictable, this code starts by measuring
the scroll effect that the first few mouse wheel events have,
and, from that, detects the way it can convert deltas to pixel
offsets afterwards.</p>
<p>The reason we want to know the amount a wheel event will scroll
is that it gives us a chance to update the display before the
actual scrolling happens, reducing flickering.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> wheelSamples = <span class="hljs-number">0</span>, wheelPixelsPerUnit = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fill in a browser-detected starting value on browsers where we
know one. These don&#39;t have to be accurate -- the result of them
being wrong would just be a slight flicker on the first wheel
scroll (if it is large enough).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> (ie) wheelPixelsPerUnit = -<span class="hljs-number">.53</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gecko) wheelPixelsPerUnit = <span class="hljs-number">15</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chrome) wheelPixelsPerUnit = -<span class="hljs-number">.7</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (safari) wheelPixelsPerUnit = -<span class="hljs-number">1</span>/<span class="hljs-number">3</span>;

  <span class="hljs-keyword">var</span> wheelEventDelta = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">var</span> dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    <span class="hljs-keyword">if</span> (dx == <span class="hljs-literal">null</span> &amp;&amp; e.detail &amp;&amp; e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    <span class="hljs-keyword">if</span> (dy == <span class="hljs-literal">null</span> &amp;&amp; e.detail &amp;&amp; e.axis == e.VERTICAL_AXIS) dy = e.detail;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dy == <span class="hljs-literal">null</span>) dy = e.wheelDelta;
    <span class="hljs-keyword">return</span> {x: dx, y: dy};
  };
  CodeMirror.wheelEventPixels = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">var</span> delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    <span class="hljs-keyword">return</span> delta;
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onScrollWheel</span>(<span class="hljs-params">cm, e</span>) </span>{
    <span class="hljs-keyword">var</span> delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    <span class="hljs-keyword">var</span> display = cm.display, scroll = display.scroller;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Quit if there&#39;s nothing to scroll here</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> canScrollX = scroll.scrollWidth &gt; scroll.clientWidth;
    <span class="hljs-keyword">var</span> canScrollY = scroll.scrollHeight &gt; scroll.clientHeight;
    <span class="hljs-keyword">if</span> (!(dx &amp;&amp; canScrollX || dy &amp;&amp; canScrollY)) <span class="hljs-keyword">return</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Webkit browsers on OS X abort momentum scrolls when the target
of the scroll event is removed from the scrollable element.
This hack (see related code in patchDisplay) makes sure the
element is kept around.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (dy &amp;&amp; mac &amp;&amp; webkit) {
      outer: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; view.length; i++) {
          <span class="hljs-keyword">if</span> (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            <span class="hljs-keyword">break</span> outer;
          }
        }
      }
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On some browsers, horizontal scrolling will cause redraws to
happen before the gutter has been realigned, causing it to
wriggle around in a most unseemly way. When we have an
estimated pixels/delta value, we just handle horizontal
scrolling entirely here. It&#39;ll be slightly off from native, but
better than glitching out.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (dx &amp;&amp; !gecko &amp;&amp; !presto &amp;&amp; wheelPixelsPerUnit != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (dy &amp;&amp; canScrollY)
        setScrollTop(cm, <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Only prevent default scrolling if vertical scrolling is
actually possible. Otherwise, it causes vertical scroll
jitter on OSX trackpads when deltaX is small and deltaY
is large (issue #3579)</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (!dy || (dy &amp;&amp; canScrollY))
        e_preventDefault(e);
      display.wheelStartX = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Abort measurement, if in progress</span>
      <span class="hljs-keyword">return</span>;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>&#39;Project&#39; the visible viewport to cover the area that is being
scrolled into view (if we know enough to estimate it).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (dy &amp;&amp; wheelPixelsPerUnit != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> pixels = dy * wheelPixelsPerUnit;
      <span class="hljs-keyword">var</span> top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      <span class="hljs-keyword">if</span> (pixels &lt; <span class="hljs-number">0</span>) top = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, top + pixels - <span class="hljs-number">50</span>);
      <span class="hljs-keyword">else</span> bot = <span class="hljs-built_in">Math</span>.min(cm.doc.height, bot + pixels + <span class="hljs-number">50</span>);
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    <span class="hljs-keyword">if</span> (wheelSamples &lt; <span class="hljs-number">20</span>) {
      <span class="hljs-keyword">if</span> (display.wheelStartX == <span class="hljs-literal">null</span>) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">if</span> (display.wheelStartX == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
          <span class="hljs-keyword">var</span> movedX = scroll.scrollLeft - display.wheelStartX;
          <span class="hljs-keyword">var</span> movedY = scroll.scrollTop - display.wheelStartY;
          <span class="hljs-keyword">var</span> sample = (movedY &amp;&amp; display.wheelDY &amp;&amp; movedY / display.wheelDY) ||
            (movedX &amp;&amp; display.wheelDX &amp;&amp; movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">if</span> (!sample) <span class="hljs-keyword">return</span>;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + <span class="hljs-number">1</span>);
          ++wheelSamples;
        }, <span class="hljs-number">200</span>);
      } <span class="hljs-keyword">else</span> {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>KEY EVENTS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Run a handler that was bound to a key.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doHandleBinding</span>(<span class="hljs-params">cm, bound, dropShift</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> bound == <span class="hljs-string">"string"</span>) {
      bound = commands[bound];
      <span class="hljs-keyword">if</span> (!bound) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure previous input has been read, so that the handler sees a
consistent view of the document</p></div></div><div class="code"><div class="wrapper">    cm.display.input.ensurePolled();
    <span class="hljs-keyword">var</span> prevShift = cm.display.shift, done = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span> (cm.isReadOnly()) cm.state.suppressEdits = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (dropShift) cm.display.shift = <span class="hljs-literal">false</span>;
      done = bound(cm) != Pass;
    } <span class="hljs-keyword">finally</span> {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> done;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lookupKeyForEditor</span>(<span class="hljs-params">cm, name, handle</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; cm.state.keyMaps.length; i++) {
      <span class="hljs-keyword">var</span> result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      <span class="hljs-keyword">if</span> (result) <span class="hljs-keyword">return</span> result;
    }
    <span class="hljs-keyword">return</span> (cm.options.extraKeys &amp;&amp; lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  <span class="hljs-keyword">var</span> stopSeq = <span class="hljs-keyword">new</span> Delayed;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchKey</span>(<span class="hljs-params">cm, name, e, handle</span>) </span>{
    <span class="hljs-keyword">var</span> seq = cm.state.keySeq;
    <span class="hljs-keyword">if</span> (seq) {
      <span class="hljs-keyword">if</span> (isModifierKey(name)) <span class="hljs-keyword">return</span> <span class="hljs-string">"handled"</span>;
      stopSeq.set(<span class="hljs-number">50</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (cm.state.keySeq == seq) {
          cm.state.keySeq = <span class="hljs-literal">null</span>;
          cm.display.input.reset();
        }
      });
      name = seq + <span class="hljs-string">" "</span> + name;
    }
    <span class="hljs-keyword">var</span> result = lookupKeyForEditor(cm, name, handle);

    <span class="hljs-keyword">if</span> (result == <span class="hljs-string">"multi"</span>)
      cm.state.keySeq = name;
    <span class="hljs-keyword">if</span> (result == <span class="hljs-string">"handled"</span>)
      signalLater(cm, <span class="hljs-string">"keyHandled"</span>, cm, name, e);

    <span class="hljs-keyword">if</span> (result == <span class="hljs-string">"handled"</span> || result == <span class="hljs-string">"multi"</span>) {
      e_preventDefault(e);
      restartBlink(cm);
    }

    <span class="hljs-keyword">if</span> (seq &amp;&amp; !result &amp;&amp; <span class="hljs-regexp">/\'$/</span>.test(name)) {
      e_preventDefault(e);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> !!result;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Handle a key from the keydown event.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleKeyBinding</span>(<span class="hljs-params">cm, e</span>) </span>{
    <span class="hljs-keyword">var</span> name = keyName(e, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (!name) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (e.shiftKey &amp;&amp; !cm.state.keySeq) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>First try to resolve full name (including &#39;Shift-&#39;). Failing
that, see if there is a cursor-motion command (starting with
&#39;go&#39;) bound to the keyname without &#39;Shift-&#39;.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">return</span> dispatchKey(cm, <span class="hljs-string">"Shift-"</span> + name, e, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>{<span class="hljs-keyword">return</span> doHandleBinding(cm, b, <span class="hljs-literal">true</span>);})
          || dispatchKey(cm, name, e, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>{
               <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> b == <span class="hljs-string">"string"</span> ? <span class="hljs-regexp">/^go[A-Z]/</span>.test(b) : b.motion)
                 <span class="hljs-keyword">return</span> doHandleBinding(cm, b);
             });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> dispatchKey(cm, name, e, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>{ <span class="hljs-keyword">return</span> doHandleBinding(cm, b); });
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Handle a key from the keypress event</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleCharBinding</span>(<span class="hljs-params">cm, e, ch</span>) </span>{
    <span class="hljs-keyword">return</span> dispatchKey(cm, <span class="hljs-string">"'"</span> + ch + <span class="hljs-string">"'"</span>, e,
                       <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>{ <span class="hljs-keyword">return</span> doHandleBinding(cm, b, <span class="hljs-literal">true</span>); });
  }

  <span class="hljs-keyword">var</span> lastStoppedKey = <span class="hljs-literal">null</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onKeyDown</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>;
    cm.curOp.focus = activeElt();
    <span class="hljs-keyword">if</span> (signalDOMEvent(cm, e)) <span class="hljs-keyword">return</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IE does strange things with escape.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">11</span> &amp;&amp; e.keyCode == <span class="hljs-number">27</span>) e.returnValue = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> code = e.keyCode;
    cm.display.shift = code == <span class="hljs-number">16</span> || e.shiftKey;
    <span class="hljs-keyword">var</span> handled = handleKeyBinding(cm, e);
    <span class="hljs-keyword">if</span> (presto) {
      lastStoppedKey = handled ? code : <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Opera has no cut event... we try to at least catch the key combo</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (!handled &amp;&amp; code == <span class="hljs-number">88</span> &amp;&amp; !hasCopyEvent &amp;&amp; (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection(<span class="hljs-string">""</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"cut"</span>);
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Turn mouse into crosshair when Alt is held on Mac.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (code == <span class="hljs-number">18</span> &amp;&amp; !<span class="hljs-regexp">/\bCodeMirror-crosshair\b/</span>.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showCrossHair</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> lineDiv = cm.display.lineDiv;
    addClass(lineDiv, <span class="hljs-string">"CodeMirror-crosshair"</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">up</span>(<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">if</span> (e.keyCode == <span class="hljs-number">18</span> || !e.altKey) {
        rmClass(lineDiv, <span class="hljs-string">"CodeMirror-crosshair"</span>);
        off(<span class="hljs-built_in">document</span>, <span class="hljs-string">"keyup"</span>, up);
        off(<span class="hljs-built_in">document</span>, <span class="hljs-string">"mouseover"</span>, up);
      }
    }
    on(<span class="hljs-built_in">document</span>, <span class="hljs-string">"keyup"</span>, up);
    on(<span class="hljs-built_in">document</span>, <span class="hljs-string">"mouseover"</span>, up);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onKeyUp</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">if</span> (e.keyCode == <span class="hljs-number">16</span>) <span class="hljs-keyword">this</span>.doc.sel.shift = <span class="hljs-literal">false</span>;
    signalDOMEvent(<span class="hljs-keyword">this</span>, e);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onKeyPress</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">if</span> (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey &amp;&amp; !e.altKey || mac &amp;&amp; e.metaKey) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> keyCode = e.keyCode, charCode = e.charCode;
    <span class="hljs-keyword">if</span> (presto &amp;&amp; keyCode == lastStoppedKey) {lastStoppedKey = <span class="hljs-literal">null</span>; e_preventDefault(e); <span class="hljs-keyword">return</span>;}
    <span class="hljs-keyword">if</span> ((presto &amp;&amp; (!e.which || e.which &lt; <span class="hljs-number">10</span>)) &amp;&amp; handleKeyBinding(cm, e)) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> ch = <span class="hljs-built_in">String</span>.fromCharCode(charCode == <span class="hljs-literal">null</span> ? keyCode : charCode);
    <span class="hljs-keyword">if</span> (handleCharBinding(cm, e, ch)) <span class="hljs-keyword">return</span>;
    cm.display.input.onKeyPress(e);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>FOCUS/BLUR EVENTS</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delayBlurEvent</span>(<span class="hljs-params">cm</span>) </span>{
    cm.state.delayingBlurEvent = <span class="hljs-literal">true</span>;
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = <span class="hljs-literal">false</span>;
        onBlur(cm);
      }
    }, <span class="hljs-number">100</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFocus</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">if</span> (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (cm.options.readOnly == <span class="hljs-string">"nocursor"</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (!cm.state.focused) {
      signal(cm, <span class="hljs-string">"focus"</span>, cm);
      cm.state.focused = <span class="hljs-literal">true</span>;
      addClass(cm.display.wrapper, <span class="hljs-string">"CodeMirror-focused"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This test prevents this from firing when a context
menu is closed (since the input reset would kill the
select-all detection hack)</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (!cm.curOp &amp;&amp; cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        <span class="hljs-keyword">if</span> (webkit) setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ cm.display.input.reset(<span class="hljs-literal">true</span>); }, <span class="hljs-number">20</span>); <span class="hljs-comment">// Issue #1730</span>
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onBlur</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">if</span> (cm.state.delayingBlurEvent) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">if</span> (cm.state.focused) {
      signal(cm, <span class="hljs-string">"blur"</span>, cm);
      cm.state.focused = <span class="hljs-literal">false</span>;
      rmClass(cm.display.wrapper, <span class="hljs-string">"CodeMirror-focused"</span>);
    }
    clearInterval(cm.display.blinker);
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">if</span> (!cm.state.focused) cm.display.shift = <span class="hljs-literal">false</span>;}, <span class="hljs-number">150</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>CONTEXT MENU HANDLING</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>To make the context menu work, we need to briefly unhide the
textarea (making it as unobtrusive as possible) to let the
right-click take effect on it.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onContextMenu</span>(<span class="hljs-params">cm, e</span>) </span>{
    <span class="hljs-keyword">if</span> (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (signalDOMEvent(cm, e, <span class="hljs-string">"contextmenu"</span>)) <span class="hljs-keyword">return</span>;
    cm.display.input.onContextMenu(e);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contextMenuInGutter</span>(<span class="hljs-params">cm, e</span>) </span>{
    <span class="hljs-keyword">if</span> (!hasHandler(cm, <span class="hljs-string">"gutterContextMenu"</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> gutterEvent(cm, e, <span class="hljs-string">"gutterContextMenu"</span>, <span class="hljs-literal">false</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>UPDATING</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute the position of the end of a change (its &#39;to&#39; property
refers to the pre-change end).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> changeEnd = CodeMirror.changeEnd = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">change</span>) </span>{
    <span class="hljs-keyword">if</span> (!change.text) <span class="hljs-keyword">return</span> change.to;
    <span class="hljs-keyword">return</span> Pos(change.from.line + change.text.length - <span class="hljs-number">1</span>,
               lst(change.text).length + (change.text.length == <span class="hljs-number">1</span> ? change.from.ch : <span class="hljs-number">0</span>));
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Adjust a position to refer to the post-change position of the
same text, or the end of the change if the change covers it.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adjustForChange</span>(<span class="hljs-params">pos, change</span>) </span>{
    <span class="hljs-keyword">if</span> (cmp(pos, change.from) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> pos;
    <span class="hljs-keyword">if</span> (cmp(pos, change.to) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> changeEnd(change);

    <span class="hljs-keyword">var</span> line = pos.line + change.text.length - (change.to.line - change.from.line) - <span class="hljs-number">1</span>, ch = pos.ch;
    <span class="hljs-keyword">if</span> (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    <span class="hljs-keyword">return</span> Pos(line, ch);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeSelAfterChange</span>(<span class="hljs-params">doc, change</span>) </span>{
    <span class="hljs-keyword">var</span> out = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; doc.sel.ranges.length; i++) {
      <span class="hljs-keyword">var</span> range = doc.sel.ranges[i];
      out.push(<span class="hljs-keyword">new</span> Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    <span class="hljs-keyword">return</span> normalizeSelection(out, doc.sel.primIndex);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">offsetPos</span>(<span class="hljs-params">pos, old, nw</span>) </span>{
    <span class="hljs-keyword">if</span> (pos.line == old.line)
      <span class="hljs-keyword">return</span> Pos(nw.line, pos.ch - old.ch + nw.ch);
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">return</span> Pos(nw.line + (pos.line - old.line), pos.ch);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used by replaceSelections to allow moving the selection to the
start or around the replaced test. Hint may be &quot;start&quot; or &quot;around&quot;.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeReplacedSel</span>(<span class="hljs-params">doc, changes, hint</span>) </span>{
    <span class="hljs-keyword">var</span> out = [];
    <span class="hljs-keyword">var</span> oldPrev = Pos(doc.first, <span class="hljs-number">0</span>), newPrev = oldPrev;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; changes.length; i++) {
      <span class="hljs-keyword">var</span> change = changes[i];
      <span class="hljs-keyword">var</span> from = offsetPos(change.from, oldPrev, newPrev);
      <span class="hljs-keyword">var</span> to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      <span class="hljs-keyword">if</span> (hint == <span class="hljs-string">"around"</span>) {
        <span class="hljs-keyword">var</span> range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) &lt; <span class="hljs-number">0</span>;
        out[i] = <span class="hljs-keyword">new</span> Range(inv ? to : from, inv ? from : to);
      } <span class="hljs-keyword">else</span> {
        out[i] = <span class="hljs-keyword">new</span> Range(from, from);
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Selection(out, doc.sel.primIndex);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Allow &quot;beforeChange&quot; event handlers to influence a change</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterChange</span>(<span class="hljs-params">doc, change, update</span>) </span>{
    <span class="hljs-keyword">var</span> obj = {
      canceled: <span class="hljs-literal">false</span>,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>.canceled = <span class="hljs-literal">true</span>; }
    };
    <span class="hljs-keyword">if</span> (update) obj.update = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, to, text, origin</span>) </span>{
      <span class="hljs-keyword">if</span> (from) <span class="hljs-keyword">this</span>.from = clipPos(doc, from);
      <span class="hljs-keyword">if</span> (to) <span class="hljs-keyword">this</span>.to = clipPos(doc, to);
      <span class="hljs-keyword">if</span> (text) <span class="hljs-keyword">this</span>.text = text;
      <span class="hljs-keyword">if</span> (origin !== <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">this</span>.origin = origin;
    };
    signal(doc, <span class="hljs-string">"beforeChange"</span>, doc, obj);
    <span class="hljs-keyword">if</span> (doc.cm) signal(doc.cm, <span class="hljs-string">"beforeChange"</span>, doc.cm, obj);

    <span class="hljs-keyword">if</span> (obj.canceled) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply a change to a document, and add it to the document&#39;s
history, and propagating it to all linked documents.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeChange</span>(<span class="hljs-params">doc, change, ignoreReadOnly</span>) </span>{
    <span class="hljs-keyword">if</span> (doc.cm) {
      <span class="hljs-keyword">if</span> (!doc.cm.curOp) <span class="hljs-keyword">return</span> operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      <span class="hljs-keyword">if</span> (doc.cm.state.suppressEdits) <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (hasHandler(doc, <span class="hljs-string">"beforeChange"</span>) || doc.cm &amp;&amp; hasHandler(doc.cm, <span class="hljs-string">"beforeChange"</span>)) {
      change = filterChange(doc, change, <span class="hljs-literal">true</span>);
      <span class="hljs-keyword">if</span> (!change) <span class="hljs-keyword">return</span>;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Possibly split or suppress the update based on the presence
of read-only spans in its range.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> split = sawReadOnlySpans &amp;&amp; !ignoreReadOnly &amp;&amp; removeReadOnlyRanges(doc, change.from, change.to);
    <span class="hljs-keyword">if</span> (split) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = split.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [<span class="hljs-string">""</span>] : change.text});
    } <span class="hljs-keyword">else</span> {
      makeChangeInner(doc, change);
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeChangeInner</span>(<span class="hljs-params">doc, change</span>) </span>{
    <span class="hljs-keyword">if</span> (change.text.length == <span class="hljs-number">1</span> &amp;&amp; change.text[<span class="hljs-number">0</span>] == <span class="hljs-string">""</span> &amp;&amp; cmp(change.from, change.to) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : <span class="hljs-literal">NaN</span>);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    <span class="hljs-keyword">var</span> rebased = [];

    linkedDocs(doc, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc, sharedHist</span>) </span>{
      <span class="hljs-keyword">if</span> (!sharedHist &amp;&amp; indexOf(rebased, doc.history) == -<span class="hljs-number">1</span>) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, <span class="hljs-literal">null</span>, stretchSpansOverChange(doc, change));
    });
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Revert a change stored in a document&#39;s history.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeChangeFromHistory</span>(<span class="hljs-params">doc, type, allowSelectionOnly</span>) </span>{
    <span class="hljs-keyword">if</span> (doc.cm &amp;&amp; doc.cm.state.suppressEdits) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">var</span> hist = doc.history, event, selAfter = doc.sel;
    <span class="hljs-keyword">var</span> source = type == <span class="hljs-string">"undo"</span> ? hist.done : hist.undone, dest = type == <span class="hljs-string">"undo"</span> ? hist.undone : hist.done;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Verify that there is a useable event (so that ctrl-z won&#39;t
needlessly clear selection events)</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; source.length; i++) {
      event = source[i];
      <span class="hljs-keyword">if</span> (allowSelectionOnly ? event.ranges &amp;&amp; !event.equals(doc.sel) : !event.ranges)
        <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">if</span> (i == source.length) <span class="hljs-keyword">return</span>;
    hist.lastOrigin = hist.lastSelOrigin = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">for</span> (;;) {
      event = source.pop();
      <span class="hljs-keyword">if</span> (event.ranges) {
        pushSelectionToHistory(event, dest);
        <span class="hljs-keyword">if</span> (allowSelectionOnly &amp;&amp; !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: <span class="hljs-literal">false</span>});
          <span class="hljs-keyword">return</span>;
        }
        selAfter = event;
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build up a reverse change object to add to the opposite history
stack (redo when undoing, and vice versa).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    <span class="hljs-keyword">var</span> filter = hasHandler(doc, <span class="hljs-string">"beforeChange"</span>) || doc.cm &amp;&amp; hasHandler(doc.cm, <span class="hljs-string">"beforeChange"</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = event.changes.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
      <span class="hljs-keyword">var</span> change = event.changes[i];
      change.origin = type;
      <span class="hljs-keyword">if</span> (filter &amp;&amp; !filterChange(doc, change, <span class="hljs-literal">false</span>)) {
        source.length = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span>;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      <span class="hljs-keyword">var</span> after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      <span class="hljs-keyword">if</span> (!i &amp;&amp; doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
      <span class="hljs-keyword">var</span> rebased = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Propagate to the linked documents</p></div></div><div class="code"><div class="wrapper">      linkedDocs(doc, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc, sharedHist</span>) </span>{
        <span class="hljs-keyword">if</span> (!sharedHist &amp;&amp; indexOf(rebased, doc.history) == -<span class="hljs-number">1</span>) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, <span class="hljs-literal">null</span>, mergeOldSpans(doc, change));
      });
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sub-views need their line numbers shifted when text is added
above or below them in the parent document.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shiftDoc</span>(<span class="hljs-params">doc, distance</span>) </span>{
    <span class="hljs-keyword">if</span> (distance == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
    doc.first += distance;
    doc.sel = <span class="hljs-keyword">new</span> Selection(map(doc.sel.ranges, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    <span class="hljs-keyword">if</span> (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> d = doc.cm.display, l = d.viewFrom; l &lt; d.viewTo; l++)
        regLineChange(doc.cm, l, <span class="hljs-string">"gutter"</span>);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>More lower-level change function, handling only a single document
(not linked ones).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeChangeSingleDoc</span>(<span class="hljs-params">doc, change, selAfter, spans</span>) </span>{
    <span class="hljs-keyword">if</span> (doc.cm &amp;&amp; !doc.cm.curOp)
      <span class="hljs-keyword">return</span> operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    <span class="hljs-keyword">if</span> (change.to.line &lt; doc.first) {
      shiftDoc(doc, change.text.length - <span class="hljs-number">1</span> - (change.to.line - change.from.line));
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (change.from.line &gt; doc.lastLine()) <span class="hljs-keyword">return</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Clip the change to the size of this doc</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (change.from.line &lt; doc.first) {
      <span class="hljs-keyword">var</span> shift = change.text.length - <span class="hljs-number">1</span> - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, <span class="hljs-number">0</span>), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    <span class="hljs-keyword">var</span> last = doc.lastLine();
    <span class="hljs-keyword">if</span> (change.to.line &gt; last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[<span class="hljs-number">0</span>]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    <span class="hljs-keyword">if</span> (!selAfter) selAfter = computeSelAfterChange(doc, change);
    <span class="hljs-keyword">if</span> (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    <span class="hljs-keyword">else</span> updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Handle the interaction of a change to a document with the editor
that this document is part of.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeChangeSingleDocInEditor</span>(<span class="hljs-params">cm, change, spans</span>) </span>{
    <span class="hljs-keyword">var</span> doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    <span class="hljs-keyword">var</span> recomputeMaxLength = <span class="hljs-literal">false</span>, checkWidthStart = from.line;
    <span class="hljs-keyword">if</span> (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + <span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">if</span> (line == display.maxLine) {
          recomputeMaxLength = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      });
    }

    <span class="hljs-keyword">if</span> (doc.sel.contains(change.from, change.to) &gt; -<span class="hljs-number">1</span>)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    <span class="hljs-keyword">if</span> (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">var</span> len = lineLength(line);
        <span class="hljs-keyword">if</span> (len &gt; display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = <span class="hljs-literal">true</span>;
          recomputeMaxLength = <span class="hljs-literal">false</span>;
        }
      });
      <span class="hljs-keyword">if</span> (recomputeMaxLength) cm.curOp.updateMaxLine = <span class="hljs-literal">true</span>;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Adjust frontier, schedule worker</p></div></div><div class="code"><div class="wrapper">    doc.frontier = <span class="hljs-built_in">Math</span>.min(doc.frontier, from.line);
    startWorker(cm, <span class="hljs-number">400</span>);

    <span class="hljs-keyword">var</span> lendiff = change.text.length - (to.line - from.line) - <span class="hljs-number">1</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remember that these lines changed, for updating the display</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (change.full)
      regChange(cm);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (from.line == to.line &amp;&amp; change.text.length == <span class="hljs-number">1</span> &amp;&amp; !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, <span class="hljs-string">"text"</span>);
    <span class="hljs-keyword">else</span>
      regChange(cm, from.line, to.line + <span class="hljs-number">1</span>, lendiff);

    <span class="hljs-keyword">var</span> changesHandler = hasHandler(cm, <span class="hljs-string">"changes"</span>), changeHandler = hasHandler(cm, <span class="hljs-string">"change"</span>);
    <span class="hljs-keyword">if</span> (changeHandler || changesHandler) {
      <span class="hljs-keyword">var</span> obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      <span class="hljs-keyword">if</span> (changeHandler) signalLater(cm, <span class="hljs-string">"change"</span>, cm, obj);
      <span class="hljs-keyword">if</span> (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceRange</span>(<span class="hljs-params">doc, code, from, to, origin</span>) </span>{
    <span class="hljs-keyword">if</span> (!to) to = from;
    <span class="hljs-keyword">if</span> (cmp(to, from) &lt; <span class="hljs-number">0</span>) { <span class="hljs-keyword">var</span> tmp = to; to = from; from = tmp; }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> code == <span class="hljs-string">"string"</span>) code = doc.splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>SCROLLING THINGS INTO VIEW</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If an editor sits on the top or bottom of the window, partially
scrolled out of view, this ensures that the cursor is visible.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybeScrollWindow</span>(<span class="hljs-params">cm, coords</span>) </span>{
    <span class="hljs-keyword">if</span> (signalDOMEvent(cm, <span class="hljs-string">"scrollCursorIntoView"</span>)) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">var</span> display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (coords.top + box.top &lt; <span class="hljs-number">0</span>) doScroll = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (coords.bottom + box.top &gt; (<span class="hljs-built_in">window</span>.innerHeight || <span class="hljs-built_in">document</span>.documentElement.clientHeight)) doScroll = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (doScroll != <span class="hljs-literal">null</span> &amp;&amp; !phantom) {
      <span class="hljs-keyword">var</span> scrollNode = elt(<span class="hljs-string">"div"</span>, <span class="hljs-string">"\u200b"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"position: absolute; top: "</span> +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + <span class="hljs-string">"px; height: "</span> +
                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + <span class="hljs-string">"px; left: "</span> +
                           coords.left + <span class="hljs-string">"px; width: 2px;"</span>);
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Scroll a given position into view (immediately), verifying that
it actually became visible (as line heights are accurately
measured, the position of something may &#39;drift&#39; during drawing).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scrollPosIntoView</span>(<span class="hljs-params">cm, pos, end, margin</span>) </span>{
    <span class="hljs-keyword">if</span> (margin == <span class="hljs-literal">null</span>) margin = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> limit = <span class="hljs-number">0</span>; limit &lt; <span class="hljs-number">5</span>; limit++) {
      <span class="hljs-keyword">var</span> changed = <span class="hljs-literal">false</span>, coords = cursorCoords(cm, pos);
      <span class="hljs-keyword">var</span> endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      <span class="hljs-keyword">var</span> scrollPos = calculateScrollPos(cm, <span class="hljs-built_in">Math</span>.min(coords.left, endCoords.left),
                                         <span class="hljs-built_in">Math</span>.min(coords.top, endCoords.top) - margin,
                                         <span class="hljs-built_in">Math</span>.max(coords.left, endCoords.left),
                                         <span class="hljs-built_in">Math</span>.max(coords.bottom, endCoords.bottom) + margin);
      <span class="hljs-keyword">var</span> startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      <span class="hljs-keyword">if</span> (scrollPos.scrollTop != <span class="hljs-literal">null</span>) {
        setScrollTop(cm, scrollPos.scrollTop);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(cm.doc.scrollTop - startTop) &gt; <span class="hljs-number">1</span>) changed = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">if</span> (scrollPos.scrollLeft != <span class="hljs-literal">null</span>) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(cm.doc.scrollLeft - startLeft) &gt; <span class="hljs-number">1</span>) changed = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">if</span> (!changed) <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span> coords;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Scroll a given set of coordinates into view (immediately).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scrollIntoView</span>(<span class="hljs-params">cm, x1, y1, x2, y2</span>) </span>{
    <span class="hljs-keyword">var</span> scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    <span class="hljs-keyword">if</span> (scrollPos.scrollTop != <span class="hljs-literal">null</span>) setScrollTop(cm, scrollPos.scrollTop);
    <span class="hljs-keyword">if</span> (scrollPos.scrollLeft != <span class="hljs-literal">null</span>) setScrollLeft(cm, scrollPos.scrollLeft);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate a new scroll position needed to scroll the given
rectangle into view. Returns an object with scrollTop and
scrollLeft properties. When these are undefined, the
vertical/horizontal position does not need to be adjusted.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateScrollPos</span>(<span class="hljs-params">cm, x1, y1, x2, y2</span>) </span>{
    <span class="hljs-keyword">var</span> display = cm.display, snapMargin = textHeight(cm.display);
    <span class="hljs-keyword">if</span> (y1 &lt; <span class="hljs-number">0</span>) y1 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> screentop = cm.curOp &amp;&amp; cm.curOp.scrollTop != <span class="hljs-literal">null</span> ? cm.curOp.scrollTop : display.scroller.scrollTop;
    <span class="hljs-keyword">var</span> screen = displayHeight(cm), result = {};
    <span class="hljs-keyword">if</span> (y2 - y1 &gt; screen) y2 = y1 + screen;
    <span class="hljs-keyword">var</span> docBottom = cm.doc.height + paddingVert(display);
    <span class="hljs-keyword">var</span> atTop = y1 &lt; snapMargin, atBottom = y2 &gt; docBottom - snapMargin;
    <span class="hljs-keyword">if</span> (y1 &lt; screentop) {
      result.scrollTop = atTop ? <span class="hljs-number">0</span> : y1;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y2 &gt; screentop + screen) {
      <span class="hljs-keyword">var</span> newTop = <span class="hljs-built_in">Math</span>.min(y1, (atBottom ? docBottom : y2) - screen);
      <span class="hljs-keyword">if</span> (newTop != screentop) result.scrollTop = newTop;
    }

    <span class="hljs-keyword">var</span> screenleft = cm.curOp &amp;&amp; cm.curOp.scrollLeft != <span class="hljs-literal">null</span> ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    <span class="hljs-keyword">var</span> screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : <span class="hljs-number">0</span>);
    <span class="hljs-keyword">var</span> tooWide = x2 - x1 &gt; screenw;
    <span class="hljs-keyword">if</span> (tooWide) x2 = x1 + screenw;
    <span class="hljs-keyword">if</span> (x1 &lt; <span class="hljs-number">10</span>)
      result.scrollLeft = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x1 &lt; screenleft)
      result.scrollLeft = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, x1 - (tooWide ? <span class="hljs-number">0</span> : <span class="hljs-number">10</span>));
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x2 &gt; screenw + screenleft - <span class="hljs-number">3</span>)
      result.scrollLeft = x2 + (tooWide ? <span class="hljs-number">0</span> : <span class="hljs-number">10</span>) - screenw;
    <span class="hljs-keyword">return</span> result;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store a relative adjustment to the scroll position in the current
operation (to be applied when the operation finishes).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addToScrollPos</span>(<span class="hljs-params">cm, left, top</span>) </span>{
    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> || top != <span class="hljs-literal">null</span>) resolveScrollToPos(cm);
    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span>)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == <span class="hljs-literal">null</span> ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    <span class="hljs-keyword">if</span> (top != <span class="hljs-literal">null</span>)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == <span class="hljs-literal">null</span> ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make sure that at the end of the operation the current cursor is
shown.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureCursorVisible</span>(<span class="hljs-params">cm</span>) </span>{
    resolveScrollToPos(cm);
    <span class="hljs-keyword">var</span> cur = cm.getCursor(), from = cur, to = cur;
    <span class="hljs-keyword">if</span> (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - <span class="hljs-number">1</span>) : cur;
      to = Pos(cur.line, cur.ch + <span class="hljs-number">1</span>);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: <span class="hljs-literal">true</span>};
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When an operation has its scrollToPos property set, and another
scroll action is applied before the end of the operation, this
&#39;simulates&#39; scrolling that position into view in a cheap way, so
that the effect of intermediate scroll commands is not ignored.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveScrollToPos</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> range = cm.curOp.scrollToPos;
    <span class="hljs-keyword">if</span> (range) {
      cm.curOp.scrollToPos = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      <span class="hljs-keyword">var</span> sPos = calculateScrollPos(cm, <span class="hljs-built_in">Math</span>.min(from.left, to.left),
                                    <span class="hljs-built_in">Math</span>.min(from.top, to.top) - range.margin,
                                    <span class="hljs-built_in">Math</span>.max(from.right, to.right),
                                    <span class="hljs-built_in">Math</span>.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>API UTILITIES</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Indent the given line. The how parameter can be &quot;smart&quot;,
&quot;add&quot;/null, &quot;subtract&quot;, or &quot;prev&quot;. When aggressive is false
(typically set to true for forced single-line indents), empty
lines are not indented, and places where the mode returns Pass
are left alone.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indentLine</span>(<span class="hljs-params">cm, n, how, aggressive</span>) </span>{
    <span class="hljs-keyword">var</span> doc = cm.doc, state;
    <span class="hljs-keyword">if</span> (how == <span class="hljs-literal">null</span>) how = <span class="hljs-string">"add"</span>;
    <span class="hljs-keyword">if</span> (how == <span class="hljs-string">"smart"</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fall back to &quot;prev&quot; when the mode doesn&#39;t have an indentation
method.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (!doc.mode.indent) how = <span class="hljs-string">"prev"</span>;
      <span class="hljs-keyword">else</span> state = getStateBefore(cm, n);
    }

    <span class="hljs-keyword">var</span> tabSize = cm.options.tabSize;
    <span class="hljs-keyword">var</span> line = getLine(doc, n), curSpace = countColumn(line.text, <span class="hljs-literal">null</span>, tabSize);
    <span class="hljs-keyword">if</span> (line.stateAfter) line.stateAfter = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> curSpaceString = line.text.match(<span class="hljs-regexp">/^\s*/</span>)[<span class="hljs-number">0</span>], indentation;
    <span class="hljs-keyword">if</span> (!aggressive &amp;&amp; !<span class="hljs-regexp">/\S/</span>.test(line.text)) {
      indentation = <span class="hljs-number">0</span>;
      how = <span class="hljs-string">"not"</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (how == <span class="hljs-string">"smart"</span>) {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      <span class="hljs-keyword">if</span> (indentation == Pass || indentation &gt; <span class="hljs-number">150</span>) {
        <span class="hljs-keyword">if</span> (!aggressive) <span class="hljs-keyword">return</span>;
        how = <span class="hljs-string">"prev"</span>;
      }
    }
    <span class="hljs-keyword">if</span> (how == <span class="hljs-string">"prev"</span>) {
      <span class="hljs-keyword">if</span> (n &gt; doc.first) indentation = countColumn(getLine(doc, n-<span class="hljs-number">1</span>).text, <span class="hljs-literal">null</span>, tabSize);
      <span class="hljs-keyword">else</span> indentation = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (how == <span class="hljs-string">"add"</span>) {
      indentation = curSpace + cm.options.indentUnit;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (how == <span class="hljs-string">"subtract"</span>) {
      indentation = curSpace - cm.options.indentUnit;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> how == <span class="hljs-string">"number"</span>) {
      indentation = curSpace + how;
    }
    indentation = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, indentation);

    <span class="hljs-keyword">var</span> indentString = <span class="hljs-string">""</span>, pos = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (cm.options.indentWithTabs)
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-built_in">Math</span>.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += <span class="hljs-string">"\t"</span>;}
    <span class="hljs-keyword">if</span> (pos &lt; indentation) indentString += spaceStr(indentation - pos);

    <span class="hljs-keyword">if</span> (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, <span class="hljs-number">0</span>), Pos(n, curSpaceString.length), <span class="hljs-string">"+input"</span>);
      line.stateAfter = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure that, if the cursor was in the whitespace at the start
of the line, it is moved to the end of that space.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; doc.sel.ranges.length; i++) {
        <span class="hljs-keyword">var</span> range = doc.sel.ranges[i];
        <span class="hljs-keyword">if</span> (range.head.line == n &amp;&amp; range.head.ch &lt; curSpaceString.length) {
          <span class="hljs-keyword">var</span> pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, <span class="hljs-keyword">new</span> Range(pos, pos));
          <span class="hljs-keyword">break</span>;
        }
      }
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Utility for applying a change to a line by handle or number,
returning the number and optionally registering the line as
changed.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeLine</span>(<span class="hljs-params">doc, handle, changeType, op</span>) </span>{
    <span class="hljs-keyword">var</span> no = handle, line = handle;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handle == <span class="hljs-string">"number"</span>) line = getLine(doc, clipLine(doc, handle));
    <span class="hljs-keyword">else</span> no = lineNo(handle);
    <span class="hljs-keyword">if</span> (no == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (op(line, no) &amp;&amp; doc.cm) regLineChange(doc.cm, no, changeType);
    <span class="hljs-keyword">return</span> line;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Helper for deleting text near the selection(s), used to implement
backspace, delete, and similar functionality.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteNearSelection</span>(<span class="hljs-params">cm, compute</span>) </span>{
    <span class="hljs-keyword">var</span> ranges = cm.doc.sel.ranges, kill = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build up a set of ranges to kill first, merging overlapping
ranges.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ranges.length; i++) {
      <span class="hljs-keyword">var</span> toKill = compute(ranges[i]);
      <span class="hljs-keyword">while</span> (kill.length &amp;&amp; cmp(toKill.from, lst(kill).to) &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> replaced = kill.pop();
        <span class="hljs-keyword">if</span> (cmp(replaced.from, toKill.from) &lt; <span class="hljs-number">0</span>) {
          toKill.from = replaced.from;
          <span class="hljs-keyword">break</span>;
        }
      }
      kill.push(toKill);
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Next, remove those actual ranges.</p></div></div><div class="code"><div class="wrapper">    runInOp(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = kill.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
        replaceRange(cm.doc, <span class="hljs-string">""</span>, kill[i].from, kill[i].to, <span class="hljs-string">"+delete"</span>);
      ensureCursorVisible(cm);
    });
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used for horizontal relative motion. Dir is -1 or 1 (left or
right), unit can be &quot;char&quot;, &quot;column&quot; (like char, but doesn&#39;t
cross line boundaries), &quot;word&quot; (across next word), or &quot;group&quot; (to
the start of next group of word or non-word-non-whitespace
chars). The visually param controls whether, in right-to-left
text, direction 1 means to move towards the next index in the
string, or towards the character to the right of the current
position. The resulting position will have a hitSide=true
property if it reached the end of the document.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findPosH</span>(<span class="hljs-params">doc, pos, dir, unit, visually</span>) </span>{
    <span class="hljs-keyword">var</span> line = pos.line, ch = pos.ch, origDir = dir;
    <span class="hljs-keyword">var</span> lineObj = getLine(doc, line);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findNextLine</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> l = line + dir;
      <span class="hljs-keyword">if</span> (l &lt; doc.first || l &gt;= doc.first + doc.size) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
      line = l;
      <span class="hljs-keyword">return</span> lineObj = getLine(doc, l);
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveOnce</span>(<span class="hljs-params">boundToLine</span>) </span>{
      <span class="hljs-keyword">var</span> next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, <span class="hljs-literal">true</span>);
      <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (!boundToLine &amp;&amp; findNextLine()) {
          <span class="hljs-keyword">if</span> (visually) ch = (dir &lt; <span class="hljs-number">0</span> ? lineRight : lineLeft)(lineObj);
          <span class="hljs-keyword">else</span> ch = dir &lt; <span class="hljs-number">0</span> ? lineObj.text.length : <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
      } <span class="hljs-keyword">else</span> ch = next;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (unit == <span class="hljs-string">"char"</span>) {
      moveOnce()
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unit == <span class="hljs-string">"column"</span>) {
      moveOnce(<span class="hljs-literal">true</span>)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unit == <span class="hljs-string">"word"</span> || unit == <span class="hljs-string">"group"</span>) {
      <span class="hljs-keyword">var</span> sawType = <span class="hljs-literal">null</span>, group = unit == <span class="hljs-string">"group"</span>;
      <span class="hljs-keyword">var</span> helper = doc.cm &amp;&amp; doc.cm.getHelper(pos, <span class="hljs-string">"wordChars"</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> first = <span class="hljs-literal">true</span>;; first = <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">if</span> (dir &lt; <span class="hljs-number">0</span> &amp;&amp; !moveOnce(!first)) <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">var</span> cur = lineObj.text.charAt(ch) || <span class="hljs-string">"\n"</span>;
        <span class="hljs-keyword">var</span> type = isWordChar(cur, helper) ? <span class="hljs-string">"w"</span>
          : group &amp;&amp; cur == <span class="hljs-string">"\n"</span> ? <span class="hljs-string">"n"</span>
          : !group || <span class="hljs-regexp">/\s/</span>.test(cur) ? <span class="hljs-literal">null</span>
          : <span class="hljs-string">"p"</span>;
        <span class="hljs-keyword">if</span> (group &amp;&amp; !first &amp;&amp; !type) type = <span class="hljs-string">"s"</span>;
        <span class="hljs-keyword">if</span> (sawType &amp;&amp; sawType != type) {
          <span class="hljs-keyword">if</span> (dir &lt; <span class="hljs-number">0</span>) {dir = <span class="hljs-number">1</span>; moveOnce();}
          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">if</span> (type) sawType = type;
        <span class="hljs-keyword">if</span> (dir &gt; <span class="hljs-number">0</span> &amp;&amp; !moveOnce(!first)) <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">var</span> result = skipAtomic(doc, Pos(line, ch), pos, origDir, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (!cmp(pos, result)) result.hitSide = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> result;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For relative vertical movement. Dir may be -1 or 1. Unit can be
&quot;page&quot; or &quot;line&quot;. The resulting position will have a hitSide=true
property if it reached the end of the document.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findPosV</span>(<span class="hljs-params">cm, pos, dir, unit</span>) </span>{
    <span class="hljs-keyword">var</span> doc = cm.doc, x = pos.left, y;
    <span class="hljs-keyword">if</span> (unit == <span class="hljs-string">"page"</span>) {
      <span class="hljs-keyword">var</span> pageSize = <span class="hljs-built_in">Math</span>.min(cm.display.wrapper.clientHeight, <span class="hljs-built_in">window</span>.innerHeight || <span class="hljs-built_in">document</span>.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1.5</span> : <span class="hljs-number">.5</span>) * textHeight(cm.display));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unit == <span class="hljs-string">"line"</span>) {
      y = dir &gt; <span class="hljs-number">0</span> ? pos.bottom + <span class="hljs-number">3</span> : pos.top - <span class="hljs-number">3</span>;
    }
    <span class="hljs-keyword">for</span> (;;) {
      <span class="hljs-keyword">var</span> target = coordsChar(cm, x, y);
      <span class="hljs-keyword">if</span> (!target.outside) <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">if</span> (dir &lt; <span class="hljs-number">0</span> ? y &lt;= <span class="hljs-number">0</span> : y &gt;= doc.height) { target.hitSide = <span class="hljs-literal">true</span>; <span class="hljs-keyword">break</span>; }
      y += dir * <span class="hljs-number">5</span>;
    }
    <span class="hljs-keyword">return</span> target;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>EDITOR METHODS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The publicly visible API. Note that methodOp(f) means
&#39;wrap f in an operation, performed on its <code>this</code> parameter&#39;.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is not the complete set of editor methods. Most of the
methods defined on the Doc type are also injected into
CodeMirror.prototype, for backwards compatibility and
convenience.</p></div></div><div class="code"><div class="wrapper">  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">window</span>.focus(); <span class="hljs-keyword">this</span>.display.input.focus();},

    setOption: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">option, value</span>) </span>{
      <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options, old = options[option];
      <span class="hljs-keyword">if</span> (options[option] == value &amp;&amp; option != <span class="hljs-string">"mode"</span>) <span class="hljs-keyword">return</span>;
      options[option] = value;
      <span class="hljs-keyword">if</span> (optionHandlers.hasOwnProperty(option))
        operation(<span class="hljs-keyword">this</span>, optionHandlers[option])(<span class="hljs-keyword">this</span>, value, old);
    },

    getOption: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">option</span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.options[option];},
    getDoc: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.doc;},

    addKeyMap: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">map, bottom</span>) </span>{
      <span class="hljs-keyword">this</span>.state.keyMaps[bottom ? <span class="hljs-string">"push"</span> : <span class="hljs-string">"unshift"</span>](getKeyMap(map));
    },
    removeKeyMap: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">map</span>) </span>{
      <span class="hljs-keyword">var</span> maps = <span class="hljs-keyword">this</span>.state.keyMaps;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; maps.length; ++i)
        <span class="hljs-keyword">if</span> (maps[i] == map || maps[i].name == map) {
          maps.splice(i, <span class="hljs-number">1</span>);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    },

    addOverlay: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">spec, options</span>) </span>{
      <span class="hljs-keyword">var</span> mode = spec.token ? spec : CodeMirror.getMode(<span class="hljs-keyword">this</span>.options, spec);
      <span class="hljs-keyword">if</span> (mode.startState) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Overlays may not be stateful."</span>);
      <span class="hljs-keyword">this</span>.state.overlays.push({mode: mode, modeSpec: spec, opaque: options &amp;&amp; options.opaque});
      <span class="hljs-keyword">this</span>.state.modeGen++;
      regChange(<span class="hljs-keyword">this</span>);
    }),
    removeOverlay: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">spec</span>) </span>{
      <span class="hljs-keyword">var</span> overlays = <span class="hljs-keyword">this</span>.state.overlays;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; overlays.length; ++i) {
        <span class="hljs-keyword">var</span> cur = overlays[i].modeSpec;
        <span class="hljs-keyword">if</span> (cur == spec || <span class="hljs-keyword">typeof</span> spec == <span class="hljs-string">"string"</span> &amp;&amp; cur.name == spec) {
          overlays.splice(i, <span class="hljs-number">1</span>);
          <span class="hljs-keyword">this</span>.state.modeGen++;
          regChange(<span class="hljs-keyword">this</span>);
          <span class="hljs-keyword">return</span>;
        }
      }
    }),

    indentLine: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, dir, aggressive</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> dir != <span class="hljs-string">"string"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> dir != <span class="hljs-string">"number"</span>) {
        <span class="hljs-keyword">if</span> (dir == <span class="hljs-literal">null</span>) dir = <span class="hljs-keyword">this</span>.options.smartIndent ? <span class="hljs-string">"smart"</span> : <span class="hljs-string">"prev"</span>;
        <span class="hljs-keyword">else</span> dir = dir ? <span class="hljs-string">"add"</span> : <span class="hljs-string">"subtract"</span>;
      }
      <span class="hljs-keyword">if</span> (isLine(<span class="hljs-keyword">this</span>.doc, n)) indentLine(<span class="hljs-keyword">this</span>, n, dir, aggressive);
    }),
    indentSelection: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">how</span>) </span>{
      <span class="hljs-keyword">var</span> ranges = <span class="hljs-keyword">this</span>.doc.sel.ranges, end = -<span class="hljs-number">1</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ranges.length; i++) {
        <span class="hljs-keyword">var</span> range = ranges[i];
        <span class="hljs-keyword">if</span> (!range.empty()) {
          <span class="hljs-keyword">var</span> from = range.from(), to = range.to();
          <span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Math</span>.max(end, from.line);
          end = <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.lastLine(), to.line - (to.ch ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = start; j &lt; end; ++j)
            indentLine(<span class="hljs-keyword">this</span>, j, how);
          <span class="hljs-keyword">var</span> newRanges = <span class="hljs-keyword">this</span>.doc.sel.ranges;
          <span class="hljs-keyword">if</span> (from.ch == <span class="hljs-number">0</span> &amp;&amp; ranges.length == newRanges.length &amp;&amp; newRanges[i].from().ch &gt; <span class="hljs-number">0</span>)
            replaceOneSelection(<span class="hljs-keyword">this</span>.doc, i, <span class="hljs-keyword">new</span> Range(from, newRanges[i].to()), sel_dontScroll);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (range.head.line &gt; end) {
          indentLine(<span class="hljs-keyword">this</span>, range.head.line, how, <span class="hljs-literal">true</span>);
          end = range.head.line;
          <span class="hljs-keyword">if</span> (i == <span class="hljs-keyword">this</span>.doc.sel.primIndex) ensureCursorVisible(<span class="hljs-keyword">this</span>);
        }
      }
    }),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fetch the parser token for a given character. Useful for hacks
that want to inspect the mode state (say, for completion).</p></div></div><div class="code"><div class="wrapper">    getTokenAt: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, precise</span>) </span>{
      <span class="hljs-keyword">return</span> takeToken(<span class="hljs-keyword">this</span>, pos, precise);
    },

    getLineTokens: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line, precise</span>) </span>{
      <span class="hljs-keyword">return</span> takeToken(<span class="hljs-keyword">this</span>, Pos(line), precise, <span class="hljs-literal">true</span>);
    },

    getTokenTypeAt: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
      pos = clipPos(<span class="hljs-keyword">this</span>.doc, pos);
      <span class="hljs-keyword">var</span> styles = getLineStyles(<span class="hljs-keyword">this</span>, getLine(<span class="hljs-keyword">this</span>.doc, pos.line));
      <span class="hljs-keyword">var</span> before = <span class="hljs-number">0</span>, after = (styles.length - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, ch = pos.ch;
      <span class="hljs-keyword">var</span> type;
      <span class="hljs-keyword">if</span> (ch == <span class="hljs-number">0</span>) type = styles[<span class="hljs-number">2</span>];
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span> (;;) {
        <span class="hljs-keyword">var</span> mid = (before + after) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> ((mid ? styles[mid * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>) &gt;= ch) after = mid;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (styles[mid * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; ch) before = mid + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> { type = styles[mid * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>]; <span class="hljs-keyword">break</span>; }
      }
      <span class="hljs-keyword">var</span> cut = type ? type.indexOf(<span class="hljs-string">"cm-overlay "</span>) : -<span class="hljs-number">1</span>;
      <span class="hljs-keyword">return</span> cut &lt; <span class="hljs-number">0</span> ? type : cut == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : type.slice(<span class="hljs-number">0</span>, cut - <span class="hljs-number">1</span>);
    },

    getModeAt: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
      <span class="hljs-keyword">var</span> mode = <span class="hljs-keyword">this</span>.doc.mode;
      <span class="hljs-keyword">if</span> (!mode.innerMode) <span class="hljs-keyword">return</span> mode;
      <span class="hljs-keyword">return</span> CodeMirror.innerMode(mode, <span class="hljs-keyword">this</span>.getTokenAt(pos).state).mode;
    },

    getHelper: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, type</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getHelpers(pos, type)[<span class="hljs-number">0</span>];
    },

    getHelpers: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, type</span>) </span>{
      <span class="hljs-keyword">var</span> found = [];
      <span class="hljs-keyword">if</span> (!helpers.hasOwnProperty(type)) <span class="hljs-keyword">return</span> found;
      <span class="hljs-keyword">var</span> help = helpers[type], mode = <span class="hljs-keyword">this</span>.getModeAt(pos);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> mode[type] == <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">if</span> (help[mode[type]]) found.push(help[mode[type]]);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode[type]) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; mode[type].length; i++) {
          <span class="hljs-keyword">var</span> val = help[mode[type][i]];
          <span class="hljs-keyword">if</span> (val) found.push(val);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode.helperType &amp;&amp; help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (help[mode.name]) {
        found.push(help[mode.name]);
      }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; help._global.length; i++) {
        <span class="hljs-keyword">var</span> cur = help._global[i];
        <span class="hljs-keyword">if</span> (cur.pred(mode, <span class="hljs-keyword">this</span>) &amp;&amp; indexOf(found, cur.val) == -<span class="hljs-number">1</span>)
          found.push(cur.val);
      }
      <span class="hljs-keyword">return</span> found;
    },

    getStateAfter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line, precise</span>) </span>{
      <span class="hljs-keyword">var</span> doc = <span class="hljs-keyword">this</span>.doc;
      line = clipLine(doc, line == <span class="hljs-literal">null</span> ? doc.first + doc.size - <span class="hljs-number">1</span>: line);
      <span class="hljs-keyword">return</span> getStateBefore(<span class="hljs-keyword">this</span>, line + <span class="hljs-number">1</span>, precise);
    },

    cursorCoords: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">start, mode</span>) </span>{
      <span class="hljs-keyword">var</span> pos, range = <span class="hljs-keyword">this</span>.doc.sel.primary();
      <span class="hljs-keyword">if</span> (start == <span class="hljs-literal">null</span>) pos = range.head;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> start == <span class="hljs-string">"object"</span>) pos = clipPos(<span class="hljs-keyword">this</span>.doc, start);
      <span class="hljs-keyword">else</span> pos = start ? range.from() : range.to();
      <span class="hljs-keyword">return</span> cursorCoords(<span class="hljs-keyword">this</span>, pos, mode || <span class="hljs-string">"page"</span>);
    },

    charCoords: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, mode</span>) </span>{
      <span class="hljs-keyword">return</span> charCoords(<span class="hljs-keyword">this</span>, clipPos(<span class="hljs-keyword">this</span>.doc, pos), mode || <span class="hljs-string">"page"</span>);
    },

    coordsChar: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">coords, mode</span>) </span>{
      coords = fromCoordSystem(<span class="hljs-keyword">this</span>, coords, mode || <span class="hljs-string">"page"</span>);
      <span class="hljs-keyword">return</span> coordsChar(<span class="hljs-keyword">this</span>, coords.left, coords.top);
    },

    lineAtHeight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">height, mode</span>) </span>{
      height = fromCoordSystem(<span class="hljs-keyword">this</span>, {top: height, left: <span class="hljs-number">0</span>}, mode || <span class="hljs-string">"page"</span>).top;
      <span class="hljs-keyword">return</span> lineAtHeight(<span class="hljs-keyword">this</span>.doc, height + <span class="hljs-keyword">this</span>.display.viewOffset);
    },
    heightAtLine: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line, mode</span>) </span>{
      <span class="hljs-keyword">var</span> end = <span class="hljs-literal">false</span>, lineObj;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> line == <span class="hljs-string">"number"</span>) {
        <span class="hljs-keyword">var</span> last = <span class="hljs-keyword">this</span>.doc.first + <span class="hljs-keyword">this</span>.doc.size - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (line &lt; <span class="hljs-keyword">this</span>.doc.first) line = <span class="hljs-keyword">this</span>.doc.first;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line &gt; last) { line = last; end = <span class="hljs-literal">true</span>; }
        lineObj = getLine(<span class="hljs-keyword">this</span>.doc, line);
      } <span class="hljs-keyword">else</span> {
        lineObj = line;
      }
      <span class="hljs-keyword">return</span> intoCoordSystem(<span class="hljs-keyword">this</span>, lineObj, {top: <span class="hljs-number">0</span>, left: <span class="hljs-number">0</span>}, mode || <span class="hljs-string">"page"</span>).top +
        (end ? <span class="hljs-keyword">this</span>.doc.height - heightAtLine(lineObj) : <span class="hljs-number">0</span>);
    },

    defaultTextHeight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> textHeight(<span class="hljs-keyword">this</span>.display); },
    defaultCharWidth: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> charWidth(<span class="hljs-keyword">this</span>.display); },

    setGutterMarker: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line, gutterID, value</span>) </span>{
      <span class="hljs-keyword">return</span> changeLine(<span class="hljs-keyword">this</span>.doc, line, <span class="hljs-string">"gutter"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">var</span> markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        <span class="hljs-keyword">if</span> (!value &amp;&amp; isEmpty(markers)) line.gutterMarkers = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      });
    }),

    clearGutter: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">gutterID</span>) </span>{
      <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>, doc = cm.doc, i = doc.first;
      doc.iter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">if</span> (line.gutterMarkers &amp;&amp; line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = <span class="hljs-literal">null</span>;
          regLineChange(cm, i, <span class="hljs-string">"gutter"</span>);
          <span class="hljs-keyword">if</span> (isEmpty(line.gutterMarkers)) line.gutterMarkers = <span class="hljs-literal">null</span>;
        }
        ++i;
      });
    }),

    lineInfo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> line == <span class="hljs-string">"number"</span>) {
        <span class="hljs-keyword">if</span> (!isLine(<span class="hljs-keyword">this</span>.doc, line)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> n = line;
        line = getLine(<span class="hljs-keyword">this</span>.doc, line);
        <span class="hljs-keyword">if</span> (!line) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> n = lineNo(line);
        <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">return</span> {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> {from: <span class="hljs-keyword">this</span>.display.viewFrom, to: <span class="hljs-keyword">this</span>.display.viewTo};},

    addWidget: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, node, scroll, vert, horiz</span>) </span>{
      <span class="hljs-keyword">var</span> display = <span class="hljs-keyword">this</span>.display;
      pos = cursorCoords(<span class="hljs-keyword">this</span>, clipPos(<span class="hljs-keyword">this</span>.doc, pos));
      <span class="hljs-keyword">var</span> top = pos.bottom, left = pos.left;
      node.style.position = <span class="hljs-string">"absolute"</span>;
      node.setAttribute(<span class="hljs-string">"cm-ignore-events"</span>, <span class="hljs-string">"true"</span>);
      <span class="hljs-keyword">this</span>.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      <span class="hljs-keyword">if</span> (vert == <span class="hljs-string">"over"</span>) {
        top = pos.top;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vert == <span class="hljs-string">"above"</span> || vert == <span class="hljs-string">"near"</span>) {
        <span class="hljs-keyword">var</span> vspace = <span class="hljs-built_in">Math</span>.max(display.wrapper.clientHeight, <span class="hljs-keyword">this</span>.doc.height),
        hspace = <span class="hljs-built_in">Math</span>.max(display.sizer.clientWidth, display.lineSpace.clientWidth);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Default to positioning above (if specified and possible); otherwise default to positioning below</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> ((vert == <span class="hljs-string">'above'</span> || pos.bottom + node.offsetHeight &gt; vspace) &amp;&amp; pos.top &gt; node.offsetHeight)
          top = pos.top - node.offsetHeight;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pos.bottom + node.offsetHeight &lt;= vspace)
          top = pos.bottom;
        <span class="hljs-keyword">if</span> (left + node.offsetWidth &gt; hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + <span class="hljs-string">"px"</span>;
      node.style.left = node.style.right = <span class="hljs-string">""</span>;
      <span class="hljs-keyword">if</span> (horiz == <span class="hljs-string">"right"</span>) {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = <span class="hljs-string">"0px"</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (horiz == <span class="hljs-string">"left"</span>) left = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (horiz == <span class="hljs-string">"middle"</span>) left = (display.sizer.clientWidth - node.offsetWidth) / <span class="hljs-number">2</span>;
        node.style.left = left + <span class="hljs-string">"px"</span>;
      }
      <span class="hljs-keyword">if</span> (scroll)
        scrollIntoView(<span class="hljs-keyword">this</span>, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,

    execCommand: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cmd</span>) </span>{
      <span class="hljs-keyword">if</span> (commands.hasOwnProperty(cmd))
        <span class="hljs-keyword">return</span> commands[cmd].call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>);
    },

    triggerElectric: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>{ triggerElectric(<span class="hljs-keyword">this</span>, text); }),

    findPosH: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, amount, unit, visually</span>) </span>{
      <span class="hljs-keyword">var</span> dir = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">0</span>) { dir = -<span class="hljs-number">1</span>; amount = -amount; }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, cur = clipPos(<span class="hljs-keyword">this</span>.doc, from); i &lt; amount; ++i) {
        cur = findPosH(<span class="hljs-keyword">this</span>.doc, cur, dir, unit, visually);
        <span class="hljs-keyword">if</span> (cur.hitSide) <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">return</span> cur;
    },

    moveH: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dir, unit</span>) </span>{
      <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>;
      cm.extendSelectionsBy(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">if</span> (cm.display.shift || cm.doc.extend || range.empty())
          <span class="hljs-keyword">return</span> findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        <span class="hljs-keyword">else</span>
          <span class="hljs-keyword">return</span> dir &lt; <span class="hljs-number">0</span> ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dir, unit</span>) </span>{
      <span class="hljs-keyword">var</span> sel = <span class="hljs-keyword">this</span>.doc.sel, doc = <span class="hljs-keyword">this</span>.doc;
      <span class="hljs-keyword">if</span> (sel.somethingSelected())
        doc.replaceSelection(<span class="hljs-string">""</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"+delete"</span>);
      <span class="hljs-keyword">else</span>
        deleteNearSelection(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
          <span class="hljs-keyword">var</span> other = findPosH(doc, range.head, dir, unit, <span class="hljs-literal">false</span>);
          <span class="hljs-keyword">return</span> dir &lt; <span class="hljs-number">0</span> ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, amount, unit, goalColumn</span>) </span>{
      <span class="hljs-keyword">var</span> dir = <span class="hljs-number">1</span>, x = goalColumn;
      <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">0</span>) { dir = -<span class="hljs-number">1</span>; amount = -amount; }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, cur = clipPos(<span class="hljs-keyword">this</span>.doc, from); i &lt; amount; ++i) {
        <span class="hljs-keyword">var</span> coords = cursorCoords(<span class="hljs-keyword">this</span>, cur, <span class="hljs-string">"div"</span>);
        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) x = coords.left;
        <span class="hljs-keyword">else</span> coords.left = x;
        cur = findPosV(<span class="hljs-keyword">this</span>, coords, dir, unit);
        <span class="hljs-keyword">if</span> (cur.hitSide) <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">return</span> cur;
    },

    moveV: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dir, unit</span>) </span>{
      <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>, doc = <span class="hljs-keyword">this</span>.doc, goals = [];
      <span class="hljs-keyword">var</span> collapse = !cm.display.shift &amp;&amp; !doc.extend &amp;&amp; doc.sel.somethingSelected();
      doc.extendSelectionsBy(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">if</span> (collapse)
          <span class="hljs-keyword">return</span> dir &lt; <span class="hljs-number">0</span> ? range.from() : range.to();
        <span class="hljs-keyword">var</span> headPos = cursorCoords(cm, range.head, <span class="hljs-string">"div"</span>);
        <span class="hljs-keyword">if</span> (range.goalColumn != <span class="hljs-literal">null</span>) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        <span class="hljs-keyword">var</span> pos = findPosV(cm, headPos, dir, unit);
        <span class="hljs-keyword">if</span> (unit == <span class="hljs-string">"page"</span> &amp;&amp; range == doc.sel.primary())
          addToScrollPos(cm, <span class="hljs-literal">null</span>, charCoords(cm, pos, <span class="hljs-string">"div"</span>).top - headPos.top);
        <span class="hljs-keyword">return</span> pos;
      }, sel_move);
      <span class="hljs-keyword">if</span> (goals.length) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the word at the given position (as returned by coordsChar).</p></div></div><div class="code"><div class="wrapper">    findWordAt: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
      <span class="hljs-keyword">var</span> doc = <span class="hljs-keyword">this</span>.doc, line = getLine(doc, pos.line).text;
      <span class="hljs-keyword">var</span> start = pos.ch, end = pos.ch;
      <span class="hljs-keyword">if</span> (line) {
        <span class="hljs-keyword">var</span> helper = <span class="hljs-keyword">this</span>.getHelper(pos, <span class="hljs-string">"wordChars"</span>);
        <span class="hljs-keyword">if</span> ((pos.xRel &lt; <span class="hljs-number">0</span> || end == line.length) &amp;&amp; start) --start; <span class="hljs-keyword">else</span> ++end;
        <span class="hljs-keyword">var</span> startChar = line.charAt(start);
        <span class="hljs-keyword">var</span> check = isWordChar(startChar, helper)
          ? <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ch</span>) </span>{ <span class="hljs-keyword">return</span> isWordChar(ch, helper); }
          : <span class="hljs-regexp">/\s/</span>.test(startChar) ? <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ch</span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-regexp">/\s/</span>.test(ch);}
          : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ch</span>) </span>{<span class="hljs-keyword">return</span> !<span class="hljs-regexp">/\s/</span>.test(ch) &amp;&amp; !isWordChar(ch);};
        <span class="hljs-keyword">while</span> (start &gt; <span class="hljs-number">0</span> &amp;&amp; check(line.charAt(start - <span class="hljs-number">1</span>))) --start;
        <span class="hljs-keyword">while</span> (end &lt; line.length &amp;&amp; check(line.charAt(end))) ++end;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Range(Pos(pos.line, start), Pos(pos.line, end));
    },

    toggleOverwrite: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span> &amp;&amp; value == <span class="hljs-keyword">this</span>.state.overwrite) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.overwrite = !<span class="hljs-keyword">this</span>.state.overwrite)
        addClass(<span class="hljs-keyword">this</span>.display.cursorDiv, <span class="hljs-string">"CodeMirror-overwrite"</span>);
      <span class="hljs-keyword">else</span>
        rmClass(<span class="hljs-keyword">this</span>.display.cursorDiv, <span class="hljs-string">"CodeMirror-overwrite"</span>);

      signal(<span class="hljs-keyword">this</span>, <span class="hljs-string">"overwriteToggle"</span>, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.state.overwrite);
    },
    hasFocus: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.display.input.getField() == activeElt(); },
    isReadOnly: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> !!(<span class="hljs-keyword">this</span>.options.readOnly || <span class="hljs-keyword">this</span>.doc.cantEdit); },

    scrollTo: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>{
      <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span> || y != <span class="hljs-literal">null</span>) resolveScrollToPos(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span>) <span class="hljs-keyword">this</span>.curOp.scrollLeft = x;
      <span class="hljs-keyword">if</span> (y != <span class="hljs-literal">null</span>) <span class="hljs-keyword">this</span>.curOp.scrollTop = y;
    }),
    getScrollInfo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> scroller = <span class="hljs-keyword">this</span>.display.scroller;
      <span class="hljs-keyword">return</span> {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(<span class="hljs-keyword">this</span>) - <span class="hljs-keyword">this</span>.display.barHeight,
              width: scroller.scrollWidth - scrollGap(<span class="hljs-keyword">this</span>) - <span class="hljs-keyword">this</span>.display.barWidth,
              clientHeight: displayHeight(<span class="hljs-keyword">this</span>), clientWidth: displayWidth(<span class="hljs-keyword">this</span>)};
    },

    scrollIntoView: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range, margin</span>) </span>{
      <span class="hljs-keyword">if</span> (range == <span class="hljs-literal">null</span>) {
        range = {from: <span class="hljs-keyword">this</span>.doc.sel.primary().head, to: <span class="hljs-literal">null</span>};
        <span class="hljs-keyword">if</span> (margin == <span class="hljs-literal">null</span>) margin = <span class="hljs-keyword">this</span>.options.cursorScrollMargin;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> range == <span class="hljs-string">"number"</span>) {
        range = {from: Pos(range, <span class="hljs-number">0</span>), to: <span class="hljs-literal">null</span>};
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (range.from == <span class="hljs-literal">null</span>) {
        range = {from: range, to: <span class="hljs-literal">null</span>};
      }
      <span class="hljs-keyword">if</span> (!range.to) range.to = range.from;
      range.margin = margin || <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (range.from.line != <span class="hljs-literal">null</span>) {
        resolveScrollToPos(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">this</span>.curOp.scrollToPos = range;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> sPos = calculateScrollPos(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Math</span>.min(range.from.left, range.to.left),
                                      <span class="hljs-built_in">Math</span>.min(range.from.top, range.to.top) - range.margin,
                                      <span class="hljs-built_in">Math</span>.max(range.from.right, range.to.right),
                                      <span class="hljs-built_in">Math</span>.max(range.from.bottom, range.to.bottom) + range.margin);
        <span class="hljs-keyword">this</span>.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">width, height</span>) </span>{
      <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>;
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">interpret</span>(<span class="hljs-params">val</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val == <span class="hljs-string">"number"</span> || <span class="hljs-regexp">/^\d+$/</span>.test(<span class="hljs-built_in">String</span>(val)) ? val + <span class="hljs-string">"px"</span> : val;
      }
      <span class="hljs-keyword">if</span> (width != <span class="hljs-literal">null</span>) cm.display.wrapper.style.width = interpret(width);
      <span class="hljs-keyword">if</span> (height != <span class="hljs-literal">null</span>) cm.display.wrapper.style.height = interpret(height);
      <span class="hljs-keyword">if</span> (cm.options.lineWrapping) clearLineMeasurementCache(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">var</span> lineNo = cm.display.viewFrom;
      cm.doc.iter(lineNo, cm.display.viewTo, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">if</span> (line.widgets) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; line.widgets.length; i++)
          <span class="hljs-keyword">if</span> (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, <span class="hljs-string">"widget"</span>); <span class="hljs-keyword">break</span>; }
        ++lineNo;
      });
      cm.curOp.forceUpdate = <span class="hljs-literal">true</span>;
      signal(cm, <span class="hljs-string">"refresh"</span>, <span class="hljs-keyword">this</span>);
    }),

    operation: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>)</span>{<span class="hljs-keyword">return</span> runInOp(<span class="hljs-keyword">this</span>, f);},

    refresh: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> oldHeight = <span class="hljs-keyword">this</span>.display.cachedTextHeight;
      regChange(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.curOp.forceUpdate = <span class="hljs-literal">true</span>;
      clearCaches(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.scrollTo(<span class="hljs-keyword">this</span>.doc.scrollLeft, <span class="hljs-keyword">this</span>.doc.scrollTop);
      updateGutterSpace(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">if</span> (oldHeight == <span class="hljs-literal">null</span> || <span class="hljs-built_in">Math</span>.abs(oldHeight - textHeight(<span class="hljs-keyword">this</span>.display)) &gt; <span class="hljs-number">.5</span>)
        estimateLineHeights(<span class="hljs-keyword">this</span>);
      signal(<span class="hljs-keyword">this</span>, <span class="hljs-string">"refresh"</span>, <span class="hljs-keyword">this</span>);
    }),

    swapDoc: methodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
      <span class="hljs-keyword">var</span> old = <span class="hljs-keyword">this</span>.doc;
      old.cm = <span class="hljs-literal">null</span>;
      attachDoc(<span class="hljs-keyword">this</span>, doc);
      clearCaches(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.display.input.reset();
      <span class="hljs-keyword">this</span>.scrollTo(doc.scrollLeft, doc.scrollTop);
      <span class="hljs-keyword">this</span>.curOp.forceScroll = <span class="hljs-literal">true</span>;
      signalLater(<span class="hljs-keyword">this</span>, <span class="hljs-string">"swapDoc"</span>, <span class="hljs-keyword">this</span>, old);
      <span class="hljs-keyword">return</span> old;
    }),

    getInputField: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.display.input.getField();},
    getWrapperElement: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.display.wrapper;},
    getScrollerElement: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.display.scroller;},
    getGutterElement: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.display.gutters;}
  };
  eventMixin(CodeMirror);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>OPTION DEFAULTS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The default configuration options.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> defaults = CodeMirror.defaults = {};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Functions to run when options are changed.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> optionHandlers = CodeMirror.optionHandlers = {};

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">option</span>(<span class="hljs-params">name, deflt, handle, notOnInit</span>) </span>{
    CodeMirror.defaults[name] = deflt;
    <span class="hljs-keyword">if</span> (handle) optionHandlers[name] =
      notOnInit ? <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val, old</span>) </span>{<span class="hljs-keyword">if</span> (old != Init) handle(cm, val, old);} : handle;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Passed to option handlers when there is no old value.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> Init = CodeMirror.Init = {toString: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-string">"CodeMirror.Init"</span>;}};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>These two are, on init, called from the constructor because they
have to be initialized before the editor can start at all.</p></div></div><div class="code"><div class="wrapper">  option(<span class="hljs-string">"value"</span>, <span class="hljs-string">""</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val</span>) </span>{
    cm.setValue(val);
  }, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"mode"</span>, <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val</span>) </span>{
    cm.doc.modeOption = val;
    loadMode(cm);
  }, <span class="hljs-literal">true</span>);

  option(<span class="hljs-string">"indentUnit"</span>, <span class="hljs-number">2</span>, loadMode, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"indentWithTabs"</span>, <span class="hljs-literal">false</span>);
  option(<span class="hljs-string">"smartIndent"</span>, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"tabSize"</span>, <span class="hljs-number">4</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"lineSeparator"</span>, <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val</span>) </span>{
    cm.doc.lineSep = val;
    <span class="hljs-keyword">if</span> (!val) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> newBreaks = [], lineNo = cm.doc.first;
    cm.doc.iter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> pos = <span class="hljs-number">0</span>;;) {
        <span class="hljs-keyword">var</span> found = line.text.indexOf(val, pos);
        <span class="hljs-keyword">if</span> (found == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;
        pos = found + val.length;
        newBreaks.push(Pos(lineNo, found));
      }
      lineNo++;
    });
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = newBreaks.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))
  });
  option(<span class="hljs-string">"specialChars"</span>, <span class="hljs-regexp">/[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val, old</span>) </span>{
    cm.state.specialChars = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(val.source + (val.test(<span class="hljs-string">"\t"</span>) ? <span class="hljs-string">""</span> : <span class="hljs-string">"|\t"</span>), <span class="hljs-string">"g"</span>);
    <span class="hljs-keyword">if</span> (old != CodeMirror.Init) cm.refresh();
  });
  option(<span class="hljs-string">"specialCharPlaceholder"</span>, defaultSpecialCharPlaceholder, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.refresh();}, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"electricChars"</span>, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"inputStyle"</span>, mobile ? <span class="hljs-string">"contenteditable"</span> : <span class="hljs-string">"textarea"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"inputStyle can not (yet) be changed in a running editor"</span>); <span class="hljs-comment">// FIXME</span>
  }, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"rtlMoveVisually"</span>, !windows);
  option(<span class="hljs-string">"wholeLineUpdateBefore"</span>, <span class="hljs-literal">true</span>);

  option(<span class="hljs-string">"theme"</span>, <span class="hljs-string">"default"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
    themeChanged(cm);
    guttersChanged(cm);
  }, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"keyMap"</span>, <span class="hljs-string">"default"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val, old</span>) </span>{
    <span class="hljs-keyword">var</span> next = getKeyMap(val);
    <span class="hljs-keyword">var</span> prev = old != CodeMirror.Init &amp;&amp; getKeyMap(old);
    <span class="hljs-keyword">if</span> (prev &amp;&amp; prev.detach) prev.detach(cm, next);
    <span class="hljs-keyword">if</span> (next.attach) next.attach(cm, prev || <span class="hljs-literal">null</span>);
  });
  option(<span class="hljs-string">"extraKeys"</span>, <span class="hljs-literal">null</span>);

  option(<span class="hljs-string">"lineWrapping"</span>, <span class="hljs-literal">false</span>, wrappingChanged, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"gutters"</span>, [], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"fixedGutter"</span>, <span class="hljs-literal">true</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val</span>) </span>{
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + <span class="hljs-string">"px"</span> : <span class="hljs-string">"0"</span>;
    cm.refresh();
  }, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"coverGutterNextToScrollbar"</span>, <span class="hljs-literal">false</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{updateScrollbars(cm);}, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"scrollbarStyle"</span>, <span class="hljs-string">"native"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"lineNumbers"</span>, <span class="hljs-literal">false</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"firstLineNumber"</span>, <span class="hljs-number">1</span>, guttersChanged, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"lineNumberFormatter"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">integer</span>) </span>{<span class="hljs-keyword">return</span> integer;}, guttersChanged, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"showCursorWhenSelecting"</span>, <span class="hljs-literal">false</span>, updateSelection, <span class="hljs-literal">true</span>);

  option(<span class="hljs-string">"resetSelectionOnContextMenu"</span>, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"lineWiseCopyCut"</span>, <span class="hljs-literal">true</span>);

  option(<span class="hljs-string">"readOnly"</span>, <span class="hljs-literal">false</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val</span>) </span>{
    <span class="hljs-keyword">if</span> (val == <span class="hljs-string">"nocursor"</span>) {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> {
      cm.display.disabled = <span class="hljs-literal">false</span>;
    }
    cm.display.input.readOnlyChanged(val)
  });
  option(<span class="hljs-string">"disableInput"</span>, <span class="hljs-literal">false</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val</span>) </span>{<span class="hljs-keyword">if</span> (!val) cm.display.input.reset();}, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"dragDrop"</span>, <span class="hljs-literal">true</span>, dragDropChanged);
  option(<span class="hljs-string">"allowDropFileTypes"</span>, <span class="hljs-literal">null</span>);

  option(<span class="hljs-string">"cursorBlinkRate"</span>, <span class="hljs-number">530</span>);
  option(<span class="hljs-string">"cursorScrollMargin"</span>, <span class="hljs-number">0</span>);
  option(<span class="hljs-string">"cursorHeight"</span>, <span class="hljs-number">1</span>, updateSelection, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"singleCursorHeightPerLine"</span>, <span class="hljs-literal">true</span>, updateSelection, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"workTime"</span>, <span class="hljs-number">100</span>);
  option(<span class="hljs-string">"workDelay"</span>, <span class="hljs-number">100</span>);
  option(<span class="hljs-string">"flattenSpans"</span>, <span class="hljs-literal">true</span>, resetModeState, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"addModeClass"</span>, <span class="hljs-literal">false</span>, resetModeState, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"pollInterval"</span>, <span class="hljs-number">100</span>);
  option(<span class="hljs-string">"undoDepth"</span>, <span class="hljs-number">200</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val</span>)</span>{cm.doc.history.undoDepth = val;});
  option(<span class="hljs-string">"historyEventDelay"</span>, <span class="hljs-number">1250</span>);
  option(<span class="hljs-string">"viewportMargin"</span>, <span class="hljs-number">10</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>)</span>{cm.refresh();}, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"maxHighlightLength"</span>, <span class="hljs-number">10000</span>, resetModeState, <span class="hljs-literal">true</span>);
  option(<span class="hljs-string">"moveInputWithCursor"</span>, <span class="hljs-literal">true</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val</span>) </span>{
    <span class="hljs-keyword">if</span> (!val) cm.display.input.resetPosition();
  });

  option(<span class="hljs-string">"tabindex"</span>, <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm, val</span>) </span>{
    cm.display.input.getField().tabIndex = val || <span class="hljs-string">""</span>;
  });
  option(<span class="hljs-string">"autofocus"</span>, <span class="hljs-literal">null</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>MODE DEFINITION AND QUERYING</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Known modes, by name and by MIME</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extra arguments are stored as the mode&#39;s dependencies, which is
used by (legacy) mechanisms like loadmode.js to automatically
load a mode. (Preferred mechanism is the require/define calls.)</p></div></div><div class="code"><div class="wrapper">  CodeMirror.defineMode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, mode</span>) </span>{
    <span class="hljs-keyword">if</span> (!CodeMirror.defaults.mode &amp;&amp; name != <span class="hljs-string">"null"</span>) CodeMirror.defaults.mode = name;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span>)
      mode.dependencies = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);
    modes[name] = mode;
  };

  CodeMirror.defineMIME = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mime, spec</span>) </span>{
    mimeModes[mime] = spec;
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a MIME type, a {name, ...options} config object, or a name
string, return a mode config object.</p></div></div><div class="code"><div class="wrapper">  CodeMirror.resolveMode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">spec</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> spec == <span class="hljs-string">"string"</span> &amp;&amp; mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (spec &amp;&amp; <span class="hljs-keyword">typeof</span> spec.name == <span class="hljs-string">"string"</span> &amp;&amp; mimeModes.hasOwnProperty(spec.name)) {
      <span class="hljs-keyword">var</span> found = mimeModes[spec.name];
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> found == <span class="hljs-string">"string"</span>) found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> spec == <span class="hljs-string">"string"</span> &amp;&amp; <span class="hljs-regexp">/^[\w\-]+\/[\w\-]+\+xml$/</span>.test(spec)) {
      <span class="hljs-keyword">return</span> CodeMirror.resolveMode(<span class="hljs-string">"application/xml"</span>);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> spec == <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> {name: spec};
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> spec || {name: <span class="hljs-string">"null"</span>};
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a mode spec (anything that resolveMode accepts), find and
initialize an actual mode object.</p></div></div><div class="code"><div class="wrapper">  CodeMirror.getMode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options, spec</span>) </span>{
    <span class="hljs-keyword">var</span> spec = CodeMirror.resolveMode(spec);
    <span class="hljs-keyword">var</span> mfactory = modes[spec.name];
    <span class="hljs-keyword">if</span> (!mfactory) <span class="hljs-keyword">return</span> CodeMirror.getMode(options, <span class="hljs-string">"text/plain"</span>);
    <span class="hljs-keyword">var</span> modeObj = mfactory(options, spec);
    <span class="hljs-keyword">if</span> (modeExtensions.hasOwnProperty(spec.name)) {
      <span class="hljs-keyword">var</span> exts = modeExtensions[spec.name];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> exts) {
        <span class="hljs-keyword">if</span> (!exts.hasOwnProperty(prop)) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span> (modeObj.hasOwnProperty(prop)) modeObj[<span class="hljs-string">"_"</span> + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    <span class="hljs-keyword">if</span> (spec.helperType) modeObj.helperType = spec.helperType;
    <span class="hljs-keyword">if</span> (spec.modeProps) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    <span class="hljs-keyword">return</span> modeObj;
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Minimal default mode.</p></div></div><div class="code"><div class="wrapper">  CodeMirror.defineMode(<span class="hljs-string">"null"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> {token: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stream</span>) </span>{stream.skipToEnd();}};
  });
  CodeMirror.defineMIME(<span class="hljs-string">"text/plain"</span>, <span class="hljs-string">"null"</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This can be used to attach properties to mode objects from
outside the actual mode definition.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mode, properties</span>) </span>{
    <span class="hljs-keyword">var</span> exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>EXTENSIONS</p></div></div><div class="code"><div class="wrapper">  CodeMirror.defineExtension = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, func</span>) </span>{
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, func</span>) </span>{
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  <span class="hljs-keyword">var</span> initHooks = [];
  CodeMirror.defineInitHook = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>) </span>{initHooks.push(f);};

  <span class="hljs-keyword">var</span> helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, name, value</span>) </span>{
    <span class="hljs-keyword">if</span> (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, name, predicate, value</span>) </span>{
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>MODE STATE HANDLING</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Utility functions for working with state. Exported because nested
modes need to do this for their inner modes.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> copyState = CodeMirror.copyState = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mode, state</span>) </span>{
    <span class="hljs-keyword">if</span> (state === <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span> state;
    <span class="hljs-keyword">if</span> (mode.copyState) <span class="hljs-keyword">return</span> mode.copyState(state);
    <span class="hljs-keyword">var</span> nstate = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> state) {
      <span class="hljs-keyword">var</span> val = state[n];
      <span class="hljs-keyword">if</span> (val <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) val = val.concat([]);
      nstate[n] = val;
    }
    <span class="hljs-keyword">return</span> nstate;
  };

  <span class="hljs-keyword">var</span> startState = CodeMirror.startState = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mode, a1, a2</span>) </span>{
    <span class="hljs-keyword">return</span> mode.startState ? mode.startState(a1, a2) : <span class="hljs-literal">true</span>;
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a mode and a state (for that mode), find the inner mode and
state at the position that the state refers to.</p></div></div><div class="code"><div class="wrapper">  CodeMirror.innerMode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mode, state</span>) </span>{
    <span class="hljs-keyword">while</span> (mode.innerMode) {
      <span class="hljs-keyword">var</span> info = mode.innerMode(state);
      <span class="hljs-keyword">if</span> (!info || info.mode == mode) <span class="hljs-keyword">break</span>;
      state = info.state;
      mode = info.mode;
    }
    <span class="hljs-keyword">return</span> info || {mode: mode, state: state};
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>STANDARD COMMANDS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Commands are parameter-less actions that can be performed on an
editor, mostly used for keybindings.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> commands = CodeMirror.commands = {
    selectAll: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.setSelection(Pos(cm.firstLine(), <span class="hljs-number">0</span>), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      cm.setSelection(cm.getCursor(<span class="hljs-string">"anchor"</span>), cm.getCursor(<span class="hljs-string">"head"</span>), sel_dontScroll);
    },
    killLine: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      deleteNearSelection(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">if</span> (range.empty()) {
          <span class="hljs-keyword">var</span> len = getLine(cm.doc, range.head.line).text.length;
          <span class="hljs-keyword">if</span> (range.head.ch == len &amp;&amp; range.head.line &lt; cm.lastLine())
            <span class="hljs-keyword">return</span> {from: range.head, to: Pos(range.head.line + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)};
          <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> {from: range.head, to: Pos(range.head.line, len)};
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      deleteNearSelection(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">return</span> {from: Pos(range.from().line, <span class="hljs-number">0</span>),
                to: clipPos(cm.doc, Pos(range.to().line + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))};
      });
    },
    delLineLeft: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      deleteNearSelection(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">return</span> {from: Pos(range.from().line, <span class="hljs-number">0</span>), to: range.from()};
      });
    },
    delWrappedLineLeft: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      deleteNearSelection(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">var</span> top = cm.charCoords(range.head, <span class="hljs-string">"div"</span>).top + <span class="hljs-number">5</span>;
        <span class="hljs-keyword">var</span> leftPos = cm.coordsChar({left: <span class="hljs-number">0</span>, top: top}, <span class="hljs-string">"div"</span>);
        <span class="hljs-keyword">return</span> {from: leftPos, to: range.from()};
      });
    },
    delWrappedLineRight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      deleteNearSelection(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">var</span> top = cm.charCoords(range.head, <span class="hljs-string">"div"</span>).top + <span class="hljs-number">5</span>;
        <span class="hljs-keyword">var</span> rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + <span class="hljs-number">100</span>, top: top}, <span class="hljs-string">"div"</span>);
        <span class="hljs-keyword">return</span> {from: range.from(), to: rightPos };
      });
    },
    undo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.undo();},
    redo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.redo();},
    undoSelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.undoSelection();},
    redoSelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.redoSelection();},
    goDocStart: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.extendSelection(Pos(cm.firstLine(), <span class="hljs-number">0</span>));},
    goDocEnd: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      cm.extendSelectionsBy(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{ <span class="hljs-keyword">return</span> lineStart(cm, range.head.line); },
                            {origin: <span class="hljs-string">"+move"</span>, bias: <span class="hljs-number">1</span>});
    },
    goLineStartSmart: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      cm.extendSelectionsBy(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">return</span> lineStartSmart(cm, range.head);
      }, {origin: <span class="hljs-string">"+move"</span>, bias: <span class="hljs-number">1</span>});
    },
    goLineEnd: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      cm.extendSelectionsBy(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{ <span class="hljs-keyword">return</span> lineEnd(cm, range.head.line); },
                            {origin: <span class="hljs-string">"+move"</span>, bias: -<span class="hljs-number">1</span>});
    },
    goLineRight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      cm.extendSelectionsBy(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">var</span> top = cm.charCoords(range.head, <span class="hljs-string">"div"</span>).top + <span class="hljs-number">5</span>;
        <span class="hljs-keyword">return</span> cm.coordsChar({left: cm.display.lineDiv.offsetWidth + <span class="hljs-number">100</span>, top: top}, <span class="hljs-string">"div"</span>);
      }, sel_move);
    },
    goLineLeft: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      cm.extendSelectionsBy(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">var</span> top = cm.charCoords(range.head, <span class="hljs-string">"div"</span>).top + <span class="hljs-number">5</span>;
        <span class="hljs-keyword">return</span> cm.coordsChar({left: <span class="hljs-number">0</span>, top: top}, <span class="hljs-string">"div"</span>);
      }, sel_move);
    },
    goLineLeftSmart: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      cm.extendSelectionsBy(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range</span>) </span>{
        <span class="hljs-keyword">var</span> top = cm.charCoords(range.head, <span class="hljs-string">"div"</span>).top + <span class="hljs-number">5</span>;
        <span class="hljs-keyword">var</span> pos = cm.coordsChar({left: <span class="hljs-number">0</span>, top: top}, <span class="hljs-string">"div"</span>);
        <span class="hljs-keyword">if</span> (pos.ch &lt; cm.getLine(pos.line).search(<span class="hljs-regexp">/\S/</span>)) <span class="hljs-keyword">return</span> lineStartSmart(cm, range.head);
        <span class="hljs-keyword">return</span> pos;
      }, sel_move);
    },
    goLineUp: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveV(-<span class="hljs-number">1</span>, <span class="hljs-string">"line"</span>);},
    goLineDown: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveV(<span class="hljs-number">1</span>, <span class="hljs-string">"line"</span>);},
    goPageUp: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveV(-<span class="hljs-number">1</span>, <span class="hljs-string">"page"</span>);},
    goPageDown: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveV(<span class="hljs-number">1</span>, <span class="hljs-string">"page"</span>);},
    goCharLeft: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveH(-<span class="hljs-number">1</span>, <span class="hljs-string">"char"</span>);},
    goCharRight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveH(<span class="hljs-number">1</span>, <span class="hljs-string">"char"</span>);},
    goColumnLeft: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveH(-<span class="hljs-number">1</span>, <span class="hljs-string">"column"</span>);},
    goColumnRight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveH(<span class="hljs-number">1</span>, <span class="hljs-string">"column"</span>);},
    goWordLeft: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveH(-<span class="hljs-number">1</span>, <span class="hljs-string">"word"</span>);},
    goGroupRight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveH(<span class="hljs-number">1</span>, <span class="hljs-string">"group"</span>);},
    goGroupLeft: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveH(-<span class="hljs-number">1</span>, <span class="hljs-string">"group"</span>);},
    goWordRight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.moveH(<span class="hljs-number">1</span>, <span class="hljs-string">"word"</span>);},
    delCharBefore: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.deleteH(-<span class="hljs-number">1</span>, <span class="hljs-string">"char"</span>);},
    delCharAfter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.deleteH(<span class="hljs-number">1</span>, <span class="hljs-string">"char"</span>);},
    delWordBefore: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.deleteH(-<span class="hljs-number">1</span>, <span class="hljs-string">"word"</span>);},
    delWordAfter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.deleteH(<span class="hljs-number">1</span>, <span class="hljs-string">"word"</span>);},
    delGroupBefore: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.deleteH(-<span class="hljs-number">1</span>, <span class="hljs-string">"group"</span>);},
    delGroupAfter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.deleteH(<span class="hljs-number">1</span>, <span class="hljs-string">"group"</span>);},
    indentAuto: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.indentSelection(<span class="hljs-string">"smart"</span>);},
    indentMore: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.indentSelection(<span class="hljs-string">"add"</span>);},
    indentLess: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.indentSelection(<span class="hljs-string">"subtract"</span>);},
    insertTab: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.replaceSelection(<span class="hljs-string">"\t"</span>);},
    insertSoftTab: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      <span class="hljs-keyword">var</span> spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ranges.length; i++) {
        <span class="hljs-keyword">var</span> pos = ranges[i].from();
        <span class="hljs-keyword">var</span> col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(tabSize - col % tabSize + <span class="hljs-number">1</span>).join(<span class="hljs-string">" "</span>));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      <span class="hljs-keyword">if</span> (cm.somethingSelected()) cm.indentSelection(<span class="hljs-string">"add"</span>);
      <span class="hljs-keyword">else</span> cm.execCommand(<span class="hljs-string">"insertTab"</span>);
    },
    transposeChars: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      runInOp(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> ranges = cm.listSelections(), newSel = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ranges.length; i++) {
          <span class="hljs-keyword">var</span> cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          <span class="hljs-keyword">if</span> (line) {
            <span class="hljs-keyword">if</span> (cur.ch == line.length) cur = <span class="hljs-keyword">new</span> Pos(cur.line, cur.ch - <span class="hljs-number">1</span>);
            <span class="hljs-keyword">if</span> (cur.ch &gt; <span class="hljs-number">0</span>) {
              cur = <span class="hljs-keyword">new</span> Pos(cur.line, cur.ch + <span class="hljs-number">1</span>);
              cm.replaceRange(line.charAt(cur.ch - <span class="hljs-number">1</span>) + line.charAt(cur.ch - <span class="hljs-number">2</span>),
                              Pos(cur.line, cur.ch - <span class="hljs-number">2</span>), cur, <span class="hljs-string">"+transpose"</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.line &gt; cm.doc.first) {
              <span class="hljs-keyword">var</span> prev = getLine(cm.doc, cur.line - <span class="hljs-number">1</span>).text;
              <span class="hljs-keyword">if</span> (prev)
                cm.replaceRange(line.charAt(<span class="hljs-number">0</span>) + cm.doc.lineSeparator() +
                                prev.charAt(prev.length - <span class="hljs-number">1</span>),
                                Pos(cur.line - <span class="hljs-number">1</span>, prev.length - <span class="hljs-number">1</span>), Pos(cur.line, <span class="hljs-number">1</span>), <span class="hljs-string">"+transpose"</span>);
            }
          }
          newSel.push(<span class="hljs-keyword">new</span> Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      runInOp(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> len = cm.listSelections().length;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
          <span class="hljs-keyword">var</span> range = cm.listSelections()[i];
          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, <span class="hljs-string">"+input"</span>);
          cm.indentLine(range.from().line + <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
        }
        ensureCursorVisible(cm);
      });
    },
    toggleOverwrite: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{cm.toggleOverwrite();}
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>STANDARD KEYMAPS</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> keyMap = CodeMirror.keyMap = {};

  keyMap.basic = {
    <span class="hljs-string">"Left"</span>: <span class="hljs-string">"goCharLeft"</span>, <span class="hljs-string">"Right"</span>: <span class="hljs-string">"goCharRight"</span>, <span class="hljs-string">"Up"</span>: <span class="hljs-string">"goLineUp"</span>, <span class="hljs-string">"Down"</span>: <span class="hljs-string">"goLineDown"</span>,
    <span class="hljs-string">"End"</span>: <span class="hljs-string">"goLineEnd"</span>, <span class="hljs-string">"Home"</span>: <span class="hljs-string">"goLineStartSmart"</span>, <span class="hljs-string">"PageUp"</span>: <span class="hljs-string">"goPageUp"</span>, <span class="hljs-string">"PageDown"</span>: <span class="hljs-string">"goPageDown"</span>,
    <span class="hljs-string">"Delete"</span>: <span class="hljs-string">"delCharAfter"</span>, <span class="hljs-string">"Backspace"</span>: <span class="hljs-string">"delCharBefore"</span>, <span class="hljs-string">"Shift-Backspace"</span>: <span class="hljs-string">"delCharBefore"</span>,
    <span class="hljs-string">"Tab"</span>: <span class="hljs-string">"defaultTab"</span>, <span class="hljs-string">"Shift-Tab"</span>: <span class="hljs-string">"indentAuto"</span>,
    <span class="hljs-string">"Enter"</span>: <span class="hljs-string">"newlineAndIndent"</span>, <span class="hljs-string">"Insert"</span>: <span class="hljs-string">"toggleOverwrite"</span>,
    <span class="hljs-string">"Esc"</span>: <span class="hljs-string">"singleSelection"</span>
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Note that the save and find-related commands aren&#39;t defined by
default. User code or addons can define them. Unknown commands
are simply ignored.</p></div></div><div class="code"><div class="wrapper">  keyMap.pcDefault = {
    <span class="hljs-string">"Ctrl-A"</span>: <span class="hljs-string">"selectAll"</span>, <span class="hljs-string">"Ctrl-D"</span>: <span class="hljs-string">"deleteLine"</span>, <span class="hljs-string">"Ctrl-Z"</span>: <span class="hljs-string">"undo"</span>, <span class="hljs-string">"Shift-Ctrl-Z"</span>: <span class="hljs-string">"redo"</span>, <span class="hljs-string">"Ctrl-Y"</span>: <span class="hljs-string">"redo"</span>,
    <span class="hljs-string">"Ctrl-Home"</span>: <span class="hljs-string">"goDocStart"</span>, <span class="hljs-string">"Ctrl-End"</span>: <span class="hljs-string">"goDocEnd"</span>, <span class="hljs-string">"Ctrl-Up"</span>: <span class="hljs-string">"goLineUp"</span>, <span class="hljs-string">"Ctrl-Down"</span>: <span class="hljs-string">"goLineDown"</span>,
    <span class="hljs-string">"Ctrl-Left"</span>: <span class="hljs-string">"goGroupLeft"</span>, <span class="hljs-string">"Ctrl-Right"</span>: <span class="hljs-string">"goGroupRight"</span>, <span class="hljs-string">"Alt-Left"</span>: <span class="hljs-string">"goLineStart"</span>, <span class="hljs-string">"Alt-Right"</span>: <span class="hljs-string">"goLineEnd"</span>,
    <span class="hljs-string">"Ctrl-Backspace"</span>: <span class="hljs-string">"delGroupBefore"</span>, <span class="hljs-string">"Ctrl-Delete"</span>: <span class="hljs-string">"delGroupAfter"</span>, <span class="hljs-string">"Ctrl-S"</span>: <span class="hljs-string">"save"</span>, <span class="hljs-string">"Ctrl-F"</span>: <span class="hljs-string">"find"</span>,
    <span class="hljs-string">"Ctrl-G"</span>: <span class="hljs-string">"findNext"</span>, <span class="hljs-string">"Shift-Ctrl-G"</span>: <span class="hljs-string">"findPrev"</span>, <span class="hljs-string">"Shift-Ctrl-F"</span>: <span class="hljs-string">"replace"</span>, <span class="hljs-string">"Shift-Ctrl-R"</span>: <span class="hljs-string">"replaceAll"</span>,
    <span class="hljs-string">"Ctrl-["</span>: <span class="hljs-string">"indentLess"</span>, <span class="hljs-string">"Ctrl-]"</span>: <span class="hljs-string">"indentMore"</span>,
    <span class="hljs-string">"Ctrl-U"</span>: <span class="hljs-string">"undoSelection"</span>, <span class="hljs-string">"Shift-Ctrl-U"</span>: <span class="hljs-string">"redoSelection"</span>, <span class="hljs-string">"Alt-U"</span>: <span class="hljs-string">"redoSelection"</span>,
    fallthrough: <span class="hljs-string">"basic"</span>
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Very basic readline/emacs-style bindings, which are standard on Mac.</p></div></div><div class="code"><div class="wrapper">  keyMap.emacsy = {
    <span class="hljs-string">"Ctrl-F"</span>: <span class="hljs-string">"goCharRight"</span>, <span class="hljs-string">"Ctrl-B"</span>: <span class="hljs-string">"goCharLeft"</span>, <span class="hljs-string">"Ctrl-P"</span>: <span class="hljs-string">"goLineUp"</span>, <span class="hljs-string">"Ctrl-N"</span>: <span class="hljs-string">"goLineDown"</span>,
    <span class="hljs-string">"Alt-F"</span>: <span class="hljs-string">"goWordRight"</span>, <span class="hljs-string">"Alt-B"</span>: <span class="hljs-string">"goWordLeft"</span>, <span class="hljs-string">"Ctrl-A"</span>: <span class="hljs-string">"goLineStart"</span>, <span class="hljs-string">"Ctrl-E"</span>: <span class="hljs-string">"goLineEnd"</span>,
    <span class="hljs-string">"Ctrl-V"</span>: <span class="hljs-string">"goPageDown"</span>, <span class="hljs-string">"Shift-Ctrl-V"</span>: <span class="hljs-string">"goPageUp"</span>, <span class="hljs-string">"Ctrl-D"</span>: <span class="hljs-string">"delCharAfter"</span>, <span class="hljs-string">"Ctrl-H"</span>: <span class="hljs-string">"delCharBefore"</span>,
    <span class="hljs-string">"Alt-D"</span>: <span class="hljs-string">"delWordAfter"</span>, <span class="hljs-string">"Alt-Backspace"</span>: <span class="hljs-string">"delWordBefore"</span>, <span class="hljs-string">"Ctrl-K"</span>: <span class="hljs-string">"killLine"</span>, <span class="hljs-string">"Ctrl-T"</span>: <span class="hljs-string">"transposeChars"</span>
  };
  keyMap.macDefault = {
    <span class="hljs-string">"Cmd-A"</span>: <span class="hljs-string">"selectAll"</span>, <span class="hljs-string">"Cmd-D"</span>: <span class="hljs-string">"deleteLine"</span>, <span class="hljs-string">"Cmd-Z"</span>: <span class="hljs-string">"undo"</span>, <span class="hljs-string">"Shift-Cmd-Z"</span>: <span class="hljs-string">"redo"</span>, <span class="hljs-string">"Cmd-Y"</span>: <span class="hljs-string">"redo"</span>,
    <span class="hljs-string">"Cmd-Home"</span>: <span class="hljs-string">"goDocStart"</span>, <span class="hljs-string">"Cmd-Up"</span>: <span class="hljs-string">"goDocStart"</span>, <span class="hljs-string">"Cmd-End"</span>: <span class="hljs-string">"goDocEnd"</span>, <span class="hljs-string">"Cmd-Down"</span>: <span class="hljs-string">"goDocEnd"</span>, <span class="hljs-string">"Alt-Left"</span>: <span class="hljs-string">"goGroupLeft"</span>,
    <span class="hljs-string">"Alt-Right"</span>: <span class="hljs-string">"goGroupRight"</span>, <span class="hljs-string">"Cmd-Left"</span>: <span class="hljs-string">"goLineLeft"</span>, <span class="hljs-string">"Cmd-Right"</span>: <span class="hljs-string">"goLineRight"</span>, <span class="hljs-string">"Alt-Backspace"</span>: <span class="hljs-string">"delGroupBefore"</span>,
    <span class="hljs-string">"Ctrl-Alt-Backspace"</span>: <span class="hljs-string">"delGroupAfter"</span>, <span class="hljs-string">"Alt-Delete"</span>: <span class="hljs-string">"delGroupAfter"</span>, <span class="hljs-string">"Cmd-S"</span>: <span class="hljs-string">"save"</span>, <span class="hljs-string">"Cmd-F"</span>: <span class="hljs-string">"find"</span>,
    <span class="hljs-string">"Cmd-G"</span>: <span class="hljs-string">"findNext"</span>, <span class="hljs-string">"Shift-Cmd-G"</span>: <span class="hljs-string">"findPrev"</span>, <span class="hljs-string">"Cmd-Alt-F"</span>: <span class="hljs-string">"replace"</span>, <span class="hljs-string">"Shift-Cmd-Alt-F"</span>: <span class="hljs-string">"replaceAll"</span>,
    <span class="hljs-string">"Cmd-["</span>: <span class="hljs-string">"indentLess"</span>, <span class="hljs-string">"Cmd-]"</span>: <span class="hljs-string">"indentMore"</span>, <span class="hljs-string">"Cmd-Backspace"</span>: <span class="hljs-string">"delWrappedLineLeft"</span>, <span class="hljs-string">"Cmd-Delete"</span>: <span class="hljs-string">"delWrappedLineRight"</span>,
    <span class="hljs-string">"Cmd-U"</span>: <span class="hljs-string">"undoSelection"</span>, <span class="hljs-string">"Shift-Cmd-U"</span>: <span class="hljs-string">"redoSelection"</span>, <span class="hljs-string">"Ctrl-Up"</span>: <span class="hljs-string">"goDocStart"</span>, <span class="hljs-string">"Ctrl-Down"</span>: <span class="hljs-string">"goDocEnd"</span>,
    fallthrough: [<span class="hljs-string">"basic"</span>, <span class="hljs-string">"emacsy"</span>]
  };
  keyMap[<span class="hljs-string">"default"</span>] = mac ? keyMap.macDefault : keyMap.pcDefault;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>KEYMAP DISPATCH</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeKeyName</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">var</span> parts = name.split(<span class="hljs-regexp">/-(?!$)/</span>), name = parts[parts.length - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">var</span> alt, ctrl, shift, cmd;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; parts.length - <span class="hljs-number">1</span>; i++) {
      <span class="hljs-keyword">var</span> mod = parts[i];
      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(cmd|meta|m)$/i</span>.test(mod)) cmd = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^a(lt)?$/i</span>.test(mod)) alt = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(c|ctrl|control)$/i</span>.test(mod)) ctrl = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^s(hift)$/i</span>.test(mod)) shift = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unrecognized modifier name: "</span> + mod);
    }
    <span class="hljs-keyword">if</span> (alt) name = <span class="hljs-string">"Alt-"</span> + name;
    <span class="hljs-keyword">if</span> (ctrl) name = <span class="hljs-string">"Ctrl-"</span> + name;
    <span class="hljs-keyword">if</span> (cmd) name = <span class="hljs-string">"Cmd-"</span> + name;
    <span class="hljs-keyword">if</span> (shift) name = <span class="hljs-string">"Shift-"</span> + name;
    <span class="hljs-keyword">return</span> name;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is a kludge to keep keymaps mostly working as raw objects
(backwards compatibility) while at the same time support features
like normalization and multi-stroke key bindings. It compiles a
new normalized keymap, and then updates the old object to reflect
this.</p></div></div><div class="code"><div class="wrapper">  CodeMirror.normalizeKeyMap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">keymap</span>) </span>{
    <span class="hljs-keyword">var</span> copy = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> keyname <span class="hljs-keyword">in</span> keymap) <span class="hljs-keyword">if</span> (keymap.hasOwnProperty(keyname)) {
      <span class="hljs-keyword">var</span> value = keymap[keyname];
      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(name|fallthrough|(de|at)tach)$/</span>.test(keyname)) <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">if</span> (value == <span class="hljs-string">"..."</span>) { <span class="hljs-keyword">delete</span> keymap[keyname]; <span class="hljs-keyword">continue</span>; }

      <span class="hljs-keyword">var</span> keys = map(keyname.split(<span class="hljs-string">" "</span>), normalizeKeyName);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) {
        <span class="hljs-keyword">var</span> val, name;
        <span class="hljs-keyword">if</span> (i == keys.length - <span class="hljs-number">1</span>) {
          name = keys.join(<span class="hljs-string">" "</span>);
          val = value;
        } <span class="hljs-keyword">else</span> {
          name = keys.slice(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>).join(<span class="hljs-string">" "</span>);
          val = <span class="hljs-string">"..."</span>;
        }
        <span class="hljs-keyword">var</span> prev = copy[name];
        <span class="hljs-keyword">if</span> (!prev) copy[name] = val;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prev != val) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Inconsistent bindings for "</span> + name);
      }
      <span class="hljs-keyword">delete</span> keymap[keyname];
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> copy) keymap[prop] = copy[prop];
    <span class="hljs-keyword">return</span> keymap;
  };

  <span class="hljs-keyword">var</span> lookupKey = CodeMirror.lookupKey = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, map, handle, context</span>) </span>{
    map = getKeyMap(map);
    <span class="hljs-keyword">var</span> found = map.call ? map.call(key, context) : map[key];
    <span class="hljs-keyword">if</span> (found === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">"nothing"</span>;
    <span class="hljs-keyword">if</span> (found === <span class="hljs-string">"..."</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">"multi"</span>;
    <span class="hljs-keyword">if</span> (found != <span class="hljs-literal">null</span> &amp;&amp; handle(found)) <span class="hljs-keyword">return</span> <span class="hljs-string">"handled"</span>;

    <span class="hljs-keyword">if</span> (map.fallthrough) {
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(map.fallthrough) != <span class="hljs-string">"[object Array]"</span>)
        <span class="hljs-keyword">return</span> lookupKey(key, map.fallthrough, handle, context);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; map.fallthrough.length; i++) {
        <span class="hljs-keyword">var</span> result = lookupKey(key, map.fallthrough[i], handle, context);
        <span class="hljs-keyword">if</span> (result) <span class="hljs-keyword">return</span> result;
      }
    }
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Modifier key presses don&#39;t count as &#39;real&#39; key presses for the
purpose of keymap fallthrough.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> isModifierKey = CodeMirror.isModifierKey = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">var</span> name = <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">"string"</span> ? value : keyNames[value.keyCode];
    <span class="hljs-keyword">return</span> name == <span class="hljs-string">"Ctrl"</span> || name == <span class="hljs-string">"Alt"</span> || name == <span class="hljs-string">"Shift"</span> || name == <span class="hljs-string">"Mod"</span>;
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Look up the name of a key as indicated by an event object.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> keyName = CodeMirror.keyName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, noShift</span>) </span>{
    <span class="hljs-keyword">if</span> (presto &amp;&amp; event.keyCode == <span class="hljs-number">34</span> &amp;&amp; event[<span class="hljs-string">"char"</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> base = keyNames[event.keyCode], name = base;
    <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span> || event.altGraphKey) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (event.altKey &amp;&amp; base != <span class="hljs-string">"Alt"</span>) name = <span class="hljs-string">"Alt-"</span> + name;
    <span class="hljs-keyword">if</span> ((flipCtrlCmd ? event.metaKey : event.ctrlKey) &amp;&amp; base != <span class="hljs-string">"Ctrl"</span>) name = <span class="hljs-string">"Ctrl-"</span> + name;
    <span class="hljs-keyword">if</span> ((flipCtrlCmd ? event.ctrlKey : event.metaKey) &amp;&amp; base != <span class="hljs-string">"Cmd"</span>) name = <span class="hljs-string">"Cmd-"</span> + name;
    <span class="hljs-keyword">if</span> (!noShift &amp;&amp; event.shiftKey &amp;&amp; base != <span class="hljs-string">"Shift"</span>) name = <span class="hljs-string">"Shift-"</span> + name;
    <span class="hljs-keyword">return</span> name;
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getKeyMap</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val == <span class="hljs-string">"string"</span> ? keyMap[val] : val;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>FROMTEXTAREA</p></div></div><div class="code"><div class="wrapper">  CodeMirror.fromTextArea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">textarea, options</span>) </span>{
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    <span class="hljs-keyword">if</span> (!options.tabindex &amp;&amp; textarea.tabIndex)
      options.tabindex = textarea.tabIndex;
    <span class="hljs-keyword">if</span> (!options.placeholder &amp;&amp; textarea.placeholder)
      options.placeholder = textarea.placeholder;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set autofocus to true if this textarea is focused, or if it has
autofocus and no other element is focused.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (options.autofocus == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute(<span class="hljs-string">"autofocus"</span>) != <span class="hljs-literal">null</span> &amp;&amp; hasFocus == <span class="hljs-built_in">document</span>.body;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span>(<span class="hljs-params"></span>) </span>{textarea.value = cm.getValue();}
    <span class="hljs-keyword">if</span> (textarea.form) {
      on(textarea.form, <span class="hljs-string">"submit"</span>, save);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Deplorable hack to make the submit method do the right thing.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (!options.leaveSubmitMethodAlone) {
        <span class="hljs-keyword">var</span> form = textarea.form, realSubmit = form.submit;
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> wrappedSubmit = form.submit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } <span class="hljs-keyword">catch</span>(e) {}
      }
    }

    options.finishInit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cm</span>) </span>{
      cm.save = save;
      cm.getTextArea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> textarea; };
      cm.toTextArea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        cm.toTextArea = <span class="hljs-built_in">isNaN</span>; <span class="hljs-comment">// Prevent this from being ran twice</span>
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">if</span> (textarea.form) {
          off(textarea.form, <span class="hljs-string">"submit"</span>, save);
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> textarea.form.submit == <span class="hljs-string">"function"</span>)
            textarea.form.submit = realSubmit;
        }
      };
    };

    textarea.style.display = <span class="hljs-string">"none"</span>;
    <span class="hljs-keyword">var</span> cm = CodeMirror(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    <span class="hljs-keyword">return</span> cm;
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>STRING STREAM</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fed to the mode parsers, provides helper functions to make
parsers more succinct.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> StringStream = CodeMirror.StringStream = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">string, tabSize</span>) </span>{
    <span class="hljs-keyword">this</span>.pos = <span class="hljs-keyword">this</span>.start = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.string = string;
    <span class="hljs-keyword">this</span>.tabSize = tabSize || <span class="hljs-number">8</span>;
    <span class="hljs-keyword">this</span>.lastColumnPos = <span class="hljs-keyword">this</span>.lastColumnValue = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.lineStart = <span class="hljs-number">0</span>;
  };

  StringStream.prototype = {
    eol: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pos &gt;= <span class="hljs-keyword">this</span>.string.length;},
    sol: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pos == <span class="hljs-keyword">this</span>.lineStart;},
    peek: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.string.charAt(<span class="hljs-keyword">this</span>.pos) || <span class="hljs-literal">undefined</span>;},
    next: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pos &lt; <span class="hljs-keyword">this</span>.string.length)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.string.charAt(<span class="hljs-keyword">this</span>.pos++);
    },
    eat: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match</span>) </span>{
      <span class="hljs-keyword">var</span> ch = <span class="hljs-keyword">this</span>.string.charAt(<span class="hljs-keyword">this</span>.pos);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> match == <span class="hljs-string">"string"</span>) <span class="hljs-keyword">var</span> ok = ch == match;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">var</span> ok = ch &amp;&amp; (match.test ? match.test(ch) : match(ch));
      <span class="hljs-keyword">if</span> (ok) {++<span class="hljs-keyword">this</span>.pos; <span class="hljs-keyword">return</span> ch;}
    },
    eatWhile: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match</span>) </span>{
      <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>.pos;
      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.eat(match)){}
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pos &gt; start;
    },
    eatSpace: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>.pos;
      <span class="hljs-keyword">while</span> (<span class="hljs-regexp">/[\s\u00a0]/</span>.test(<span class="hljs-keyword">this</span>.string.charAt(<span class="hljs-keyword">this</span>.pos))) ++<span class="hljs-keyword">this</span>.pos;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pos &gt; start;
    },
    skipToEnd: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">this</span>.pos = <span class="hljs-keyword">this</span>.string.length;},
    skipTo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ch</span>) </span>{
      <span class="hljs-keyword">var</span> found = <span class="hljs-keyword">this</span>.string.indexOf(ch, <span class="hljs-keyword">this</span>.pos);
      <span class="hljs-keyword">if</span> (found &gt; -<span class="hljs-number">1</span>) {<span class="hljs-keyword">this</span>.pos = found; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}
    },
    backUp: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{<span class="hljs-keyword">this</span>.pos -= n;},
    column: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lastColumnPos &lt; <span class="hljs-keyword">this</span>.start) {
        <span class="hljs-keyword">this</span>.lastColumnValue = countColumn(<span class="hljs-keyword">this</span>.string, <span class="hljs-keyword">this</span>.start, <span class="hljs-keyword">this</span>.tabSize, <span class="hljs-keyword">this</span>.lastColumnPos, <span class="hljs-keyword">this</span>.lastColumnValue);
        <span class="hljs-keyword">this</span>.lastColumnPos = <span class="hljs-keyword">this</span>.start;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lastColumnValue - (<span class="hljs-keyword">this</span>.lineStart ? countColumn(<span class="hljs-keyword">this</span>.string, <span class="hljs-keyword">this</span>.lineStart, <span class="hljs-keyword">this</span>.tabSize) : <span class="hljs-number">0</span>);
    },
    indentation: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> countColumn(<span class="hljs-keyword">this</span>.string, <span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>.tabSize) -
        (<span class="hljs-keyword">this</span>.lineStart ? countColumn(<span class="hljs-keyword">this</span>.string, <span class="hljs-keyword">this</span>.lineStart, <span class="hljs-keyword">this</span>.tabSize) : <span class="hljs-number">0</span>);
    },
    match: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, consume, caseInsensitive</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> pattern == <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">var</span> cased = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>{<span class="hljs-keyword">return</span> caseInsensitive ? str.toLowerCase() : str;};
        <span class="hljs-keyword">var</span> substr = <span class="hljs-keyword">this</span>.string.substr(<span class="hljs-keyword">this</span>.pos, pattern.length);
        <span class="hljs-keyword">if</span> (cased(substr) == cased(pattern)) {
          <span class="hljs-keyword">if</span> (consume !== <span class="hljs-literal">false</span>) <span class="hljs-keyword">this</span>.pos += pattern.length;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> match = <span class="hljs-keyword">this</span>.string.slice(<span class="hljs-keyword">this</span>.pos).match(pattern);
        <span class="hljs-keyword">if</span> (match &amp;&amp; match.index &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (match &amp;&amp; consume !== <span class="hljs-literal">false</span>) <span class="hljs-keyword">this</span>.pos += match[<span class="hljs-number">0</span>].length;
        <span class="hljs-keyword">return</span> match;
      }
    },
    current: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.string.slice(<span class="hljs-keyword">this</span>.start, <span class="hljs-keyword">this</span>.pos);},
    hideFirstChars: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, inner</span>) </span>{
      <span class="hljs-keyword">this</span>.lineStart += n;
      <span class="hljs-keyword">try</span> { <span class="hljs-keyword">return</span> inner(); }
      <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">this</span>.lineStart -= n; }
    }
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TEXTMARKERS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Created with markText and setBookmark methods. A TextMarker is a
handle that can be used to clear or find a marked position in the
document. Line objects hold arrays (markedSpans) containing
{from, to, marker} object pointing to such marker objects, and
indicating that such a marker is present on that line. Multiple
lines may point to the same marker when it spans across lines.
The spans will have null for their from/to properties when the
marker continues beyond the start/end of the line. Markers have
links back to the lines they currently touch.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> nextMarkerId = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">var</span> TextMarker = CodeMirror.TextMarker = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc, type</span>) </span>{
    <span class="hljs-keyword">this</span>.lines = [];
    <span class="hljs-keyword">this</span>.type = type;
    <span class="hljs-keyword">this</span>.doc = doc;
    <span class="hljs-keyword">this</span>.id = ++nextMarkerId;
  };
  eventMixin(TextMarker);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Clear the marker.</p></div></div><div class="code"><div class="wrapper">  TextMarker.prototype.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.explicitlyCleared) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>.doc.cm, withOp = cm &amp;&amp; !cm.curOp;
    <span class="hljs-keyword">if</span> (withOp) startOperation(cm);
    <span class="hljs-keyword">if</span> (hasHandler(<span class="hljs-keyword">this</span>, <span class="hljs-string">"clear"</span>)) {
      <span class="hljs-keyword">var</span> found = <span class="hljs-keyword">this</span>.find();
      <span class="hljs-keyword">if</span> (found) signalLater(<span class="hljs-keyword">this</span>, <span class="hljs-string">"clear"</span>, found.from, found.to);
    }
    <span class="hljs-keyword">var</span> min = <span class="hljs-literal">null</span>, max = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.lines.length; ++i) {
      <span class="hljs-keyword">var</span> line = <span class="hljs-keyword">this</span>.lines[i];
      <span class="hljs-keyword">var</span> span = getMarkedSpanFor(line.markedSpans, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">if</span> (cm &amp;&amp; !<span class="hljs-keyword">this</span>.collapsed) regLineChange(cm, lineNo(line), <span class="hljs-string">"text"</span>);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cm) {
        <span class="hljs-keyword">if</span> (span.to != <span class="hljs-literal">null</span>) max = lineNo(line);
        <span class="hljs-keyword">if</span> (span.from != <span class="hljs-literal">null</span>) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      <span class="hljs-keyword">if</span> (span.from == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.collapsed &amp;&amp; !lineIsHidden(<span class="hljs-keyword">this</span>.doc, line) &amp;&amp; cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    <span class="hljs-keyword">if</span> (cm &amp;&amp; <span class="hljs-keyword">this</span>.collapsed &amp;&amp; !cm.options.lineWrapping) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.lines.length; ++i) {
      <span class="hljs-keyword">var</span> visual = visualLine(<span class="hljs-keyword">this</span>.lines[i]), len = lineLength(visual);
      <span class="hljs-keyword">if</span> (len &gt; cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-keyword">if</span> (min != <span class="hljs-literal">null</span> &amp;&amp; cm &amp;&amp; <span class="hljs-keyword">this</span>.collapsed) regChange(cm, min, max + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">this</span>.lines.length = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.explicitlyCleared = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.atomic &amp;&amp; <span class="hljs-keyword">this</span>.doc.cantEdit) {
      <span class="hljs-keyword">this</span>.doc.cantEdit = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (cm) reCheckSelection(cm.doc);
    }
    <span class="hljs-keyword">if</span> (cm) signalLater(cm, <span class="hljs-string">"markerCleared"</span>, cm, <span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">if</span> (withOp) endOperation(cm);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent) <span class="hljs-keyword">this</span>.parent.clear();
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the position of the marker in the document. Returns a {from,
to} object by default. Side can be passed to get a specific side
-- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
Pos objects returned contain a line object, rather than a line
number (used to prevent looking up the same line twice).</p></div></div><div class="code"><div class="wrapper">  TextMarker.prototype.find = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">side, lineObj</span>) </span>{
    <span class="hljs-keyword">if</span> (side == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.type == <span class="hljs-string">"bookmark"</span>) side = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> from, to;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.lines.length; ++i) {
      <span class="hljs-keyword">var</span> line = <span class="hljs-keyword">this</span>.lines[i];
      <span class="hljs-keyword">var</span> span = getMarkedSpanFor(line.markedSpans, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">if</span> (span.from != <span class="hljs-literal">null</span>) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        <span class="hljs-keyword">if</span> (side == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> from;
      }
      <span class="hljs-keyword">if</span> (span.to != <span class="hljs-literal">null</span>) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        <span class="hljs-keyword">if</span> (side == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> to;
      }
    }
    <span class="hljs-keyword">return</span> from &amp;&amp; {from: from, to: to};
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Signals that the marker&#39;s widget changed, and surrounding layout
should be recomputed.</p></div></div><div class="code"><div class="wrapper">  TextMarker.prototype.changed = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> pos = <span class="hljs-keyword">this</span>.find(-<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>), widget = <span class="hljs-keyword">this</span>, cm = <span class="hljs-keyword">this</span>.doc.cm;
    <span class="hljs-keyword">if</span> (!pos || !cm) <span class="hljs-keyword">return</span>;
    runInOp(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> line = pos.line, lineN = lineNo(pos.line);
      <span class="hljs-keyword">var</span> view = findViewForLine(cm, lineN);
      <span class="hljs-keyword">if</span> (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = <span class="hljs-literal">true</span>;
      }
      cm.curOp.updateMaxLine = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (!lineIsHidden(widget.doc, line) &amp;&amp; widget.height != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> oldHeight = widget.height;
        widget.height = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> dHeight = widgetHeight(widget) - oldHeight;
        <span class="hljs-keyword">if</span> (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.lines.length &amp;&amp; <span class="hljs-keyword">this</span>.doc.cm) {
      <span class="hljs-keyword">var</span> op = <span class="hljs-keyword">this</span>.doc.cm.curOp;
      <span class="hljs-keyword">if</span> (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, <span class="hljs-keyword">this</span>) == -<span class="hljs-number">1</span>)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(<span class="hljs-keyword">this</span>);
    }
    <span class="hljs-keyword">this</span>.lines.push(line);
  };
  TextMarker.prototype.detachLine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">this</span>.lines.splice(indexOf(<span class="hljs-keyword">this</span>.lines, line), <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.lines.length &amp;&amp; <span class="hljs-keyword">this</span>.doc.cm) {
      <span class="hljs-keyword">var</span> op = <span class="hljs-keyword">this</span>.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(<span class="hljs-keyword">this</span>);
    }
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Collapsed markers have unique ids, in order to be able to order
them, which is needed for uniquely determining an outer marker
when they overlap (they may nest, but not partially overlap).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> nextMarkerId = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a marker, wire it up to the right lines, and</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markText</span>(<span class="hljs-params">doc, from, to, options, type</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Shared markers (across linked documents) are handled separately
(markTextShared will call out to this again, once per
document).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (options &amp;&amp; options.shared) <span class="hljs-keyword">return</span> markTextShared(doc, from, to, options, type);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure we are in an operation.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (doc.cm &amp;&amp; !doc.cm.curOp) <span class="hljs-keyword">return</span> operation(doc.cm, markText)(doc, from, to, options, type);

    <span class="hljs-keyword">var</span> marker = <span class="hljs-keyword">new</span> TextMarker(doc, type), diff = cmp(from, to);
    <span class="hljs-keyword">if</span> (options) copyObj(options, marker, <span class="hljs-literal">false</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Don&#39;t connect empty markers unless clearWhenEmpty is false</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span> || diff == <span class="hljs-number">0</span> &amp;&amp; marker.clearWhenEmpty !== <span class="hljs-literal">false</span>)
      <span class="hljs-keyword">return</span> marker;
    <span class="hljs-keyword">if</span> (marker.replacedWith) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Showing up as a widget implies collapsed (widget replaces text)</p></div></div><div class="code"><div class="wrapper">      marker.collapsed = <span class="hljs-literal">true</span>;
      marker.widgetNode = elt(<span class="hljs-string">"span"</span>, [marker.replacedWith], <span class="hljs-string">"CodeMirror-widget"</span>);
      <span class="hljs-keyword">if</span> (!options.handleMouseEvents) marker.widgetNode.setAttribute(<span class="hljs-string">"cm-ignore-events"</span>, <span class="hljs-string">"true"</span>);
      <span class="hljs-keyword">if</span> (options.insertLeft) marker.widgetNode.insertLeft = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">if</span> (marker.collapsed) {
      <span class="hljs-keyword">if</span> (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line &amp;&amp; conflictingCollapsedRange(doc, to.line, from, to, marker))
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Inserting collapsed marker partially overlapping an existing one"</span>);
      sawCollapsedSpans = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: <span class="hljs-string">"markText"</span>}, doc.sel, <span class="hljs-literal">NaN</span>);

    <span class="hljs-keyword">var</span> curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + <span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">if</span> (cm &amp;&amp; marker.collapsed &amp;&amp; !cm.options.lineWrapping &amp;&amp; visualLine(line) == cm.display.maxLine)
        updateMaxLine = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (marker.collapsed &amp;&amp; curLine != from.line) updateLineHeight(line, <span class="hljs-number">0</span>);
      addMarkedSpan(line, <span class="hljs-keyword">new</span> MarkedSpan(marker,
                                         curLine == from.line ? from.ch : <span class="hljs-literal">null</span>,
                                         curLine == to.line ? to.ch : <span class="hljs-literal">null</span>));
      ++curLine;
    });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>lineIsHidden depends on the presence of the spans, so needs a second pass</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (marker.collapsed) doc.iter(from.line, to.line + <span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">if</span> (lineIsHidden(doc, line)) updateLineHeight(line, <span class="hljs-number">0</span>);
    });

    <span class="hljs-keyword">if</span> (marker.clearOnEnter) on(marker, <span class="hljs-string">"beforeCursorEnter"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ marker.clear(); });

    <span class="hljs-keyword">if</span> (marker.readOnly) {
      sawReadOnlySpans = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    <span class="hljs-keyword">if</span> (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">if</span> (cm) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sync editor state</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (updateMaxLine) cm.curOp.updateMaxLine = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (marker.collapsed)
        regChange(cm, from.line, to.line + <span class="hljs-number">1</span>);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = from.line; i &lt;= to.line; i++) regLineChange(cm, i, <span class="hljs-string">"text"</span>);
      <span class="hljs-keyword">if</span> (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, <span class="hljs-string">"markerAdded"</span>, cm, marker);
    }
    <span class="hljs-keyword">return</span> marker;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>SHARED TEXTMARKERS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A shared marker spans multiple linked documents. It is
implemented as a meta-marker-object controlling multiple normal
markers.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> SharedTextMarker = CodeMirror.SharedTextMarker = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">markers, primary</span>) </span>{
    <span class="hljs-keyword">this</span>.markers = markers;
    <span class="hljs-keyword">this</span>.primary = primary;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; markers.length; ++i)
      markers[i].parent = <span class="hljs-keyword">this</span>;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.explicitlyCleared) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>.explicitlyCleared = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.markers.length; ++i)
      <span class="hljs-keyword">this</span>.markers[i].clear();
    signalLater(<span class="hljs-keyword">this</span>, <span class="hljs-string">"clear"</span>);
  };
  SharedTextMarker.prototype.find = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">side, lineObj</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.primary.find(side, lineObj);
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markTextShared</span>(<span class="hljs-params">doc, from, to, options, type</span>) </span>{
    options = copyObj(options);
    options.shared = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> markers = [markText(doc, from, to, options, type)], primary = markers[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">var</span> widget = options.widgetNode;
    linkedDocs(doc, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
      <span class="hljs-keyword">if</span> (widget) options.widgetNode = widget.cloneNode(<span class="hljs-literal">true</span>);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; doc.linked.length; ++i)
        <span class="hljs-keyword">if</span> (doc.linked[i].isParent) <span class="hljs-keyword">return</span>;
      primary = lst(markers);
    });
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SharedTextMarker(markers, primary);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSharedMarkers</span>(<span class="hljs-params">doc</span>) </span>{
    <span class="hljs-keyword">return</span> doc.findMarks(Pos(doc.first, <span class="hljs-number">0</span>), doc.clipPos(Pos(doc.lastLine())),
                         <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>) </span>{ <span class="hljs-keyword">return</span> m.parent; });
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copySharedMarkers</span>(<span class="hljs-params">doc, markers</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; markers.length; i++) {
      <span class="hljs-keyword">var</span> marker = markers[i], pos = marker.find();
      <span class="hljs-keyword">var</span> mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      <span class="hljs-keyword">if</span> (cmp(mFrom, mTo)) {
        <span class="hljs-keyword">var</span> subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detachSharedMarkers</span>(<span class="hljs-params">markers</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; markers.length; i++) {
      <span class="hljs-keyword">var</span> marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">d</span>) </span>{ linked.push(d); });
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; marker.markers.length; j++) {
        <span class="hljs-keyword">var</span> subMarker = marker.markers[j];
        <span class="hljs-keyword">if</span> (indexOf(linked, subMarker.doc) == -<span class="hljs-number">1</span>) {
          subMarker.parent = <span class="hljs-literal">null</span>;
          marker.markers.splice(j--, <span class="hljs-number">1</span>);
        }
      }
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TEXTMARKER SPANS</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MarkedSpan</span>(<span class="hljs-params">marker, from, to</span>) </span>{
    <span class="hljs-keyword">this</span>.marker = marker;
    <span class="hljs-keyword">this</span>.from = from; <span class="hljs-keyword">this</span>.to = to;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Search an array of spans for a span matching the given marker.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMarkedSpanFor</span>(<span class="hljs-params">spans, marker</span>) </span>{
    <span class="hljs-keyword">if</span> (spans) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; spans.length; ++i) {
      <span class="hljs-keyword">var</span> span = spans[i];
      <span class="hljs-keyword">if</span> (span.marker == marker) <span class="hljs-keyword">return</span> span;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove a span from an array, returning undefined if no spans are
left (we don&#39;t store arrays for lines without spans).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeMarkedSpan</span>(<span class="hljs-params">spans, span</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> r, i = <span class="hljs-number">0</span>; i &lt; spans.length; ++i)
      <span class="hljs-keyword">if</span> (spans[i] != span) (r || (r = [])).push(spans[i]);
    <span class="hljs-keyword">return</span> r;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add a span to a line.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addMarkedSpan</span>(<span class="hljs-params">line, span</span>) </span>{
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used for the algorithm that adjusts markers for a change in the
document. These functions cut an array of spans at a given
character position, returning an array of remaining chunks (or
undefined if nothing remains).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markedSpansBefore</span>(<span class="hljs-params">old, startCh, isInsert</span>) </span>{
    <span class="hljs-keyword">if</span> (old) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, nw; i &lt; old.length; ++i) {
      <span class="hljs-keyword">var</span> span = old[i], marker = span.marker;
      <span class="hljs-keyword">var</span> startsBefore = span.from == <span class="hljs-literal">null</span> || (marker.inclusiveLeft ? span.from &lt;= startCh : span.from &lt; startCh);
      <span class="hljs-keyword">if</span> (startsBefore || span.from == startCh &amp;&amp; marker.type == <span class="hljs-string">"bookmark"</span> &amp;&amp; (!isInsert || !span.marker.insertLeft)) {
        <span class="hljs-keyword">var</span> endsAfter = span.to == <span class="hljs-literal">null</span> || (marker.inclusiveRight ? span.to &gt;= startCh : span.to &gt; startCh);
        (nw || (nw = [])).push(<span class="hljs-keyword">new</span> MarkedSpan(marker, span.from, endsAfter ? <span class="hljs-literal">null</span> : span.to));
      }
    }
    <span class="hljs-keyword">return</span> nw;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markedSpansAfter</span>(<span class="hljs-params">old, endCh, isInsert</span>) </span>{
    <span class="hljs-keyword">if</span> (old) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, nw; i &lt; old.length; ++i) {
      <span class="hljs-keyword">var</span> span = old[i], marker = span.marker;
      <span class="hljs-keyword">var</span> endsAfter = span.to == <span class="hljs-literal">null</span> || (marker.inclusiveRight ? span.to &gt;= endCh : span.to &gt; endCh);
      <span class="hljs-keyword">if</span> (endsAfter || span.from == endCh &amp;&amp; marker.type == <span class="hljs-string">"bookmark"</span> &amp;&amp; (!isInsert || span.marker.insertLeft)) {
        <span class="hljs-keyword">var</span> startsBefore = span.from == <span class="hljs-literal">null</span> || (marker.inclusiveLeft ? span.from &lt;= endCh : span.from &lt; endCh);
        (nw || (nw = [])).push(<span class="hljs-keyword">new</span> MarkedSpan(marker, startsBefore ? <span class="hljs-literal">null</span> : span.from - endCh,
                                              span.to == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : span.to - endCh));
      }
    }
    <span class="hljs-keyword">return</span> nw;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a change object, compute the new set of marker spans that
cover the line in which the change took place. Removes spans
entirely within the change, reconnects spans belonging to the
same marker that appear on both sides of the change, and cuts off
spans partially within the change. Returns an array of span
arrays with one element for each line in (after) the change.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stretchSpansOverChange</span>(<span class="hljs-params">doc, change</span>) </span>{
    <span class="hljs-keyword">if</span> (change.full) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> oldFirst = isLine(doc, change.from.line) &amp;&amp; getLine(doc, change.from.line).markedSpans;
    <span class="hljs-keyword">var</span> oldLast = isLine(doc, change.to.line) &amp;&amp; getLine(doc, change.to.line).markedSpans;
    <span class="hljs-keyword">if</span> (!oldFirst &amp;&amp; !oldLast) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">var</span> startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the spans that &#39;stick out&#39; on both sides</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> first = markedSpansBefore(oldFirst, startCh, isInsert);
    <span class="hljs-keyword">var</span> last = markedSpansAfter(oldLast, endCh, isInsert);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Next, merge those two ends</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> sameLine = change.text.length == <span class="hljs-number">1</span>, offset = lst(change.text).length + (sameLine ? startCh : <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (first) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fix up .to properties of first</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; first.length; ++i) {
        <span class="hljs-keyword">var</span> span = first[i];
        <span class="hljs-keyword">if</span> (span.to == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> found = getMarkedSpanFor(last, span.marker);
          <span class="hljs-keyword">if</span> (!found) span.to = startCh;
          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameLine) span.to = found.to == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : found.to + offset;
        }
      }
    }
    <span class="hljs-keyword">if</span> (last) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fix up .from in last (or move them into first in case of sameLine)</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; last.length; ++i) {
        <span class="hljs-keyword">var</span> span = last[i];
        <span class="hljs-keyword">if</span> (span.to != <span class="hljs-literal">null</span>) span.to += offset;
        <span class="hljs-keyword">if</span> (span.from == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> found = getMarkedSpanFor(first, span.marker);
          <span class="hljs-keyword">if</span> (!found) {
            span.from = offset;
            <span class="hljs-keyword">if</span> (sameLine) (first || (first = [])).push(span);
          }
        } <span class="hljs-keyword">else</span> {
          span.from += offset;
          <span class="hljs-keyword">if</span> (sameLine) (first || (first = [])).push(span);
        }
      }
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make sure we didn&#39;t create any zero-length spans</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (first) first = clearEmptySpans(first);
    <span class="hljs-keyword">if</span> (last &amp;&amp; last != first) last = clearEmptySpans(last);

    <span class="hljs-keyword">var</span> newMarkers = [first];
    <span class="hljs-keyword">if</span> (!sameLine) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fill gap with whole-line-spans</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> gap = change.text.length - <span class="hljs-number">2</span>, gapMarkers;
      <span class="hljs-keyword">if</span> (gap &gt; <span class="hljs-number">0</span> &amp;&amp; first)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; first.length; ++i)
          <span class="hljs-keyword">if</span> (first[i].to == <span class="hljs-literal">null</span>)
            (gapMarkers || (gapMarkers = [])).push(<span class="hljs-keyword">new</span> MarkedSpan(first[i].marker, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>));
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    <span class="hljs-keyword">return</span> newMarkers;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove spans that are empty and don&#39;t have a clearWhenEmpty
option of false.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearEmptySpans</span>(<span class="hljs-params">spans</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; spans.length; ++i) {
      <span class="hljs-keyword">var</span> span = spans[i];
      <span class="hljs-keyword">if</span> (span.from != <span class="hljs-literal">null</span> &amp;&amp; span.from == span.to &amp;&amp; span.marker.clearWhenEmpty !== <span class="hljs-literal">false</span>)
        spans.splice(i--, <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">if</span> (!spans.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> spans;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used for un/re-doing changes from the history. Combines the
result of computing the existing spans with the set of spans that
existed in the history (so that deleting around a span and then
undoing brings back the span).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeOldSpans</span>(<span class="hljs-params">doc, change</span>) </span>{
    <span class="hljs-keyword">var</span> old = getOldSpans(doc, change);
    <span class="hljs-keyword">var</span> stretched = stretchSpansOverChange(doc, change);
    <span class="hljs-keyword">if</span> (!old) <span class="hljs-keyword">return</span> stretched;
    <span class="hljs-keyword">if</span> (!stretched) <span class="hljs-keyword">return</span> old;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; old.length; ++i) {
      <span class="hljs-keyword">var</span> oldCur = old[i], stretchCur = stretched[i];
      <span class="hljs-keyword">if</span> (oldCur &amp;&amp; stretchCur) {
        spans: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; stretchCur.length; ++j) {
          <span class="hljs-keyword">var</span> span = stretchCur[j];
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt; oldCur.length; ++k)
            <span class="hljs-keyword">if</span> (oldCur[k].marker == span.marker) <span class="hljs-keyword">continue</span> spans;
          oldCur.push(span);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stretchCur) {
        old[i] = stretchCur;
      }
    }
    <span class="hljs-keyword">return</span> old;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to &#39;clip&#39; out readOnly ranges when making a change.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeReadOnlyRanges</span>(<span class="hljs-params">doc, from, to</span>) </span>{
    <span class="hljs-keyword">var</span> markers = <span class="hljs-literal">null</span>;
    doc.iter(from.line, to.line + <span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">if</span> (line.markedSpans) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; line.markedSpans.length; ++i) {
        <span class="hljs-keyword">var</span> mark = line.markedSpans[i].marker;
        <span class="hljs-keyword">if</span> (mark.readOnly &amp;&amp; (!markers || indexOf(markers, mark) == -<span class="hljs-number">1</span>))
          (markers || (markers = [])).push(mark);
      }
    });
    <span class="hljs-keyword">if</span> (!markers) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> parts = [{from: from, to: to}];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; markers.length; ++i) {
      <span class="hljs-keyword">var</span> mk = markers[i], m = mk.find(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; parts.length; ++j) {
        <span class="hljs-keyword">var</span> p = parts[j];
        <span class="hljs-keyword">if</span> (cmp(p.to, m.from) &lt; <span class="hljs-number">0</span> || cmp(p.from, m.to) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">var</span> newParts = [j, <span class="hljs-number">1</span>], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        <span class="hljs-keyword">if</span> (dfrom &lt; <span class="hljs-number">0</span> || !mk.inclusiveLeft &amp;&amp; !dfrom)
          newParts.push({from: p.from, to: m.from});
        <span class="hljs-keyword">if</span> (dto &gt; <span class="hljs-number">0</span> || !mk.inclusiveRight &amp;&amp; !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - <span class="hljs-number">1</span>;
      }
    }
    <span class="hljs-keyword">return</span> parts;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Connect or disconnect spans from a line.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detachMarkedSpans</span>(<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">var</span> spans = line.markedSpans;
    <span class="hljs-keyword">if</span> (!spans) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attachMarkedSpans</span>(<span class="hljs-params">line, spans</span>) </span>{
    <span class="hljs-keyword">if</span> (!spans) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Helpers used when computing which overlapping collapsed span
counts as the larger one.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extraLeft</span>(<span class="hljs-params">marker</span>) </span>{ <span class="hljs-keyword">return</span> marker.inclusiveLeft ? -<span class="hljs-number">1</span> : <span class="hljs-number">0</span>; }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extraRight</span>(<span class="hljs-params">marker</span>) </span>{ <span class="hljs-keyword">return</span> marker.inclusiveRight ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns a number indicating which of two overlapping collapsed
spans is larger (and thus includes the other). Falls back to
comparing ids when the spans cover exactly the same range.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareCollapsedMarkers</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">var</span> lenDiff = a.lines.length - b.lines.length;
    <span class="hljs-keyword">if</span> (lenDiff != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> lenDiff;
    <span class="hljs-keyword">var</span> aPos = a.find(), bPos = b.find();
    <span class="hljs-keyword">var</span> fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    <span class="hljs-keyword">if</span> (fromCmp) <span class="hljs-keyword">return</span> -fromCmp;
    <span class="hljs-keyword">var</span> toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    <span class="hljs-keyword">if</span> (toCmp) <span class="hljs-keyword">return</span> toCmp;
    <span class="hljs-keyword">return</span> b.id - a.id;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find out whether a line ends or starts in a collapsed span. If
so, return the marker for that span.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collapsedSpanAtSide</span>(<span class="hljs-params">line, start</span>) </span>{
    <span class="hljs-keyword">var</span> sps = sawCollapsedSpans &amp;&amp; line.markedSpans, found;
    <span class="hljs-keyword">if</span> (sps) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> sp, i = <span class="hljs-number">0</span>; i &lt; sps.length; ++i) {
      sp = sps[i];
      <span class="hljs-keyword">if</span> (sp.marker.collapsed &amp;&amp; (start ? sp.from : sp.to) == <span class="hljs-literal">null</span> &amp;&amp;
          (!found || compareCollapsedMarkers(found, sp.marker) &lt; <span class="hljs-number">0</span>))
        found = sp.marker;
    }
    <span class="hljs-keyword">return</span> found;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collapsedSpanAtStart</span>(<span class="hljs-params">line</span>) </span>{ <span class="hljs-keyword">return</span> collapsedSpanAtSide(line, <span class="hljs-literal">true</span>); }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collapsedSpanAtEnd</span>(<span class="hljs-params">line</span>) </span>{ <span class="hljs-keyword">return</span> collapsedSpanAtSide(line, <span class="hljs-literal">false</span>); }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Test whether there exists a collapsed span that partially
overlaps (covers the start or end, but not both) of a new span.
Such overlap is not allowed.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">conflictingCollapsedRange</span>(<span class="hljs-params">doc, lineNo, from, to, marker</span>) </span>{
    <span class="hljs-keyword">var</span> line = getLine(doc, lineNo);
    <span class="hljs-keyword">var</span> sps = sawCollapsedSpans &amp;&amp; line.markedSpans;
    <span class="hljs-keyword">if</span> (sps) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; sps.length; ++i) {
      <span class="hljs-keyword">var</span> sp = sps[i];
      <span class="hljs-keyword">if</span> (!sp.marker.collapsed) <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">var</span> found = sp.marker.find(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">var</span> fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      <span class="hljs-keyword">var</span> toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      <span class="hljs-keyword">if</span> (fromCmp &gt;= <span class="hljs-number">0</span> &amp;&amp; toCmp &lt;= <span class="hljs-number">0</span> || fromCmp &lt;= <span class="hljs-number">0</span> &amp;&amp; toCmp &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">if</span> (fromCmp &lt;= <span class="hljs-number">0</span> &amp;&amp; (cmp(found.to, from) &gt; <span class="hljs-number">0</span> || (sp.marker.inclusiveRight &amp;&amp; marker.inclusiveLeft)) ||
          fromCmp &gt;= <span class="hljs-number">0</span> &amp;&amp; (cmp(found.from, to) &lt; <span class="hljs-number">0</span> || (sp.marker.inclusiveLeft &amp;&amp; marker.inclusiveRight)))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A visual line is a line as drawn on the screen. Folding, for
example, can cause multiple logical lines to appear on the same
visual line. This finds the start of the visual line that the
given line is part of (usually that is the line itself).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visualLine</span>(<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">var</span> merged;
    <span class="hljs-keyword">while</span> (merged = collapsedSpanAtStart(line))
      line = merged.find(-<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>).line;
    <span class="hljs-keyword">return</span> line;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns an array of logical lines that continue the visual line
started by the argument, or undefined if there are no such lines.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visualLineContinued</span>(<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">var</span> merged, lines;
    <span class="hljs-keyword">while</span> (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>).line;
      (lines || (lines = [])).push(line);
    }
    <span class="hljs-keyword">return</span> lines;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the line number of the start of the visual line that the
given line number is part of.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visualLineNo</span>(<span class="hljs-params">doc, lineN</span>) </span>{
    <span class="hljs-keyword">var</span> line = getLine(doc, lineN), vis = visualLine(line);
    <span class="hljs-keyword">if</span> (line == vis) <span class="hljs-keyword">return</span> lineN;
    <span class="hljs-keyword">return</span> lineNo(vis);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the line number of the start of the next visual line after
the given line.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visualLineEndNo</span>(<span class="hljs-params">doc, lineN</span>) </span>{
    <span class="hljs-keyword">if</span> (lineN &gt; doc.lastLine()) <span class="hljs-keyword">return</span> lineN;
    <span class="hljs-keyword">var</span> line = getLine(doc, lineN), merged;
    <span class="hljs-keyword">if</span> (!lineIsHidden(doc, line)) <span class="hljs-keyword">return</span> lineN;
    <span class="hljs-keyword">while</span> (merged = collapsedSpanAtEnd(line))
      line = merged.find(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>).line;
    <span class="hljs-keyword">return</span> lineNo(line) + <span class="hljs-number">1</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute whether a line is hidden. Lines count as hidden when they
are part of a visual line that starts with another line, or when
they are entirely covered by collapsed, non-widget span.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineIsHidden</span>(<span class="hljs-params">doc, line</span>) </span>{
    <span class="hljs-keyword">var</span> sps = sawCollapsedSpans &amp;&amp; line.markedSpans;
    <span class="hljs-keyword">if</span> (sps) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> sp, i = <span class="hljs-number">0</span>; i &lt; sps.length; ++i) {
      sp = sps[i];
      <span class="hljs-keyword">if</span> (!sp.marker.collapsed) <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">if</span> (sp.from == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (sp.marker.widgetNode) <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">if</span> (sp.from == <span class="hljs-number">0</span> &amp;&amp; sp.marker.inclusiveLeft &amp;&amp; lineIsHiddenInner(doc, line, sp))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineIsHiddenInner</span>(<span class="hljs-params">doc, line, span</span>) </span>{
    <span class="hljs-keyword">if</span> (span.to == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> end = span.marker.find(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);
      <span class="hljs-keyword">return</span> lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    <span class="hljs-keyword">if</span> (span.marker.inclusiveRight &amp;&amp; span.to == line.text.length)
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> sp, i = <span class="hljs-number">0</span>; i &lt; line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      <span class="hljs-keyword">if</span> (sp.marker.collapsed &amp;&amp; !sp.marker.widgetNode &amp;&amp; sp.from == span.to &amp;&amp;
          (sp.to == <span class="hljs-literal">null</span> || sp.to != span.from) &amp;&amp;
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &amp;&amp;
          lineIsHiddenInner(doc, line, sp)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LINE WIDGETS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Line widgets are block elements displayed above or below a line.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> LineWidget = CodeMirror.LineWidget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc, node, options</span>) </span>{
    <span class="hljs-keyword">if</span> (options) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> opt <span class="hljs-keyword">in</span> options) <span class="hljs-keyword">if</span> (options.hasOwnProperty(opt))
      <span class="hljs-keyword">this</span>[opt] = options[opt];
    <span class="hljs-keyword">this</span>.doc = doc;
    <span class="hljs-keyword">this</span>.node = node;
  };
  eventMixin(LineWidget);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adjustScrollWhenAboveVisible</span>(<span class="hljs-params">cm, line, diff</span>) </span>{
    <span class="hljs-keyword">if</span> (heightAtLine(line) &lt; ((cm.curOp &amp;&amp; cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, <span class="hljs-literal">null</span>, diff);
  }

  LineWidget.prototype.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> cm = <span class="hljs-keyword">this</span>.doc.cm, ws = <span class="hljs-keyword">this</span>.line.widgets, line = <span class="hljs-keyword">this</span>.line, no = lineNo(line);
    <span class="hljs-keyword">if</span> (no == <span class="hljs-literal">null</span> || !ws) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ws.length; ++i) <span class="hljs-keyword">if</span> (ws[i] == <span class="hljs-keyword">this</span>) ws.splice(i--, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (!ws.length) line.widgets = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> height = widgetHeight(<span class="hljs-keyword">this</span>);
    updateLineHeight(line, <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, line.height - height));
    <span class="hljs-keyword">if</span> (cm) runInOp(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, <span class="hljs-string">"widget"</span>);
    });
  };
  LineWidget.prototype.changed = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> oldH = <span class="hljs-keyword">this</span>.height, cm = <span class="hljs-keyword">this</span>.doc.cm, line = <span class="hljs-keyword">this</span>.line;
    <span class="hljs-keyword">this</span>.height = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> diff = widgetHeight(<span class="hljs-keyword">this</span>) - oldH;
    <span class="hljs-keyword">if</span> (!diff) <span class="hljs-keyword">return</span>;
    updateLineHeight(line, line.height + diff);
    <span class="hljs-keyword">if</span> (cm) runInOp(cm, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      cm.curOp.forceUpdate = <span class="hljs-literal">true</span>;
      adjustScrollWhenAboveVisible(cm, line, diff);
    });
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">widgetHeight</span>(<span class="hljs-params">widget</span>) </span>{
    <span class="hljs-keyword">if</span> (widget.height != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> widget.height;
    <span class="hljs-keyword">var</span> cm = widget.doc.cm;
    <span class="hljs-keyword">if</span> (!cm) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (!contains(<span class="hljs-built_in">document</span>.body, widget.node)) {
      <span class="hljs-keyword">var</span> parentStyle = <span class="hljs-string">"position: relative;"</span>;
      <span class="hljs-keyword">if</span> (widget.coverGutter)
        parentStyle += <span class="hljs-string">"margin-left: -"</span> + cm.display.gutters.offsetWidth + <span class="hljs-string">"px;"</span>;
      <span class="hljs-keyword">if</span> (widget.noHScroll)
        parentStyle += <span class="hljs-string">"width: "</span> + cm.display.wrapper.clientWidth + <span class="hljs-string">"px;"</span>;
      removeChildrenAndAdd(cm.display.measure, elt(<span class="hljs-string">"div"</span>, [widget.node], <span class="hljs-literal">null</span>, parentStyle));
    }
    <span class="hljs-keyword">return</span> widget.height = widget.node.parentNode.offsetHeight;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addLineWidget</span>(<span class="hljs-params">doc, handle, node, options</span>) </span>{
    <span class="hljs-keyword">var</span> widget = <span class="hljs-keyword">new</span> LineWidget(doc, node, options);
    <span class="hljs-keyword">var</span> cm = doc.cm;
    <span class="hljs-keyword">if</span> (cm &amp;&amp; widget.noHScroll) cm.display.alignWidgets = <span class="hljs-literal">true</span>;
    changeLine(doc, handle, <span class="hljs-string">"widget"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">var</span> widgets = line.widgets || (line.widgets = []);
      <span class="hljs-keyword">if</span> (widget.insertAt == <span class="hljs-literal">null</span>) widgets.push(widget);
      <span class="hljs-keyword">else</span> widgets.splice(<span class="hljs-built_in">Math</span>.min(widgets.length - <span class="hljs-number">1</span>, <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, widget.insertAt)), <span class="hljs-number">0</span>, widget);
      widget.line = line;
      <span class="hljs-keyword">if</span> (cm &amp;&amp; !lineIsHidden(doc, line)) {
        <span class="hljs-keyword">var</span> aboveVisible = heightAtLine(line) &lt; doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        <span class="hljs-keyword">if</span> (aboveVisible) addToScrollPos(cm, <span class="hljs-literal">null</span>, widget.height);
        cm.curOp.forceUpdate = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    });
    <span class="hljs-keyword">return</span> widget;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LINE DATA STRUCTURE</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Line objects. These hold state related to a line, including
highlighting info (the styles array).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> Line = CodeMirror.Line = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text, markedSpans, estimateHeight</span>) </span>{
    <span class="hljs-keyword">this</span>.text = text;
    attachMarkedSpans(<span class="hljs-keyword">this</span>, markedSpans);
    <span class="hljs-keyword">this</span>.height = estimateHeight ? estimateHeight(<span class="hljs-keyword">this</span>) : <span class="hljs-number">1</span>;
  };
  eventMixin(Line);
  Line.prototype.lineNo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> lineNo(<span class="hljs-keyword">this</span>); };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Change the content (text, markers) of a line. Automatically
invalidates cached information and tries to re-estimate the
line&#39;s height.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateLine</span>(<span class="hljs-params">line, text, markedSpans, estimateHeight</span>) </span>{
    line.text = text;
    <span class="hljs-keyword">if</span> (line.stateAfter) line.stateAfter = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (line.styles) line.styles = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (line.order != <span class="hljs-literal">null</span>) line.order = <span class="hljs-literal">null</span>;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    <span class="hljs-keyword">var</span> estHeight = estimateHeight ? estimateHeight(line) : <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (estHeight != line.height) updateLineHeight(line, estHeight);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Detach a line from the document tree and its markers.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanUpLine</span>(<span class="hljs-params">line</span>) </span>{
    line.parent = <span class="hljs-literal">null</span>;
    detachMarkedSpans(line);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractLineClasses</span>(<span class="hljs-params">type, output</span>) </span>{
    <span class="hljs-keyword">if</span> (type) <span class="hljs-keyword">for</span> (;;) {
      <span class="hljs-keyword">var</span> lineClass = type.match(<span class="hljs-regexp">/(?:^|\s+)line-(background-)?(\S+)/</span>);
      <span class="hljs-keyword">if</span> (!lineClass) <span class="hljs-keyword">break</span>;
      type = type.slice(<span class="hljs-number">0</span>, lineClass.index) + type.slice(lineClass.index + lineClass[<span class="hljs-number">0</span>].length);
      <span class="hljs-keyword">var</span> prop = lineClass[<span class="hljs-number">1</span>] ? <span class="hljs-string">"bgClass"</span> : <span class="hljs-string">"textClass"</span>;
      <span class="hljs-keyword">if</span> (output[prop] == <span class="hljs-literal">null</span>)
        output[prop] = lineClass[<span class="hljs-number">2</span>];
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"(?:^|\s)"</span> + lineClass[<span class="hljs-number">2</span>] + <span class="hljs-string">"(?:$|\s)"</span>)).test(output[prop]))
        output[prop] += <span class="hljs-string">" "</span> + lineClass[<span class="hljs-number">2</span>];
    }
    <span class="hljs-keyword">return</span> type;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callBlankLine</span>(<span class="hljs-params">mode, state</span>) </span>{
    <span class="hljs-keyword">if</span> (mode.blankLine) <span class="hljs-keyword">return</span> mode.blankLine(state);
    <span class="hljs-keyword">if</span> (!mode.innerMode) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> inner = CodeMirror.innerMode(mode, state);
    <span class="hljs-keyword">if</span> (inner.mode.blankLine) <span class="hljs-keyword">return</span> inner.mode.blankLine(inner.state);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readToken</span>(<span class="hljs-params">mode, stream, state, inner</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
      <span class="hljs-keyword">if</span> (inner) inner[<span class="hljs-number">0</span>] = CodeMirror.innerMode(mode, state).mode;
      <span class="hljs-keyword">var</span> style = mode.token(stream, state);
      <span class="hljs-keyword">if</span> (stream.pos &gt; stream.start) <span class="hljs-keyword">return</span> style;
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Mode "</span> + mode.name + <span class="hljs-string">" failed to advance stream."</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Utility for getTokenAt and getLineTokens</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">takeToken</span>(<span class="hljs-params">cm, pos, precise, asArray</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getObj</span>(<span class="hljs-params">copy</span>) </span>{
      <span class="hljs-keyword">return</span> {start: stream.start, end: stream.pos,
              string: stream.current(),
              type: style || <span class="hljs-literal">null</span>,
              state: copy ? copyState(doc.mode, state) : state};
    }

    <span class="hljs-keyword">var</span> doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    <span class="hljs-keyword">var</span> line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
    <span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">new</span> StringStream(line.text, cm.options.tabSize), tokens;
    <span class="hljs-keyword">if</span> (asArray) tokens = [];
    <span class="hljs-keyword">while</span> ((asArray || stream.pos &lt; pos.ch) &amp;&amp; !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, state);
      <span class="hljs-keyword">if</span> (asArray) tokens.push(getObj(<span class="hljs-literal">true</span>));
    }
    <span class="hljs-keyword">return</span> asArray ? tokens : getObj();
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Run the given mode&#39;s parser over a line, calling f for each token.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runMode</span>(<span class="hljs-params">cm, text, mode, state, f, lineClasses, forceToEnd</span>) </span>{
    <span class="hljs-keyword">var</span> flattenSpans = mode.flattenSpans;
    <span class="hljs-keyword">if</span> (flattenSpans == <span class="hljs-literal">null</span>) flattenSpans = cm.options.flattenSpans;
    <span class="hljs-keyword">var</span> curStart = <span class="hljs-number">0</span>, curStyle = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">new</span> StringStream(text, cm.options.tabSize), style;
    <span class="hljs-keyword">var</span> inner = cm.options.addModeClass &amp;&amp; [<span class="hljs-literal">null</span>];
    <span class="hljs-keyword">if</span> (text == <span class="hljs-string">""</span>) extractLineClasses(callBlankLine(mode, state), lineClasses);
    <span class="hljs-keyword">while</span> (!stream.eol()) {
      <span class="hljs-keyword">if</span> (stream.pos &gt; cm.options.maxHighlightLength) {
        flattenSpans = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
      }
      <span class="hljs-keyword">if</span> (inner) {
        <span class="hljs-keyword">var</span> mName = inner[<span class="hljs-number">0</span>].name;
        <span class="hljs-keyword">if</span> (mName) style = <span class="hljs-string">"m-"</span> + (style ? mName + <span class="hljs-string">" "</span> + style : mName);
      }
      <span class="hljs-keyword">if</span> (!flattenSpans || curStyle != style) {
        <span class="hljs-keyword">while</span> (curStart &lt; stream.start) {
          curStart = <span class="hljs-built_in">Math</span>.min(stream.start, curStart + <span class="hljs-number">50000</span>);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    <span class="hljs-keyword">while</span> (curStart &lt; stream.pos) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Webkit seems to refuse to render text nodes longer than 57444 characters</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> pos = <span class="hljs-built_in">Math</span>.min(stream.pos, curStart + <span class="hljs-number">50000</span>);
      f(pos, curStyle);
      curStart = pos;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute a style array (an array starting with a mode generation
-- for invalidation -- followed by pairs of end positions and
style strings), which is used to highlight the tokens on the
line.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">highlightLine</span>(<span class="hljs-params">cm, line, state, forceToEnd</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A styles array always starts with a number identifying the
mode/overlays that it is based on (for easy invalidation).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> st = [cm.state.modeGen], lineClasses = {};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute the base array of styles</p></div></div><div class="code"><div class="wrapper">    runMode(cm, line.text, cm.doc.mode, state, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">end, style</span>) </span>{
      st.push(end, style);
    }, lineClasses, forceToEnd);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Run overlays, adjust style array.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> o = <span class="hljs-number">0</span>; o &lt; cm.state.overlays.length; ++o) {
      <span class="hljs-keyword">var</span> overlay = cm.state.overlays[o], i = <span class="hljs-number">1</span>, at = <span class="hljs-number">0</span>;
      runMode(cm, line.text, overlay.mode, <span class="hljs-literal">true</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">end, style</span>) </span>{
        <span class="hljs-keyword">var</span> start = i;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure there&#39;s a token end at the current position, and that i points at it</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">while</span> (at &lt; end) {
          <span class="hljs-keyword">var</span> i_end = st[i];
          <span class="hljs-keyword">if</span> (i_end &gt; end)
            st.splice(i, <span class="hljs-number">1</span>, end, st[i+<span class="hljs-number">1</span>], i_end);
          i += <span class="hljs-number">2</span>;
          at = <span class="hljs-built_in">Math</span>.min(end, i_end);
        }
        <span class="hljs-keyword">if</span> (!style) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (overlay.opaque) {
          st.splice(start, i - start, end, <span class="hljs-string">"cm-overlay "</span> + style);
          i = start + <span class="hljs-number">2</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">for</span> (; start &lt; i; start += <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">var</span> cur = st[start+<span class="hljs-number">1</span>];
            st[start+<span class="hljs-number">1</span>] = (cur ? cur + <span class="hljs-string">" "</span> : <span class="hljs-string">""</span>) + <span class="hljs-string">"cm-overlay "</span> + style;
          }
        }
      }, lineClasses);
    }

    <span class="hljs-keyword">return</span> {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : <span class="hljs-literal">null</span>};
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLineStyles</span>(<span class="hljs-params">cm, line, updateFrontier</span>) </span>{
    <span class="hljs-keyword">if</span> (!line.styles || line.styles[<span class="hljs-number">0</span>] != cm.state.modeGen) {
      <span class="hljs-keyword">var</span> state = getStateBefore(cm, lineNo(line));
      <span class="hljs-keyword">var</span> result = highlightLine(cm, line, line.text.length &gt; cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
      line.stateAfter = state;
      line.styles = result.styles;
      <span class="hljs-keyword">if</span> (result.classes) line.styleClasses = result.classes;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.styleClasses) line.styleClasses = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">if</span> (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
    }
    <span class="hljs-keyword">return</span> line.styles;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Lightweight form of highlight -- proceed over this line and
update state, but don&#39;t save a style array. Used for lines that
aren&#39;t currently visible.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processLine</span>(<span class="hljs-params">cm, text, state, startAt</span>) </span>{
    <span class="hljs-keyword">var</span> mode = cm.doc.mode;
    <span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">new</span> StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (text == <span class="hljs-string">""</span>) callBlankLine(mode, state);
    <span class="hljs-keyword">while</span> (!stream.eol()) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert a style as returned by a mode (either null, or a string
containing one or more styles) to a CSS style. This is cached,
and also looks for line-wide styles.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> styleToClassCache = {}, styleToClassCacheWithMode = {};
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">interpretTokenStyle</span>(<span class="hljs-params">style, options</span>) </span>{
    <span class="hljs-keyword">if</span> (!style || <span class="hljs-regexp">/^\s*$/</span>.test(style)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    <span class="hljs-keyword">return</span> cache[style] ||
      (cache[style] = style.replace(<span class="hljs-regexp">/\S+/g</span>, <span class="hljs-string">"cm-$&amp;"</span>));
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Render the DOM representation of the text of a line. Also builds
up a &#39;line map&#39;, which points at the DOM nodes that represent
specific stretches of text, and is used by the measuring code.
The returned object contains the DOM node, this map, and
information about line-wide styles that were set by the mode.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildLineContent</span>(<span class="hljs-params">cm, lineView</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The padding-right forces the element to have a &#39;border&#39;, which
is needed on Webkit to be able to get line-level bounding
rectangles for it (in measureChar).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> content = elt(<span class="hljs-string">"span"</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, webkit ? <span class="hljs-string">"padding-right: .1px"</span> : <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">var</span> builder = {pre: elt(<span class="hljs-string">"pre"</span>, [content], <span class="hljs-string">"CodeMirror-line"</span>), content: content,
                   col: <span class="hljs-number">0</span>, pos: <span class="hljs-number">0</span>, cm: cm,
                   splitSpaces: (ie || webkit) &amp;&amp; cm.getOption(<span class="hljs-string">"lineWrapping"</span>)};
    lineView.measure = {};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Iterate over the logical lines that make up this visual line.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= (lineView.rest ? lineView.rest.length : <span class="hljs-number">0</span>); i++) {
      <span class="hljs-keyword">var</span> line = i ? lineView.rest[i - <span class="hljs-number">1</span>] : lineView.line, order;
      builder.pos = <span class="hljs-number">0</span>;
      builder.addToken = buildToken;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Optionally wire in some hacks into the token-rendering
algorithm, to deal with browser quirks.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (hasBadBidiRects(cm.display.measure) &amp;&amp; (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      <span class="hljs-keyword">var</span> allowFrontierUpdate = lineView != cm.display.externalMeasured &amp;&amp; lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      <span class="hljs-keyword">if</span> (line.styleClasses) {
        <span class="hljs-keyword">if</span> (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || <span class="hljs-string">""</span>);
        <span class="hljs-keyword">if</span> (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || <span class="hljs-string">""</span>);
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure at least a single node is present, for measuring.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (builder.map.length == <span class="hljs-number">0</span>)
        builder.map.push(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, builder.content.appendChild(zeroWidthElement(cm.display.measure)));</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store the map and a cache object for the current logical line</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } <span class="hljs-keyword">else</span> {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>See issue #2901</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (webkit &amp;&amp; <span class="hljs-regexp">/\bcm-tab\b/</span>.test(builder.content.lastChild.className))
      builder.content.className = <span class="hljs-string">"cm-tab-wrap-hack"</span>;

    signal(cm, <span class="hljs-string">"renderLine"</span>, cm, lineView.line, builder.pre);
    <span class="hljs-keyword">if</span> (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || <span class="hljs-string">""</span>);

    <span class="hljs-keyword">return</span> builder;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultSpecialCharPlaceholder</span>(<span class="hljs-params">ch</span>) </span>{
    <span class="hljs-keyword">var</span> token = elt(<span class="hljs-string">"span"</span>, <span class="hljs-string">"\u2022"</span>, <span class="hljs-string">"cm-invalidchar"</span>);
    token.title = <span class="hljs-string">"\\u"</span> + ch.charCodeAt(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>);
    token.setAttribute(<span class="hljs-string">"aria-label"</span>, token.title);
    <span class="hljs-keyword">return</span> token;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build up the DOM representation for a single token, and add it to
the line map. Takes care to render special characters separately.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildToken</span>(<span class="hljs-params">builder, text, style, startStyle, endStyle, title, css</span>) </span>{
    <span class="hljs-keyword">if</span> (!text) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> displayText = builder.splitSpaces ? text.replace(<span class="hljs-regexp">/ {3,}/g</span>, splitSpaces) : text;
    <span class="hljs-keyword">var</span> special = builder.cm.state.specialChars, mustWrap = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (!special.test(text)) {
      builder.col += text.length;
      <span class="hljs-keyword">var</span> content = <span class="hljs-built_in">document</span>.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">9</span>) mustWrap = <span class="hljs-literal">true</span>;
      builder.pos += text.length;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> content = <span class="hljs-built_in">document</span>.createDocumentFragment(), pos = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        special.lastIndex = pos;
        <span class="hljs-keyword">var</span> m = special.exec(text);
        <span class="hljs-keyword">var</span> skipped = m ? m.index - pos : text.length - pos;
        <span class="hljs-keyword">if</span> (skipped) {
          <span class="hljs-keyword">var</span> txt = <span class="hljs-built_in">document</span>.createTextNode(displayText.slice(pos, pos + skipped));
          <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">9</span>) content.appendChild(elt(<span class="hljs-string">"span"</span>, [txt]));
          <span class="hljs-keyword">else</span> content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        <span class="hljs-keyword">if</span> (!m) <span class="hljs-keyword">break</span>;
        pos += skipped + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (m[<span class="hljs-number">0</span>] == <span class="hljs-string">"\t"</span>) {
          <span class="hljs-keyword">var</span> tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          <span class="hljs-keyword">var</span> txt = content.appendChild(elt(<span class="hljs-string">"span"</span>, spaceStr(tabWidth), <span class="hljs-string">"cm-tab"</span>));
          txt.setAttribute(<span class="hljs-string">"role"</span>, <span class="hljs-string">"presentation"</span>);
          txt.setAttribute(<span class="hljs-string">"cm-text"</span>, <span class="hljs-string">"\t"</span>);
          builder.col += tabWidth;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m[<span class="hljs-number">0</span>] == <span class="hljs-string">"\r"</span> || m[<span class="hljs-number">0</span>] == <span class="hljs-string">"\n"</span>) {
          <span class="hljs-keyword">var</span> txt = content.appendChild(elt(<span class="hljs-string">"span"</span>, m[<span class="hljs-number">0</span>] == <span class="hljs-string">"\r"</span> ? <span class="hljs-string">"\u240d"</span> : <span class="hljs-string">"\u2424"</span>, <span class="hljs-string">"cm-invalidchar"</span>));
          txt.setAttribute(<span class="hljs-string">"cm-text"</span>, m[<span class="hljs-number">0</span>]);
          builder.col += <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> txt = builder.cm.options.specialCharPlaceholder(m[<span class="hljs-number">0</span>]);
          txt.setAttribute(<span class="hljs-string">"cm-text"</span>, m[<span class="hljs-number">0</span>]);
          <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">9</span>) content.appendChild(elt(<span class="hljs-string">"span"</span>, [txt]));
          <span class="hljs-keyword">else</span> content.appendChild(txt);
          builder.col += <span class="hljs-number">1</span>;
        }
        builder.map.push(builder.pos, builder.pos + <span class="hljs-number">1</span>, txt);
        builder.pos++;
      }
    }
    <span class="hljs-keyword">if</span> (style || startStyle || endStyle || mustWrap || css) {
      <span class="hljs-keyword">var</span> fullStyle = style || <span class="hljs-string">""</span>;
      <span class="hljs-keyword">if</span> (startStyle) fullStyle += startStyle;
      <span class="hljs-keyword">if</span> (endStyle) fullStyle += endStyle;
      <span class="hljs-keyword">var</span> token = elt(<span class="hljs-string">"span"</span>, [content], fullStyle, css);
      <span class="hljs-keyword">if</span> (title) token.title = title;
      <span class="hljs-keyword">return</span> builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">splitSpaces</span>(<span class="hljs-params">old</span>) </span>{
    <span class="hljs-keyword">var</span> out = <span class="hljs-string">" "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; old.length - <span class="hljs-number">2</span>; ++i) out += i % <span class="hljs-number">2</span> ? <span class="hljs-string">" "</span> : <span class="hljs-string">"\u00a0"</span>;
    out += <span class="hljs-string">" "</span>;
    <span class="hljs-keyword">return</span> out;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Work around nonsense dimensions being reported for stretches of
right-to-left text.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildTokenBadBidi</span>(<span class="hljs-params">inner, order</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">builder, text, style, startStyle, endStyle, title, css</span>) </span>{
      style = style ? style + <span class="hljs-string">" cm-force-border"</span> : <span class="hljs-string">"cm-force-border"</span>;
      <span class="hljs-keyword">var</span> start = builder.pos, end = start + text.length;
      <span class="hljs-keyword">for</span> (;;) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the part that overlaps with the start of this text</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; order.length; i++) {
          <span class="hljs-keyword">var</span> part = order[i];
          <span class="hljs-keyword">if</span> (part.to &gt; start &amp;&amp; part.from &lt;= start) <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span> (part.to &gt;= end) <span class="hljs-keyword">return</span> inner(builder, text, style, startStyle, endStyle, title, css);
        inner(builder, text.slice(<span class="hljs-number">0</span>, part.to - start), style, startStyle, <span class="hljs-literal">null</span>, title, css);
        startStyle = <span class="hljs-literal">null</span>;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildCollapsedSpan</span>(<span class="hljs-params">builder, size, marker, ignoreWidget</span>) </span>{
    <span class="hljs-keyword">var</span> widget = !ignoreWidget &amp;&amp; marker.widgetNode;
    <span class="hljs-keyword">if</span> (widget) builder.map.push(builder.pos, builder.pos + size, widget);
    <span class="hljs-keyword">if</span> (!ignoreWidget &amp;&amp; builder.cm.display.input.needsContentAttribute) {
      <span class="hljs-keyword">if</span> (!widget)
        widget = builder.content.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"span"</span>));
      widget.setAttribute(<span class="hljs-string">"cm-marker"</span>, marker.id);
    }
    <span class="hljs-keyword">if</span> (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Outputs a number of spans to make up a line, taking highlighting
and marked text into account.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertLineContent</span>(<span class="hljs-params">line, builder, styles</span>) </span>{
    <span class="hljs-keyword">var</span> spans = line.markedSpans, allText = line.text, at = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (!spans) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; styles.length; i+=<span class="hljs-number">2</span>)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+<span class="hljs-number">1</span>], builder.cm.options));
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> len = allText.length, pos = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>, text = <span class="hljs-string">""</span>, style, css;
    <span class="hljs-keyword">var</span> nextChange = <span class="hljs-number">0</span>, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    <span class="hljs-keyword">for</span> (;;) {
      <span class="hljs-keyword">if</span> (nextChange == pos) { <span class="hljs-comment">// Update current marker set</span>
        spanStyle = spanEndStyle = spanStartStyle = title = css = <span class="hljs-string">""</span>;
        collapsed = <span class="hljs-literal">null</span>; nextChange = <span class="hljs-literal">Infinity</span>;
        <span class="hljs-keyword">var</span> foundBookmarks = [], endStyles
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; spans.length; ++j) {
          <span class="hljs-keyword">var</span> sp = spans[j], m = sp.marker;
          <span class="hljs-keyword">if</span> (m.type == <span class="hljs-string">"bookmark"</span> &amp;&amp; sp.from == pos &amp;&amp; m.widgetNode) {
            foundBookmarks.push(m);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sp.from &lt;= pos &amp;&amp; (sp.to == <span class="hljs-literal">null</span> || sp.to &gt; pos || m.collapsed &amp;&amp; sp.to == pos &amp;&amp; sp.from == pos)) {
            <span class="hljs-keyword">if</span> (sp.to != <span class="hljs-literal">null</span> &amp;&amp; sp.to != pos &amp;&amp; nextChange &gt; sp.to) {
              nextChange = sp.to;
              spanEndStyle = <span class="hljs-string">""</span>;
            }
            <span class="hljs-keyword">if</span> (m.className) spanStyle += <span class="hljs-string">" "</span> + m.className;
            <span class="hljs-keyword">if</span> (m.css) css = (css ? css + <span class="hljs-string">";"</span> : <span class="hljs-string">""</span>) + m.css;
            <span class="hljs-keyword">if</span> (m.startStyle &amp;&amp; sp.from == pos) spanStartStyle += <span class="hljs-string">" "</span> + m.startStyle;
            <span class="hljs-keyword">if</span> (m.endStyle &amp;&amp; sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)
            <span class="hljs-keyword">if</span> (m.title &amp;&amp; !title) title = m.title;
            <span class="hljs-keyword">if</span> (m.collapsed &amp;&amp; (!collapsed || compareCollapsedMarkers(collapsed.marker, m) &lt; <span class="hljs-number">0</span>))
              collapsed = sp;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sp.from &gt; pos &amp;&amp; nextChange &gt; sp.from) {
            nextChange = sp.from;
          }
        }
        <span class="hljs-keyword">if</span> (endStyles) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; endStyles.length; j += <span class="hljs-number">2</span>)
          <span class="hljs-keyword">if</span> (endStyles[j + <span class="hljs-number">1</span>] == nextChange) spanEndStyle += <span class="hljs-string">" "</span> + endStyles[j]

        <span class="hljs-keyword">if</span> (!collapsed || collapsed.from == pos) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, <span class="hljs-number">0</span>, foundBookmarks[j]);
        <span class="hljs-keyword">if</span> (collapsed &amp;&amp; (collapsed.from || <span class="hljs-number">0</span>) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == <span class="hljs-literal">null</span> ? len + <span class="hljs-number">1</span> : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == <span class="hljs-literal">null</span>);
          <span class="hljs-keyword">if</span> (collapsed.to == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
          <span class="hljs-keyword">if</span> (collapsed.to == pos) collapsed = <span class="hljs-literal">false</span>;
        }
      }
      <span class="hljs-keyword">if</span> (pos &gt;= len) <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">var</span> upto = <span class="hljs-built_in">Math</span>.min(len, nextChange);
      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (text) {
          <span class="hljs-keyword">var</span> end = pos + text.length;
          <span class="hljs-keyword">if</span> (!collapsed) {
            <span class="hljs-keyword">var</span> tokenText = end &gt; upto ? text.slice(<span class="hljs-number">0</span>, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : <span class="hljs-string">""</span>, title, css);
          }
          <span class="hljs-keyword">if</span> (end &gt;= upto) {text = text.slice(upto - pos); pos = upto; <span class="hljs-keyword">break</span>;}
          pos = end;
          spanStartStyle = <span class="hljs-string">""</span>;
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DOCUMENT DATA STRUCTURE</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>By default, updates that start and end at the beginning of a line
are treated specially, in order to make the association of line
widgets and marker elements with the text behave more intuitive.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWholeLineUpdate</span>(<span class="hljs-params">doc, change</span>) </span>{
    <span class="hljs-keyword">return</span> change.from.ch == <span class="hljs-number">0</span> &amp;&amp; change.to.ch == <span class="hljs-number">0</span> &amp;&amp; lst(change.text) == <span class="hljs-string">""</span> &amp;&amp;
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Perform a change on the document data structure.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateDoc</span>(<span class="hljs-params">doc, change, markedSpans, estimateHeight</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spansFor</span>(<span class="hljs-params">n</span>) </span>{<span class="hljs-keyword">return</span> markedSpans ? markedSpans[n] : <span class="hljs-literal">null</span>;}
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">line, text, spans</span>) </span>{
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, <span class="hljs-string">"change"</span>, line, change);
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">linesFor</span>(<span class="hljs-params">start, end</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start, result = []; i &lt; end; ++i)
        result.push(<span class="hljs-keyword">new</span> Line(text[i], spansFor(i), estimateHeight));
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">var</span> from = change.from, to = change.to, text = change.text;
    <span class="hljs-keyword">var</span> firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    <span class="hljs-keyword">var</span> lastText = lst(text), lastSpans = spansFor(text.length - <span class="hljs-number">1</span>), nlines = to.line - from.line;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Adjust the line structure</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (change.full) {
      doc.insert(<span class="hljs-number">0</span>, linesFor(<span class="hljs-number">0</span>, text.length));
      doc.remove(text.length, doc.size - text.length);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isWholeLineUpdate(doc, change)) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is a whole-line replace. Treated specially to make
sure line objects move the way they are supposed to.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> added = linesFor(<span class="hljs-number">0</span>, text.length - <span class="hljs-number">1</span>);
      update(lastLine, lastLine.text, lastSpans);
      <span class="hljs-keyword">if</span> (nlines) doc.remove(from.line, nlines);
      <span class="hljs-keyword">if</span> (added.length) doc.insert(from.line, added);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstLine == lastLine) {
      <span class="hljs-keyword">if</span> (text.length == <span class="hljs-number">1</span>) {
        update(firstLine, firstLine.text.slice(<span class="hljs-number">0</span>, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> added = linesFor(<span class="hljs-number">1</span>, text.length - <span class="hljs-number">1</span>);
        added.push(<span class="hljs-keyword">new</span> Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(<span class="hljs-number">0</span>, from.ch) + text[<span class="hljs-number">0</span>], spansFor(<span class="hljs-number">0</span>));
        doc.insert(from.line + <span class="hljs-number">1</span>, added);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (text.length == <span class="hljs-number">1</span>) {
      update(firstLine, firstLine.text.slice(<span class="hljs-number">0</span>, from.ch) + text[<span class="hljs-number">0</span>] + lastLine.text.slice(to.ch), spansFor(<span class="hljs-number">0</span>));
      doc.remove(from.line + <span class="hljs-number">1</span>, nlines);
    } <span class="hljs-keyword">else</span> {
      update(firstLine, firstLine.text.slice(<span class="hljs-number">0</span>, from.ch) + text[<span class="hljs-number">0</span>], spansFor(<span class="hljs-number">0</span>));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      <span class="hljs-keyword">var</span> added = linesFor(<span class="hljs-number">1</span>, text.length - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (nlines &gt; <span class="hljs-number">1</span>) doc.remove(from.line + <span class="hljs-number">1</span>, nlines - <span class="hljs-number">1</span>);
      doc.insert(from.line + <span class="hljs-number">1</span>, added);
    }

    signalLater(doc, <span class="hljs-string">"change"</span>, doc, change);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The document is represented as a BTree consisting of leaves, with
chunk of lines in them, and branches, with up to ten leaves or
other branch nodes below them. The top node is always a branch
node, and is the document object itself (meaning it has
additional methods and properties).</p>
<p>All nodes have parent links. The tree is used both to go from
line numbers to line objects, and to go from objects to numbers.
It also indexes by height, and is used to convert between height
and line object, and to find the total height of the document.</p>
<p>See also <a href="http://marijnhaverbeke.nl/blog/codemirror-line-tree.html">http://marijnhaverbeke.nl/blog/codemirror-line-tree.html</a></p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LeafChunk</span>(<span class="hljs-params">lines</span>) </span>{
    <span class="hljs-keyword">this</span>.lines = lines;
    <span class="hljs-keyword">this</span>.parent = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span>; i &lt; lines.length; ++i) {
      lines[i].parent = <span class="hljs-keyword">this</span>;
      height += lines[i].height;
    }
    <span class="hljs-keyword">this</span>.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lines.length; },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove the n lines at offset &#39;at&#39;.</p></div></div><div class="code"><div class="wrapper">    removeInner: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">at, n</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = at, e = at + n; i &lt; e; ++i) {
        <span class="hljs-keyword">var</span> line = <span class="hljs-keyword">this</span>.lines[i];
        <span class="hljs-keyword">this</span>.height -= line.height;
        cleanUpLine(line);
        signalLater(line, <span class="hljs-string">"delete"</span>);
      }
      <span class="hljs-keyword">this</span>.lines.splice(at, n);
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Helper used to collapse a small branch into a single leaf.</p></div></div><div class="code"><div class="wrapper">    collapse: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lines</span>) </span>{
      lines.push.apply(lines, <span class="hljs-keyword">this</span>.lines);
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Insert the given array of lines at offset &#39;at&#39;, count them as
having the given height.</p></div></div><div class="code"><div class="wrapper">    insertInner: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">at, lines, height</span>) </span>{
      <span class="hljs-keyword">this</span>.height += height;
      <span class="hljs-keyword">this</span>.lines = <span class="hljs-keyword">this</span>.lines.slice(<span class="hljs-number">0</span>, at).concat(lines).concat(<span class="hljs-keyword">this</span>.lines.slice(at));
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lines.length; ++i) lines[i].parent = <span class="hljs-keyword">this</span>;
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to iterate over a part of the tree.</p></div></div><div class="code"><div class="wrapper">    iterN: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">at, n, op</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e = at + n; at &lt; e; ++at)
        <span class="hljs-keyword">if</span> (op(<span class="hljs-keyword">this</span>.lines[at])) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BranchChunk</span>(<span class="hljs-params">children</span>) </span>{
    <span class="hljs-keyword">this</span>.children = children;
    <span class="hljs-keyword">var</span> size = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; children.length; ++i) {
      <span class="hljs-keyword">var</span> ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = <span class="hljs-keyword">this</span>;
    }
    <span class="hljs-keyword">this</span>.size = size;
    <span class="hljs-keyword">this</span>.height = height;
    <span class="hljs-keyword">this</span>.parent = <span class="hljs-literal">null</span>;
  }

  BranchChunk.prototype = {
    chunkSize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size; },
    removeInner: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">at, n</span>) </span>{
      <span class="hljs-keyword">this</span>.size -= n;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.children.length; ++i) {
        <span class="hljs-keyword">var</span> child = <span class="hljs-keyword">this</span>.children[i], sz = child.chunkSize();
        <span class="hljs-keyword">if</span> (at &lt; sz) {
          <span class="hljs-keyword">var</span> rm = <span class="hljs-built_in">Math</span>.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          <span class="hljs-keyword">this</span>.height -= oldHeight - child.height;
          <span class="hljs-keyword">if</span> (sz == rm) { <span class="hljs-keyword">this</span>.children.splice(i--, <span class="hljs-number">1</span>); child.parent = <span class="hljs-literal">null</span>; }
          <span class="hljs-keyword">if</span> ((n -= rm) == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
          at = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> at -= sz;
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the result is smaller than 25 lines, ensure that it is a
single leaf node.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.size - n &lt; <span class="hljs-number">25</span> &amp;&amp;
          (<span class="hljs-keyword">this</span>.children.length &gt; <span class="hljs-number">1</span> || !(<span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> LeafChunk))) {
        <span class="hljs-keyword">var</span> lines = [];
        <span class="hljs-keyword">this</span>.collapse(lines);
        <span class="hljs-keyword">this</span>.children = [<span class="hljs-keyword">new</span> LeafChunk(lines)];
        <span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>].parent = <span class="hljs-keyword">this</span>;
      }
    },
    collapse: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lines</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.children.length; ++i) <span class="hljs-keyword">this</span>.children[i].collapse(lines);
    },
    insertInner: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">at, lines, height</span>) </span>{
      <span class="hljs-keyword">this</span>.size += lines.length;
      <span class="hljs-keyword">this</span>.height += height;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.children.length; ++i) {
        <span class="hljs-keyword">var</span> child = <span class="hljs-keyword">this</span>.children[i], sz = child.chunkSize();
        <span class="hljs-keyword">if</span> (at &lt;= sz) {
          child.insertInner(at, lines, height);
          <span class="hljs-keyword">if</span> (child.lines &amp;&amp; child.lines.length &gt; <span class="hljs-number">50</span>) {
            <span class="hljs-keyword">while</span> (child.lines.length &gt; <span class="hljs-number">50</span>) {
              <span class="hljs-keyword">var</span> spilled = child.lines.splice(child.lines.length - <span class="hljs-number">25</span>, <span class="hljs-number">25</span>);
              <span class="hljs-keyword">var</span> newleaf = <span class="hljs-keyword">new</span> LeafChunk(spilled);
              child.height -= newleaf.height;
              <span class="hljs-keyword">this</span>.children.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, newleaf);
              newleaf.parent = <span class="hljs-keyword">this</span>;
            }
            <span class="hljs-keyword">this</span>.maybeSpill();
          }
          <span class="hljs-keyword">break</span>;
        }
        at -= sz;
      }
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When a node has grown, check whether it should be split.</p></div></div><div class="code"><div class="wrapper">    maybeSpill: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.children.length &lt;= <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">var</span> me = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">var</span> spilled = me.children.splice(me.children.length - <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);
        <span class="hljs-keyword">var</span> sibling = <span class="hljs-keyword">new</span> BranchChunk(spilled);
        <span class="hljs-keyword">if</span> (!me.parent) { <span class="hljs-comment">// Become the parent node</span>
          <span class="hljs-keyword">var</span> copy = <span class="hljs-keyword">new</span> BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } <span class="hljs-keyword">else</span> {
          me.size -= sibling.size;
          me.height -= sibling.height;
          <span class="hljs-keyword">var</span> myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, sibling);
        }
        sibling.parent = me.parent;
      } <span class="hljs-keyword">while</span> (me.children.length &gt; <span class="hljs-number">10</span>);
      me.parent.maybeSpill();
    },
    iterN: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">at, n, op</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.children.length; ++i) {
        <span class="hljs-keyword">var</span> child = <span class="hljs-keyword">this</span>.children[i], sz = child.chunkSize();
        <span class="hljs-keyword">if</span> (at &lt; sz) {
          <span class="hljs-keyword">var</span> used = <span class="hljs-built_in">Math</span>.min(n, sz - at);
          <span class="hljs-keyword">if</span> (child.iterN(at, used, op)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">if</span> ((n -= used) == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
          at = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> at -= sz;
      }
    }
  };

  <span class="hljs-keyword">var</span> nextDocId = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> Doc = CodeMirror.Doc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text, mode, firstLine, lineSep</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Doc)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Doc(text, mode, firstLine, lineSep);
    <span class="hljs-keyword">if</span> (firstLine == <span class="hljs-literal">null</span>) firstLine = <span class="hljs-number">0</span>;

    BranchChunk.call(<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">new</span> LeafChunk([<span class="hljs-keyword">new</span> Line(<span class="hljs-string">""</span>, <span class="hljs-literal">null</span>)])]);
    <span class="hljs-keyword">this</span>.first = firstLine;
    <span class="hljs-keyword">this</span>.scrollTop = <span class="hljs-keyword">this</span>.scrollLeft = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.cantEdit = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.cleanGeneration = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">this</span>.frontier = firstLine;
    <span class="hljs-keyword">var</span> start = Pos(firstLine, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">this</span>.sel = simpleSelection(start);
    <span class="hljs-keyword">this</span>.history = <span class="hljs-keyword">new</span> History(<span class="hljs-literal">null</span>);
    <span class="hljs-keyword">this</span>.id = ++nextDocId;
    <span class="hljs-keyword">this</span>.modeOption = mode;
    <span class="hljs-keyword">this</span>.lineSep = lineSep;
    <span class="hljs-keyword">this</span>.extend = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> text == <span class="hljs-string">"string"</span>) text = <span class="hljs-keyword">this</span>.splitLines(text);
    updateDoc(<span class="hljs-keyword">this</span>, {from: start, to: start, text: text});
    setSelection(<span class="hljs-keyword">this</span>, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Iterate over the document. Supports two forms -- with only one
argument, it calls that for each line in the document. With
three, it iterates over the range given by the first two (with
the second being non-inclusive).</p></div></div><div class="code"><div class="wrapper">    iter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, to, op</span>) </span>{
      <span class="hljs-keyword">if</span> (op) <span class="hljs-keyword">this</span>.iterN(from - <span class="hljs-keyword">this</span>.first, to - from, op);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span>.iterN(<span class="hljs-keyword">this</span>.first, <span class="hljs-keyword">this</span>.first + <span class="hljs-keyword">this</span>.size, from);
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Non-public interface for adding and removing lines.</p></div></div><div class="code"><div class="wrapper">    insert: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">at, lines</span>) </span>{
      <span class="hljs-keyword">var</span> height = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lines.length; ++i) height += lines[i].height;
      <span class="hljs-keyword">this</span>.insertInner(at - <span class="hljs-keyword">this</span>.first, lines, height);
    },
    remove: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">at, n</span>) </span>{ <span class="hljs-keyword">this</span>.removeInner(at - <span class="hljs-keyword">this</span>.first, n); },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>From here, the methods are part of the public interface. Most
are also available from CodeMirror (editor) instances.</p></div></div><div class="code"><div class="wrapper">    getValue: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lineSep</span>) </span>{
      <span class="hljs-keyword">var</span> lines = getLines(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.first, <span class="hljs-keyword">this</span>.first + <span class="hljs-keyword">this</span>.size);
      <span class="hljs-keyword">if</span> (lineSep === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> lines;
      <span class="hljs-keyword">return</span> lines.join(lineSep || <span class="hljs-keyword">this</span>.lineSeparator());
    },
    setValue: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">code</span>) </span>{
      <span class="hljs-keyword">var</span> top = Pos(<span class="hljs-keyword">this</span>.first, <span class="hljs-number">0</span>), last = <span class="hljs-keyword">this</span>.first + <span class="hljs-keyword">this</span>.size - <span class="hljs-number">1</span>;
      makeChange(<span class="hljs-keyword">this</span>, {from: top, to: Pos(last, getLine(<span class="hljs-keyword">this</span>, last).text.length),
                        text: <span class="hljs-keyword">this</span>.splitLines(code), origin: <span class="hljs-string">"setValue"</span>, full: <span class="hljs-literal">true</span>}, <span class="hljs-literal">true</span>);
      setSelection(<span class="hljs-keyword">this</span>, simpleSelection(top));
    }),
    replaceRange: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">code, from, to, origin</span>) </span>{
      from = clipPos(<span class="hljs-keyword">this</span>, from);
      to = to ? clipPos(<span class="hljs-keyword">this</span>, to) : from;
      replaceRange(<span class="hljs-keyword">this</span>, code, from, to, origin);
    },
    getRange: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, to, lineSep</span>) </span>{
      <span class="hljs-keyword">var</span> lines = getBetween(<span class="hljs-keyword">this</span>, clipPos(<span class="hljs-keyword">this</span>, from), clipPos(<span class="hljs-keyword">this</span>, to));
      <span class="hljs-keyword">if</span> (lineSep === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> lines;
      <span class="hljs-keyword">return</span> lines.join(lineSep || <span class="hljs-keyword">this</span>.lineSeparator());
    },

    getLine: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{<span class="hljs-keyword">var</span> l = <span class="hljs-keyword">this</span>.getLineHandle(line); <span class="hljs-keyword">return</span> l &amp;&amp; l.text;},

    getLineHandle: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{<span class="hljs-keyword">if</span> (isLine(<span class="hljs-keyword">this</span>, line)) <span class="hljs-keyword">return</span> getLine(<span class="hljs-keyword">this</span>, line);},
    getLineNumber: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{<span class="hljs-keyword">return</span> lineNo(line);},

    getLineHandleVisualStart: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> line == <span class="hljs-string">"number"</span>) line = getLine(<span class="hljs-keyword">this</span>, line);
      <span class="hljs-keyword">return</span> visualLine(line);
    },

    lineCount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size;},
    firstLine: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.first;},
    lastLine: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.first + <span class="hljs-keyword">this</span>.size - <span class="hljs-number">1</span>;},

    clipPos: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{<span class="hljs-keyword">return</span> clipPos(<span class="hljs-keyword">this</span>, pos);},

    getCursor: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">start</span>) </span>{
      <span class="hljs-keyword">var</span> range = <span class="hljs-keyword">this</span>.sel.primary(), pos;
      <span class="hljs-keyword">if</span> (start == <span class="hljs-literal">null</span> || start == <span class="hljs-string">"head"</span>) pos = range.head;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start == <span class="hljs-string">"anchor"</span>) pos = range.anchor;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start == <span class="hljs-string">"end"</span> || start == <span class="hljs-string">"to"</span> || start === <span class="hljs-literal">false</span>) pos = range.to();
      <span class="hljs-keyword">else</span> pos = range.from();
      <span class="hljs-keyword">return</span> pos;
    },
    listSelections: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sel.ranges; },
    somethingSelected: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sel.somethingSelected();},

    setCursor: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line, ch, options</span>) </span>{
      setSimpleSelection(<span class="hljs-keyword">this</span>, clipPos(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">typeof</span> line == <span class="hljs-string">"number"</span> ? Pos(line, ch || <span class="hljs-number">0</span>) : line), <span class="hljs-literal">null</span>, options);
    }),
    setSelection: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">anchor, head, options</span>) </span>{
      setSimpleSelection(<span class="hljs-keyword">this</span>, clipPos(<span class="hljs-keyword">this</span>, anchor), clipPos(<span class="hljs-keyword">this</span>, head || anchor), options);
    }),
    extendSelection: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, other, options</span>) </span>{
      extendSelection(<span class="hljs-keyword">this</span>, clipPos(<span class="hljs-keyword">this</span>, head), other &amp;&amp; clipPos(<span class="hljs-keyword">this</span>, other), options);
    }),
    extendSelections: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">heads, options</span>) </span>{
      extendSelections(<span class="hljs-keyword">this</span>, clipPosArray(<span class="hljs-keyword">this</span>, heads), options);
    }),
    extendSelectionsBy: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f, options</span>) </span>{
      <span class="hljs-keyword">var</span> heads = map(<span class="hljs-keyword">this</span>.sel.ranges, f);
      extendSelections(<span class="hljs-keyword">this</span>, clipPosArray(<span class="hljs-keyword">this</span>, heads), options);
    }),
    setSelections: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ranges, primary, options</span>) </span>{
      <span class="hljs-keyword">if</span> (!ranges.length) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, out = []; i &lt; ranges.length; i++)
        out[i] = <span class="hljs-keyword">new</span> Range(clipPos(<span class="hljs-keyword">this</span>, ranges[i].anchor),
                           clipPos(<span class="hljs-keyword">this</span>, ranges[i].head));
      <span class="hljs-keyword">if</span> (primary == <span class="hljs-literal">null</span>) primary = <span class="hljs-built_in">Math</span>.min(ranges.length - <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.sel.primIndex);
      setSelection(<span class="hljs-keyword">this</span>, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">anchor, head, options</span>) </span>{
      <span class="hljs-keyword">var</span> ranges = <span class="hljs-keyword">this</span>.sel.ranges.slice(<span class="hljs-number">0</span>);
      ranges.push(<span class="hljs-keyword">new</span> Range(clipPos(<span class="hljs-keyword">this</span>, anchor), clipPos(<span class="hljs-keyword">this</span>, head || anchor)));
      setSelection(<span class="hljs-keyword">this</span>, normalizeSelection(ranges, ranges.length - <span class="hljs-number">1</span>), options);
    }),

    getSelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lineSep</span>) </span>{
      <span class="hljs-keyword">var</span> ranges = <span class="hljs-keyword">this</span>.sel.ranges, lines;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ranges.length; i++) {
        <span class="hljs-keyword">var</span> sel = getBetween(<span class="hljs-keyword">this</span>, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      <span class="hljs-keyword">if</span> (lineSep === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> lines;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> lines.join(lineSep || <span class="hljs-keyword">this</span>.lineSeparator());
    },
    getSelections: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lineSep</span>) </span>{
      <span class="hljs-keyword">var</span> parts = [], ranges = <span class="hljs-keyword">this</span>.sel.ranges;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ranges.length; i++) {
        <span class="hljs-keyword">var</span> sel = getBetween(<span class="hljs-keyword">this</span>, ranges[i].from(), ranges[i].to());
        <span class="hljs-keyword">if</span> (lineSep !== <span class="hljs-literal">false</span>) sel = sel.join(lineSep || <span class="hljs-keyword">this</span>.lineSeparator());
        parts[i] = sel;
      }
      <span class="hljs-keyword">return</span> parts;
    },
    replaceSelection: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">code, collapse, origin</span>) </span>{
      <span class="hljs-keyword">var</span> dup = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.sel.ranges.length; i++)
        dup[i] = code;
      <span class="hljs-keyword">this</span>.replaceSelections(dup, collapse, origin || <span class="hljs-string">"+input"</span>);
    },
    replaceSelections: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">code, collapse, origin</span>) </span>{
      <span class="hljs-keyword">var</span> changes = [], sel = <span class="hljs-keyword">this</span>.sel;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; sel.ranges.length; i++) {
        <span class="hljs-keyword">var</span> range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: <span class="hljs-keyword">this</span>.splitLines(code[i]), origin: origin};
      }
      <span class="hljs-keyword">var</span> newSel = collapse &amp;&amp; collapse != <span class="hljs-string">"end"</span> &amp;&amp; computeReplacedSel(<span class="hljs-keyword">this</span>, changes, collapse);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = changes.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
        makeChange(<span class="hljs-keyword">this</span>, changes[i]);
      <span class="hljs-keyword">if</span> (newSel) setSelectionReplaceHistory(<span class="hljs-keyword">this</span>, newSel);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cm) ensureCursorVisible(<span class="hljs-keyword">this</span>.cm);
    }),
    undo: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{makeChangeFromHistory(<span class="hljs-keyword">this</span>, <span class="hljs-string">"undo"</span>);}),
    redo: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{makeChangeFromHistory(<span class="hljs-keyword">this</span>, <span class="hljs-string">"redo"</span>);}),
    undoSelection: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{makeChangeFromHistory(<span class="hljs-keyword">this</span>, <span class="hljs-string">"undo"</span>, <span class="hljs-literal">true</span>);}),
    redoSelection: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{makeChangeFromHistory(<span class="hljs-keyword">this</span>, <span class="hljs-string">"redo"</span>, <span class="hljs-literal">true</span>);}),

    setExtending: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{<span class="hljs-keyword">this</span>.extend = val;},
    getExtending: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.extend;},

    historySize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> hist = <span class="hljs-keyword">this</span>.history, done = <span class="hljs-number">0</span>, undone = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; hist.done.length; i++) <span class="hljs-keyword">if</span> (!hist.done[i].ranges) ++done;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; hist.undone.length; i++) <span class="hljs-keyword">if</span> (!hist.undone[i].ranges) ++undone;
      <span class="hljs-keyword">return</span> {undo: done, redo: undone};
    },
    clearHistory: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">this</span>.history = <span class="hljs-keyword">new</span> History(<span class="hljs-keyword">this</span>.history.maxGeneration);},

    markClean: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.cleanGeneration = <span class="hljs-keyword">this</span>.changeGeneration(<span class="hljs-literal">true</span>);
    },
    changeGeneration: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">forceSplit</span>) </span>{
      <span class="hljs-keyword">if</span> (forceSplit)
        <span class="hljs-keyword">this</span>.history.lastOp = <span class="hljs-keyword">this</span>.history.lastSelOp = <span class="hljs-keyword">this</span>.history.lastOrigin = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history.generation;
    },
    isClean: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">gen</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history.generation == (gen || <span class="hljs-keyword">this</span>.cleanGeneration);
    },

    getHistory: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> {done: copyHistoryArray(<span class="hljs-keyword">this</span>.history.done),
              undone: copyHistoryArray(<span class="hljs-keyword">this</span>.history.undone)};
    },
    setHistory: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">histData</span>) </span>{
      <span class="hljs-keyword">var</span> hist = <span class="hljs-keyword">this</span>.history = <span class="hljs-keyword">new</span> History(<span class="hljs-keyword">this</span>.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(<span class="hljs-number">0</span>), <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
      hist.undone = copyHistoryArray(histData.undone.slice(<span class="hljs-number">0</span>), <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
    },

    addLineClass: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">handle, where, cls</span>) </span>{
      <span class="hljs-keyword">return</span> changeLine(<span class="hljs-keyword">this</span>, handle, where == <span class="hljs-string">"gutter"</span> ? <span class="hljs-string">"gutter"</span> : <span class="hljs-string">"class"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">var</span> prop = where == <span class="hljs-string">"text"</span> ? <span class="hljs-string">"textClass"</span>
                 : where == <span class="hljs-string">"background"</span> ? <span class="hljs-string">"bgClass"</span>
                 : where == <span class="hljs-string">"gutter"</span> ? <span class="hljs-string">"gutterClass"</span> : <span class="hljs-string">"wrapClass"</span>;
        <span class="hljs-keyword">if</span> (!line[prop]) line[prop] = cls;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (classTest(cls).test(line[prop])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">else</span> line[prop] += <span class="hljs-string">" "</span> + cls;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      });
    }),
    removeLineClass: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">handle, where, cls</span>) </span>{
      <span class="hljs-keyword">return</span> changeLine(<span class="hljs-keyword">this</span>, handle, where == <span class="hljs-string">"gutter"</span> ? <span class="hljs-string">"gutter"</span> : <span class="hljs-string">"class"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">var</span> prop = where == <span class="hljs-string">"text"</span> ? <span class="hljs-string">"textClass"</span>
                 : where == <span class="hljs-string">"background"</span> ? <span class="hljs-string">"bgClass"</span>
                 : where == <span class="hljs-string">"gutter"</span> ? <span class="hljs-string">"gutterClass"</span> : <span class="hljs-string">"wrapClass"</span>;
        <span class="hljs-keyword">var</span> cur = line[prop];
        <span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cls == <span class="hljs-literal">null</span>) line[prop] = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> found = cur.match(classTest(cls));
          <span class="hljs-keyword">if</span> (!found) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">var</span> end = found.index + found[<span class="hljs-number">0</span>].length;
          line[prop] = cur.slice(<span class="hljs-number">0</span>, found.index) + (!found.index || end == cur.length ? <span class="hljs-string">""</span> : <span class="hljs-string">" "</span>) + cur.slice(end) || <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      });
    }),

    addLineWidget: docMethodOp(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">handle, node, options</span>) </span>{
      <span class="hljs-keyword">return</span> addLineWidget(<span class="hljs-keyword">this</span>, handle, node, options);
    }),
    removeLineWidget: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">widget</span>) </span>{ widget.clear(); },

    markText: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, to, options</span>) </span>{
      <span class="hljs-keyword">return</span> markText(<span class="hljs-keyword">this</span>, clipPos(<span class="hljs-keyword">this</span>, from), clipPos(<span class="hljs-keyword">this</span>, to), options, options &amp;&amp; options.type || <span class="hljs-string">"range"</span>);
    },
    setBookmark: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, options</span>) </span>{
      <span class="hljs-keyword">var</span> realOpts = {replacedWith: options &amp;&amp; (options.nodeType == <span class="hljs-literal">null</span> ? options.widget : options),
                      insertLeft: options &amp;&amp; options.insertLeft,
                      clearWhenEmpty: <span class="hljs-literal">false</span>, shared: options &amp;&amp; options.shared,
                      handleMouseEvents: options &amp;&amp; options.handleMouseEvents};
      pos = clipPos(<span class="hljs-keyword">this</span>, pos);
      <span class="hljs-keyword">return</span> markText(<span class="hljs-keyword">this</span>, pos, pos, realOpts, <span class="hljs-string">"bookmark"</span>);
    },
    findMarksAt: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
      pos = clipPos(<span class="hljs-keyword">this</span>, pos);
      <span class="hljs-keyword">var</span> markers = [], spans = getLine(<span class="hljs-keyword">this</span>, pos.line).markedSpans;
      <span class="hljs-keyword">if</span> (spans) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; spans.length; ++i) {
        <span class="hljs-keyword">var</span> span = spans[i];
        <span class="hljs-keyword">if</span> ((span.from == <span class="hljs-literal">null</span> || span.from &lt;= pos.ch) &amp;&amp;
            (span.to == <span class="hljs-literal">null</span> || span.to &gt;= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      <span class="hljs-keyword">return</span> markers;
    },
    findMarks: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, to, filter</span>) </span>{
      from = clipPos(<span class="hljs-keyword">this</span>, from); to = clipPos(<span class="hljs-keyword">this</span>, to);
      <span class="hljs-keyword">var</span> found = [], lineNo = from.line;
      <span class="hljs-keyword">this</span>.iter(from.line, to.line + <span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">var</span> spans = line.markedSpans;
        <span class="hljs-keyword">if</span> (spans) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; spans.length; i++) {
          <span class="hljs-keyword">var</span> span = spans[i];
          <span class="hljs-keyword">if</span> (!(span.to != <span class="hljs-literal">null</span> &amp;&amp; lineNo == from.line &amp;&amp; from.ch &gt;= span.to ||
                span.from == <span class="hljs-literal">null</span> &amp;&amp; lineNo != from.line ||
                span.from != <span class="hljs-literal">null</span> &amp;&amp; lineNo == to.line &amp;&amp; span.from &gt;= to.ch) &amp;&amp;
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      <span class="hljs-keyword">return</span> found;
    },
    getAllMarks: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> markers = [];
      <span class="hljs-keyword">this</span>.iter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">var</span> sps = line.markedSpans;
        <span class="hljs-keyword">if</span> (sps) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; sps.length; ++i)
          <span class="hljs-keyword">if</span> (sps[i].from != <span class="hljs-literal">null</span>) markers.push(sps[i].marker);
      });
      <span class="hljs-keyword">return</span> markers;
    },

    posFromIndex: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">off</span>) </span>{
      <span class="hljs-keyword">var</span> ch, lineNo = <span class="hljs-keyword">this</span>.first, sepSize = <span class="hljs-keyword">this</span>.lineSeparator().length;
      <span class="hljs-keyword">this</span>.iter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
        <span class="hljs-keyword">var</span> sz = line.text.length + sepSize;
        <span class="hljs-keyword">if</span> (sz &gt; off) { ch = off; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
        off -= sz;
        ++lineNo;
      });
      <span class="hljs-keyword">return</span> clipPos(<span class="hljs-keyword">this</span>, Pos(lineNo, ch));
    },
    indexFromPos: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">coords</span>) </span>{
      coords = clipPos(<span class="hljs-keyword">this</span>, coords);
      <span class="hljs-keyword">var</span> index = coords.ch;
      <span class="hljs-keyword">if</span> (coords.line &lt; <span class="hljs-keyword">this</span>.first || coords.ch &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> sepSize = <span class="hljs-keyword">this</span>.lineSeparator().length;
      <span class="hljs-keyword">this</span>.iter(<span class="hljs-keyword">this</span>.first, coords.line, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">line</span>) </span>{
        index += line.text.length + sepSize;
      });
      <span class="hljs-keyword">return</span> index;
    },

    copy: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">copyHistory</span>) </span>{
      <span class="hljs-keyword">var</span> doc = <span class="hljs-keyword">new</span> Doc(getLines(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.first, <span class="hljs-keyword">this</span>.first + <span class="hljs-keyword">this</span>.size),
                        <span class="hljs-keyword">this</span>.modeOption, <span class="hljs-keyword">this</span>.first, <span class="hljs-keyword">this</span>.lineSep);
      doc.scrollTop = <span class="hljs-keyword">this</span>.scrollTop; doc.scrollLeft = <span class="hljs-keyword">this</span>.scrollLeft;
      doc.sel = <span class="hljs-keyword">this</span>.sel;
      doc.extend = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (copyHistory) {
        doc.history.undoDepth = <span class="hljs-keyword">this</span>.history.undoDepth;
        doc.setHistory(<span class="hljs-keyword">this</span>.getHistory());
      }
      <span class="hljs-keyword">return</span> doc;
    },

    linkedDoc: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">if</span> (!options) options = {};
      <span class="hljs-keyword">var</span> from = <span class="hljs-keyword">this</span>.first, to = <span class="hljs-keyword">this</span>.first + <span class="hljs-keyword">this</span>.size;
      <span class="hljs-keyword">if</span> (options.from != <span class="hljs-literal">null</span> &amp;&amp; options.from &gt; from) from = options.from;
      <span class="hljs-keyword">if</span> (options.to != <span class="hljs-literal">null</span> &amp;&amp; options.to &lt; to) to = options.to;
      <span class="hljs-keyword">var</span> copy = <span class="hljs-keyword">new</span> Doc(getLines(<span class="hljs-keyword">this</span>, from, to), options.mode || <span class="hljs-keyword">this</span>.modeOption, from, <span class="hljs-keyword">this</span>.lineSep);
      <span class="hljs-keyword">if</span> (options.sharedHist) copy.history = <span class="hljs-keyword">this</span>.history;
      (<span class="hljs-keyword">this</span>.linked || (<span class="hljs-keyword">this</span>.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: <span class="hljs-keyword">this</span>, isParent: <span class="hljs-literal">true</span>, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(<span class="hljs-keyword">this</span>));
      <span class="hljs-keyword">return</span> copy;
    },
    unlinkDoc: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">other</span>) </span>{
      <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> CodeMirror) other = other.doc;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.linked) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.linked.length; ++i) {
        <span class="hljs-keyword">var</span> link = <span class="hljs-keyword">this</span>.linked[i];
        <span class="hljs-keyword">if</span> (link.doc != other) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">this</span>.linked.splice(i, <span class="hljs-number">1</span>);
        other.unlinkDoc(<span class="hljs-keyword">this</span>);
        detachSharedMarkers(findSharedMarkers(<span class="hljs-keyword">this</span>));
        <span class="hljs-keyword">break</span>;
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the histories were shared, split them again</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (other.history == <span class="hljs-keyword">this</span>.history) {
        <span class="hljs-keyword">var</span> splitIds = [other.id];
        linkedDocs(other, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{splitIds.push(doc.id);}, <span class="hljs-literal">true</span>);
        other.history = <span class="hljs-keyword">new</span> History(<span class="hljs-literal">null</span>);
        other.history.done = copyHistoryArray(<span class="hljs-keyword">this</span>.history.done, splitIds);
        other.history.undone = copyHistoryArray(<span class="hljs-keyword">this</span>.history.undone, splitIds);
      }
    },
    iterLinkedDocs: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>) </span>{linkedDocs(<span class="hljs-keyword">this</span>, f);},

    getMode: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mode;},
    getEditor: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cm;},

    splitLines: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lineSep) <span class="hljs-keyword">return</span> str.split(<span class="hljs-keyword">this</span>.lineSep);
      <span class="hljs-keyword">return</span> splitLinesAuto(str);
    },
    lineSeparator: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lineSep || <span class="hljs-string">"\n"</span>; }
  });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Public alias.</p></div></div><div class="code"><div class="wrapper">  Doc.prototype.eachLine = Doc.prototype.iter;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set up methods on CodeMirror&#39;s prototype to redirect to the editor&#39;s document.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> dontDelegate = <span class="hljs-string">"iter insert remove copy getEditor constructor"</span>.split(<span class="hljs-string">" "</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> Doc.prototype) <span class="hljs-keyword">if</span> (Doc.prototype.hasOwnProperty(prop) &amp;&amp; indexOf(dontDelegate, prop) &lt; <span class="hljs-number">0</span>)
    CodeMirror.prototype[prop] = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">method</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> method.apply(<span class="hljs-keyword">this</span>.doc, <span class="hljs-built_in">arguments</span>);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call f for all linked documents.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">linkedDocs</span>(<span class="hljs-params">doc, f, sharedHistOnly</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">propagate</span>(<span class="hljs-params">doc, skip, sharedHist</span>) </span>{
      <span class="hljs-keyword">if</span> (doc.linked) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; doc.linked.length; ++i) {
        <span class="hljs-keyword">var</span> rel = doc.linked[i];
        <span class="hljs-keyword">if</span> (rel.doc == skip) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">var</span> shared = sharedHist &amp;&amp; rel.sharedHist;
        <span class="hljs-keyword">if</span> (sharedHistOnly &amp;&amp; !shared) <span class="hljs-keyword">continue</span>;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attach a document to an editor.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attachDoc</span>(<span class="hljs-params">cm, doc</span>) </span>{
    <span class="hljs-keyword">if</span> (doc.cm) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"This document is already in use."</span>);
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    <span class="hljs-keyword">if</span> (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>LINE UTILITIES</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the line object corresponding to the given line number.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLine</span>(<span class="hljs-params">doc, n</span>) </span>{
    n -= doc.first;
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span> || n &gt;= doc.size) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"There is no line "</span> + (n + doc.first) + <span class="hljs-string">" in the document."</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> chunk = doc; !chunk.lines;) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;; ++i) {
        <span class="hljs-keyword">var</span> child = chunk.children[i], sz = child.chunkSize();
        <span class="hljs-keyword">if</span> (n &lt; sz) { chunk = child; <span class="hljs-keyword">break</span>; }
        n -= sz;
      }
    }
    <span class="hljs-keyword">return</span> chunk.lines[n];
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the part of a document between two positions, as an array of
strings.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBetween</span>(<span class="hljs-params">doc, start, end</span>) </span>{
    <span class="hljs-keyword">var</span> out = [], n = start.line;
    doc.iter(start.line, end.line + <span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">var</span> text = line.text;
      <span class="hljs-keyword">if</span> (n == end.line) text = text.slice(<span class="hljs-number">0</span>, end.ch);
      <span class="hljs-keyword">if</span> (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    <span class="hljs-keyword">return</span> out;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the lines between from and to, as array of strings.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLines</span>(<span class="hljs-params">doc, from, to</span>) </span>{
    <span class="hljs-keyword">var</span> out = [];
    doc.iter(from, to, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{ out.push(line.text); });
    <span class="hljs-keyword">return</span> out;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update the height of a line, propagating the height change
upwards to parent nodes.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateLineHeight</span>(<span class="hljs-params">line, height</span>) </span>{
    <span class="hljs-keyword">var</span> diff = height - line.height;
    <span class="hljs-keyword">if</span> (diff) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = line; n; n = n.parent) n.height += diff;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a line object, find its line number by walking up through
its parent links.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineNo</span>(<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">if</span> (line.parent == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> cur = line.parent, no = indexOf(cur.lines, line);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;; ++i) {
        <span class="hljs-keyword">if</span> (chunk.children[i] == cur) <span class="hljs-keyword">break</span>;
        no += chunk.children[i].chunkSize();
      }
    }
    <span class="hljs-keyword">return</span> no + cur.first;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the line at the given vertical position, using the height
information in the document tree.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineAtHeight</span>(<span class="hljs-params">chunk, h</span>) </span>{
    <span class="hljs-keyword">var</span> n = chunk.first;
    outer: <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; chunk.children.length; ++i) {
        <span class="hljs-keyword">var</span> child = chunk.children[i], ch = child.height;
        <span class="hljs-keyword">if</span> (h &lt; ch) { chunk = child; <span class="hljs-keyword">continue</span> outer; }
        h -= ch;
        n += child.chunkSize();
      }
      <span class="hljs-keyword">return</span> n;
    } <span class="hljs-keyword">while</span> (!chunk.lines);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; chunk.lines.length; ++i) {
      <span class="hljs-keyword">var</span> line = chunk.lines[i], lh = line.height;
      <span class="hljs-keyword">if</span> (h &lt; lh) <span class="hljs-keyword">break</span>;
      h -= lh;
    }
    <span class="hljs-keyword">return</span> n + i;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the height above the given line.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heightAtLine</span>(<span class="hljs-params">lineObj</span>) </span>{
    lineObj = visualLine(lineObj);

    <span class="hljs-keyword">var</span> h = <span class="hljs-number">0</span>, chunk = lineObj.parent;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; chunk.lines.length; ++i) {
      <span class="hljs-keyword">var</span> line = chunk.lines[i];
      <span class="hljs-keyword">if</span> (line == lineObj) <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">else</span> h += line.height;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p = chunk.parent; p; chunk = p, p = chunk.parent) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; p.children.length; ++i) {
        <span class="hljs-keyword">var</span> cur = p.children[i];
        <span class="hljs-keyword">if</span> (cur == chunk) <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">else</span> h += cur.height;
      }
    }
    <span class="hljs-keyword">return</span> h;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the bidi ordering for the given line (and cache it). Returns
false for lines that are fully left-to-right, and an array of
BidiSpan objects otherwise.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOrder</span>(<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">var</span> order = line.order;
    <span class="hljs-keyword">if</span> (order == <span class="hljs-literal">null</span>) order = line.order = bidiOrdering(line.text);
    <span class="hljs-keyword">return</span> order;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>HISTORY</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">History</span>(<span class="hljs-params">startGen</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Arrays of change events and selections. Doing something adds an
event to done and clears undo. Undoing moves events from done
to undone, redoing moves them in the other direction.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.done = []; <span class="hljs-keyword">this</span>.undone = [];
    <span class="hljs-keyword">this</span>.undoDepth = <span class="hljs-literal">Infinity</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to track when changes can be merged into a single undo
event</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.lastModTime = <span class="hljs-keyword">this</span>.lastSelTime = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.lastOp = <span class="hljs-keyword">this</span>.lastSelOp = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.lastOrigin = <span class="hljs-keyword">this</span>.lastSelOrigin = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used by the isClean() method</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.generation = <span class="hljs-keyword">this</span>.maxGeneration = startGen || <span class="hljs-number">1</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a history change event from an updateDoc-style change
object.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">historyChangeFromChange</span>(<span class="hljs-params">doc, change</span>) </span>{
    <span class="hljs-keyword">var</span> histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + <span class="hljs-number">1</span>);
    linkedDocs(doc, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{attachLocalSpans(doc, histChange, change.from.line, change.to.line + <span class="hljs-number">1</span>);}, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">return</span> histChange;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pop all selection events off the end of a history array. Stop at
a change event.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearSelectionEvents</span>(<span class="hljs-params">array</span>) </span>{
    <span class="hljs-keyword">while</span> (array.length) {
      <span class="hljs-keyword">var</span> last = lst(array);
      <span class="hljs-keyword">if</span> (last.ranges) array.pop();
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the top change event in the history. Pop off selection
events that are in the way.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastChangeEvent</span>(<span class="hljs-params">hist, force</span>) </span>{
    <span class="hljs-keyword">if</span> (force) {
      clearSelectionEvents(hist.done);
      <span class="hljs-keyword">return</span> lst(hist.done);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hist.done.length &amp;&amp; !lst(hist.done).ranges) {
      <span class="hljs-keyword">return</span> lst(hist.done);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hist.done.length &gt; <span class="hljs-number">1</span> &amp;&amp; !hist.done[hist.done.length - <span class="hljs-number">2</span>].ranges) {
      hist.done.pop();
      <span class="hljs-keyword">return</span> lst(hist.done);
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Register a change in the history. Merges changes that are within
a single operation, ore are close together with an origin that
allows merging (starting with &quot;+&quot;) into a single event.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addChangeToHistory</span>(<span class="hljs-params">doc, change, selAfter, opId</span>) </span>{
    <span class="hljs-keyword">var</span> hist = doc.history;
    hist.undone.length = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> time = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>, cur;

    <span class="hljs-keyword">if</span> ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin &amp;&amp; change.origin &amp;&amp;
         ((change.origin.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">"+"</span> &amp;&amp; doc.cm &amp;&amp; hist.lastModTime &gt; time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">"*"</span>)) &amp;&amp;
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Merge this change into the last event</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> last = lst(cur.changes);
      <span class="hljs-keyword">if</span> (cmp(change.from, change.to) == <span class="hljs-number">0</span> &amp;&amp; cmp(change.from, last.to) == <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Optimized case for simple insertion -- don&#39;t want to add
new changesets for every character typed</p></div></div><div class="code"><div class="wrapper">        last.to = changeEnd(change);
      } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add new sub-event</p></div></div><div class="code"><div class="wrapper">        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Can not be merged, start a new event.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> before = lst(hist.done);
      <span class="hljs-keyword">if</span> (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      <span class="hljs-keyword">while</span> (hist.done.length &gt; hist.undoDepth) {
        hist.done.shift();
        <span class="hljs-keyword">if</span> (!hist.done[<span class="hljs-number">0</span>].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    <span class="hljs-keyword">if</span> (!last) signal(doc, <span class="hljs-string">"historyAdded"</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionEventCanBeMerged</span>(<span class="hljs-params">doc, origin, prev, sel</span>) </span>{
    <span class="hljs-keyword">var</span> ch = origin.charAt(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> ch == <span class="hljs-string">"*"</span> ||
      ch == <span class="hljs-string">"+"</span> &amp;&amp;
      prev.ranges.length == sel.ranges.length &amp;&amp;
      prev.somethingSelected() == sel.somethingSelected() &amp;&amp;
      <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - doc.history.lastSelTime &lt;= (doc.cm ? doc.cm.options.historyEventDelay : <span class="hljs-number">500</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Called whenever the selection changes, sets the new selection as
the pending selection in the history, and pushes the old pending
selection into the &#39;done&#39; array when it was significantly
different (in number of selected ranges, emptiness, or time).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSelectionToHistory</span>(<span class="hljs-params">doc, sel, opId, options</span>) </span>{
    <span class="hljs-keyword">var</span> hist = doc.history, origin = options &amp;&amp; options.origin;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A new event is started when the previous origin does not match
the current, or the origins don&#39;t allow matching. Origins
starting with * are always merged, those starting with + are
merged when similar and close together in time.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (opId == hist.lastSelOp ||
        (origin &amp;&amp; hist.lastSelOrigin == origin &amp;&amp;
         (hist.lastModTime == hist.lastSelTime &amp;&amp; hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - <span class="hljs-number">1</span>] = sel;
    <span class="hljs-keyword">else</span>
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    <span class="hljs-keyword">if</span> (options &amp;&amp; options.clearRedo !== <span class="hljs-literal">false</span>)
      clearSelectionEvents(hist.undone);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushSelectionToHistory</span>(<span class="hljs-params">sel, dest</span>) </span>{
    <span class="hljs-keyword">var</span> top = lst(dest);
    <span class="hljs-keyword">if</span> (!(top &amp;&amp; top.ranges &amp;&amp; top.equals(sel)))
      dest.push(sel);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used to store marked span information in the history.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attachLocalSpans</span>(<span class="hljs-params">doc, change, from, to</span>) </span>{
    <span class="hljs-keyword">var</span> existing = change[<span class="hljs-string">"spans_"</span> + doc.id], n = <span class="hljs-number">0</span>;
    doc.iter(<span class="hljs-built_in">Math</span>.max(doc.first, from), <span class="hljs-built_in">Math</span>.min(doc.first + doc.size, to), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
      <span class="hljs-keyword">if</span> (line.markedSpans)
        (existing || (existing = change[<span class="hljs-string">"spans_"</span> + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When un/re-doing restores text containing marked spans, those
that have been explicitly cleared should not be restored.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeClearedSpans</span>(<span class="hljs-params">spans</span>) </span>{
    <span class="hljs-keyword">if</span> (!spans) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, out; i &lt; spans.length; ++i) {
      <span class="hljs-keyword">if</span> (spans[i].marker.explicitlyCleared) { <span class="hljs-keyword">if</span> (!out) out = spans.slice(<span class="hljs-number">0</span>, i); }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (out) out.push(spans[i]);
    }
    <span class="hljs-keyword">return</span> !out ? spans : out.length ? out : <span class="hljs-literal">null</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Retrieve and filter the old marked spans stored in a change event.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOldSpans</span>(<span class="hljs-params">doc, change</span>) </span>{
    <span class="hljs-keyword">var</span> found = change[<span class="hljs-string">"spans_"</span> + doc.id];
    <span class="hljs-keyword">if</span> (!found) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, nw = []; i &lt; change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    <span class="hljs-keyword">return</span> nw;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Used both to provide a JSON-safe object in .getHistory, and, when
detaching a document, to split the history in two</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyHistoryArray</span>(<span class="hljs-params">events, newGroup, instantiateSel</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, copy = []; i &lt; events.length; ++i) {
      <span class="hljs-keyword">var</span> event = events[i];
      <span class="hljs-keyword">if</span> (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">var</span> changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; changes.length; ++j) {
        <span class="hljs-keyword">var</span> change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        <span class="hljs-keyword">if</span> (newGroup) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> change) <span class="hljs-keyword">if</span> (m = prop.match(<span class="hljs-regexp">/^spans_(\d+)$/</span>)) {
          <span class="hljs-keyword">if</span> (indexOf(newGroup, <span class="hljs-built_in">Number</span>(m[<span class="hljs-number">1</span>])) &gt; -<span class="hljs-number">1</span>) {
            lst(newChanges)[prop] = change[prop];
            <span class="hljs-keyword">delete</span> change[prop];
          }
        }
      }
    }
    <span class="hljs-keyword">return</span> copy;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Rebasing/resetting history to deal with externally-sourced changes</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rebaseHistSelSingle</span>(<span class="hljs-params">pos, from, to, diff</span>) </span>{
    <span class="hljs-keyword">if</span> (to &lt; pos.line) {
      pos.line += diff;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (from &lt; pos.line) {
      pos.line = from;
      pos.ch = <span class="hljs-number">0</span>;
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Tries to rebase an array of history events given a change in the
document. If the change touches the same lines as the event, the
event, and everything &#39;behind&#39; it, is discarded. If the change is
before the event, the event&#39;s positions are updated. Uses a
copy-on-write scheme for the positions, to avoid having to
reallocate them all on every rebase, but also avoid problems with
shared position objects being unsafely updated.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rebaseHistArray</span>(<span class="hljs-params">array, from, to, diff</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.length; ++i) {
      <span class="hljs-keyword">var</span> sub = array[i], ok = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (sub.ranges) {
        <span class="hljs-keyword">if</span> (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = <span class="hljs-literal">true</span>; }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; sub.changes.length; ++j) {
        <span class="hljs-keyword">var</span> cur = sub.changes[j];
        <span class="hljs-keyword">if</span> (to &lt; cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (from &lt;= cur.to.line) {
          ok = <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">if</span> (!ok) {
        array.splice(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>);
        i = <span class="hljs-number">0</span>;
      }
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rebaseHist</span>(<span class="hljs-params">hist, change</span>) </span>{
    <span class="hljs-keyword">var</span> from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - <span class="hljs-number">1</span>;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>EVENT UTILITIES</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Due to the fact that we still support jurassic IE versions, some
compatibility wrappers are needed.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> e_preventDefault = CodeMirror.e_preventDefault = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">if</span> (e.preventDefault) e.preventDefault();
    <span class="hljs-keyword">else</span> e.returnValue = <span class="hljs-literal">false</span>;
  };
  <span class="hljs-keyword">var</span> e_stopPropagation = CodeMirror.e_stopPropagation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">if</span> (e.stopPropagation) e.stopPropagation();
    <span class="hljs-keyword">else</span> e.cancelBubble = <span class="hljs-literal">true</span>;
  };
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e_defaultPrevented</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">return</span> e.defaultPrevented != <span class="hljs-literal">null</span> ? e.defaultPrevented : e.returnValue == <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">var</span> e_stop = CodeMirror.e_stop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{e_preventDefault(e); e_stopPropagation(e);};

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e_target</span>(<span class="hljs-params">e</span>) </span>{<span class="hljs-keyword">return</span> e.target || e.srcElement;}
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e_button</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">var</span> b = e.which;
    <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (e.button &amp; <span class="hljs-number">1</span>) b = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.button &amp; <span class="hljs-number">2</span>) b = <span class="hljs-number">3</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.button &amp; <span class="hljs-number">4</span>) b = <span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">if</span> (mac &amp;&amp; e.ctrlKey &amp;&amp; b == <span class="hljs-number">1</span>) b = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">return</span> b;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>EVENT HANDLING</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Lightweight event framework. on/off also work on DOM nodes,
registering native DOM handlers.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> on = CodeMirror.on = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">emitter, type, f</span>) </span>{
    <span class="hljs-keyword">if</span> (emitter.addEventListener)
      emitter.addEventListener(type, f, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (emitter.attachEvent)
      emitter.attachEvent(<span class="hljs-string">"on"</span> + type, f);
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> map = emitter._handlers || (emitter._handlers = {});
      <span class="hljs-keyword">var</span> arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  <span class="hljs-keyword">var</span> noHandlers = []
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHandlers</span>(<span class="hljs-params">emitter, type, copy</span>) </span>{
    <span class="hljs-keyword">var</span> arr = emitter._handlers &amp;&amp; emitter._handlers[type]
    <span class="hljs-keyword">if</span> (copy) <span class="hljs-keyword">return</span> arr &amp;&amp; arr.length &gt; <span class="hljs-number">0</span> ? arr.slice() : noHandlers
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> arr || noHandlers
  }

  <span class="hljs-keyword">var</span> off = CodeMirror.off = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">emitter, type, f</span>) </span>{
    <span class="hljs-keyword">if</span> (emitter.removeEventListener)
      emitter.removeEventListener(type, f, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (emitter.detachEvent)
      emitter.detachEvent(<span class="hljs-string">"on"</span> + type, f);
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> handlers = getHandlers(emitter, type, <span class="hljs-literal">false</span>)
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; handlers.length; ++i)
        <span class="hljs-keyword">if</span> (handlers[i] == f) { handlers.splice(i, <span class="hljs-number">1</span>); <span class="hljs-keyword">break</span>; }
    }
  };

  <span class="hljs-keyword">var</span> signal = CodeMirror.signal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">emitter, type <span class="hljs-comment">/*, values...*/</span></span>) </span>{
    <span class="hljs-keyword">var</span> handlers = getHandlers(emitter, type, <span class="hljs-literal">true</span>)
    <span class="hljs-keyword">if</span> (!handlers.length) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; handlers.length; ++i) handlers[i].apply(<span class="hljs-literal">null</span>, args);
  };

  <span class="hljs-keyword">var</span> orphanDelayedCallbacks = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Often, we want to signal events at a point where we are in the
middle of some work, but don&#39;t want the handler to start calling
other methods on the editor, which might be in an inconsistent
state or simply not expect any other events to happen.
signalLater looks whether there are any handlers, and schedules
them to be executed when the last operation ends, or, if no
operation is active, when a timeout fires.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">signalLater</span>(<span class="hljs-params">emitter, type <span class="hljs-comment">/*, values...*/</span></span>) </span>{
    <span class="hljs-keyword">var</span> arr = getHandlers(emitter, type, <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">if</span> (!arr.length) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>), list;
    <span class="hljs-keyword">if</span> (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } <span class="hljs-keyword">else</span> {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, <span class="hljs-number">0</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bnd</span>(<span class="hljs-params">f</span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{f.apply(<span class="hljs-literal">null</span>, args);};};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; ++i)
      list.push(bnd(arr[i]));
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fireOrphanDelayed</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; delayed.length; ++i) delayed[i]();
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The DOM events that CodeMirror handles can be overridden by
registering a (non-DOM) handler on the editor for the event name,
and preventDefault-ing the event in that handler.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">signalDOMEvent</span>(<span class="hljs-params">cm, e, override</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> e == <span class="hljs-string">"string"</span>)
      e = {type: e, preventDefault: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>.defaultPrevented = <span class="hljs-literal">true</span>; }};
    signal(cm, override || e.type, cm, e);
    <span class="hljs-keyword">return</span> e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">signalCursorActivity</span>(<span class="hljs-params">cm</span>) </span>{
    <span class="hljs-keyword">var</span> arr = cm._handlers &amp;&amp; cm._handlers.cursorActivity;
    <span class="hljs-keyword">if</span> (!arr) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; ++i) <span class="hljs-keyword">if</span> (indexOf(set, arr[i]) == -<span class="hljs-number">1</span>)
      set.push(arr[i]);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasHandler</span>(<span class="hljs-params">emitter, type</span>) </span>{
    <span class="hljs-keyword">return</span> getHandlers(emitter, type).length &gt; <span class="hljs-number">0</span>
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add on and off methods to a constructor&#39;s prototype, to make
registering events on such objects more convenient.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventMixin</span>(<span class="hljs-params">ctor</span>) </span>{
    ctor.prototype.on = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, f</span>) </span>{on(<span class="hljs-keyword">this</span>, type, f);};
    ctor.prototype.off = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, f</span>) </span>{off(<span class="hljs-keyword">this</span>, type, f);};
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>MISC UTILITIES</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Number of pixels added to scroller and sizer to hide scrollbar</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> scrollerGap = <span class="hljs-number">30</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returned or thrown by various protocols to signal &#39;I&#39;m not
handling this&#39;.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> Pass = CodeMirror.Pass = {toString: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> <span class="hljs-string">"CodeMirror.Pass"</span>;}};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reused option objects for setSelection &amp; friends</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> sel_dontScroll = {scroll: <span class="hljs-literal">false</span>}, sel_mouse = {origin: <span class="hljs-string">"*mouse"</span>}, sel_move = {origin: <span class="hljs-string">"+move"</span>};

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Delayed</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">this</span>.id = <span class="hljs-literal">null</span>;}
  Delayed.prototype.set = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ms, f</span>) </span>{
    clearTimeout(<span class="hljs-keyword">this</span>.id);
    <span class="hljs-keyword">this</span>.id = setTimeout(f, ms);
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Counts the column offset in a string, taking tabs into account.
Used mostly to find indentation.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> countColumn = CodeMirror.countColumn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">string, end, tabSize, startIndex, startValue</span>) </span>{
    <span class="hljs-keyword">if</span> (end == <span class="hljs-literal">null</span>) {
      end = string.search(<span class="hljs-regexp">/[^\s\u00a0]/</span>);
      <span class="hljs-keyword">if</span> (end == -<span class="hljs-number">1</span>) end = string.length;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = startIndex || <span class="hljs-number">0</span>, n = startValue || <span class="hljs-number">0</span>;;) {
      <span class="hljs-keyword">var</span> nextTab = string.indexOf(<span class="hljs-string">"\t"</span>, i);
      <span class="hljs-keyword">if</span> (nextTab &lt; <span class="hljs-number">0</span> || nextTab &gt;= end)
        <span class="hljs-keyword">return</span> n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + <span class="hljs-number">1</span>;
    }
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The inverse of countColumn -- find the offset that corresponds to
a particular column.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> findColumn = CodeMirror.findColumn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">string, goal, tabSize</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> pos = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;;) {
      <span class="hljs-keyword">var</span> nextTab = string.indexOf(<span class="hljs-string">"\t"</span>, pos);
      <span class="hljs-keyword">if</span> (nextTab == -<span class="hljs-number">1</span>) nextTab = string.length;
      <span class="hljs-keyword">var</span> skipped = nextTab - pos;
      <span class="hljs-keyword">if</span> (nextTab == string.length || col + skipped &gt;= goal)
        <span class="hljs-keyword">return</span> pos + <span class="hljs-built_in">Math</span>.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">if</span> (col &gt;= goal) <span class="hljs-keyword">return</span> pos;
    }
  }

  <span class="hljs-keyword">var</span> spaceStrs = [<span class="hljs-string">""</span>];
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spaceStr</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">while</span> (spaceStrs.length &lt;= n)
      spaceStrs.push(lst(spaceStrs) + <span class="hljs-string">" "</span>);
    <span class="hljs-keyword">return</span> spaceStrs[n];
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lst</span>(<span class="hljs-params">arr</span>) </span>{ <span class="hljs-keyword">return</span> arr[arr.length-<span class="hljs-number">1</span>]; }

  <span class="hljs-keyword">var</span> selectInput = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{ node.select(); };
  <span class="hljs-keyword">if</span> (ios) <span class="hljs-comment">// Mobile Safari apparently has a bug where select() is broken.</span>
    selectInput = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{ node.selectionStart = <span class="hljs-number">0</span>; node.selectionEnd = node.value.length; };
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ie) <span class="hljs-comment">// Suppress mysterious IE10 errors</span>
    selectInput = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{ <span class="hljs-keyword">try</span> { node.select(); } <span class="hljs-keyword">catch</span>(_e) {} };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexOf</span>(<span class="hljs-params">array, elt</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.length; ++i)
      <span class="hljs-keyword">if</span> (array[i] == elt) <span class="hljs-keyword">return</span> i;
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">array, f</span>) </span>{
    <span class="hljs-keyword">var</span> out = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) out[i] = f(array[i], i);
    <span class="hljs-keyword">return</span> out;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nothing</span>(<span class="hljs-params"></span>) </span>{}

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObj</span>(<span class="hljs-params">base, props</span>) </span>{
    <span class="hljs-keyword">var</span> inst;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.create) {
      inst = <span class="hljs-built_in">Object</span>.create(base);
    } <span class="hljs-keyword">else</span> {
      nothing.prototype = base;
      inst = <span class="hljs-keyword">new</span> nothing();
    }
    <span class="hljs-keyword">if</span> (props) copyObj(props, inst);
    <span class="hljs-keyword">return</span> inst;
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyObj</span>(<span class="hljs-params">obj, target, overwrite</span>) </span>{
    <span class="hljs-keyword">if</span> (!target) target = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> obj)
      <span class="hljs-keyword">if</span> (obj.hasOwnProperty(prop) &amp;&amp; (overwrite !== <span class="hljs-literal">false</span> || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    <span class="hljs-keyword">return</span> target;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">f</span>) </span>{
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> f.apply(<span class="hljs-literal">null</span>, args);};
  }

  <span class="hljs-keyword">var</span> nonASCIISingleCaseWordChar = <span class="hljs-regexp">/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/</span>;
  <span class="hljs-keyword">var</span> isWordCharBasic = CodeMirror.isWordChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ch</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-regexp">/\w/</span>.test(ch) || ch &gt; <span class="hljs-string">"\x80"</span> &amp;&amp;
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWordChar</span>(<span class="hljs-params">ch, helper</span>) </span>{
    <span class="hljs-keyword">if</span> (!helper) <span class="hljs-keyword">return</span> isWordCharBasic(ch);
    <span class="hljs-keyword">if</span> (helper.source.indexOf(<span class="hljs-string">"\\w"</span>) &gt; -<span class="hljs-number">1</span> &amp;&amp; isWordCharBasic(ch)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> helper.test(ch);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmpty</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> obj) <span class="hljs-keyword">if</span> (obj.hasOwnProperty(n) &amp;&amp; obj[n]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extending unicode characters. A series of a non-extending char +
any number of extending chars is treated as a single unit as far
as editing and measuring is concerned. This is not fully correct,
since some scripts/fonts/browsers also treat other configurations
of code points as a group.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> extendingChars = <span class="hljs-regexp">/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isExtendingChar</span>(<span class="hljs-params">ch</span>) </span>{ <span class="hljs-keyword">return</span> ch.charCodeAt(<span class="hljs-number">0</span>) &gt;= <span class="hljs-number">768</span> &amp;&amp; extendingChars.test(ch); }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DOM UTILITIES</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elt</span>(<span class="hljs-params">tag, content, className, style</span>) </span>{
    <span class="hljs-keyword">var</span> e = <span class="hljs-built_in">document</span>.createElement(tag);
    <span class="hljs-keyword">if</span> (className) e.className = className;
    <span class="hljs-keyword">if</span> (style) e.style.cssText = style;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> content == <span class="hljs-string">"string"</span>) e.appendChild(<span class="hljs-built_in">document</span>.createTextNode(content));
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (content) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; content.length; ++i) e.appendChild(content[i]);
    <span class="hljs-keyword">return</span> e;
  }

  <span class="hljs-keyword">var</span> range;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.createRange) range = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, start, end, endNode</span>) </span>{
    <span class="hljs-keyword">var</span> r = <span class="hljs-built_in">document</span>.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    <span class="hljs-keyword">return</span> r;
  };
  <span class="hljs-keyword">else</span> range = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, start, end</span>) </span>{
    <span class="hljs-keyword">var</span> r = <span class="hljs-built_in">document</span>.body.createTextRange();
    <span class="hljs-keyword">try</span> { r.moveToElementText(node.parentNode); }
    <span class="hljs-keyword">catch</span>(e) { <span class="hljs-keyword">return</span> r; }
    r.collapse(<span class="hljs-literal">true</span>);
    r.moveEnd(<span class="hljs-string">"character"</span>, end);
    r.moveStart(<span class="hljs-string">"character"</span>, start);
    <span class="hljs-keyword">return</span> r;
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeChildren</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> count = e.childNodes.length; count &gt; <span class="hljs-number">0</span>; --count)
      e.removeChild(e.firstChild);
    <span class="hljs-keyword">return</span> e;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeChildrenAndAdd</span>(<span class="hljs-params">parent, e</span>) </span>{
    <span class="hljs-keyword">return</span> removeChildren(parent).appendChild(e);
  }

  <span class="hljs-keyword">var</span> contains = CodeMirror.contains = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">parent, child</span>) </span>{
    <span class="hljs-keyword">if</span> (child.nodeType == <span class="hljs-number">3</span>) <span class="hljs-comment">// Android browser always returns false when child is a textnode</span>
      child = child.parentNode;
    <span class="hljs-keyword">if</span> (parent.contains)
      <span class="hljs-keyword">return</span> parent.contains(child);
    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">if</span> (child.nodeType == <span class="hljs-number">11</span>) child = child.host;
      <span class="hljs-keyword">if</span> (child == parent) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">while</span> (child = child.parentNode);
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activeElt</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> activeElement = <span class="hljs-built_in">document</span>.activeElement;
    <span class="hljs-keyword">while</span> (activeElement &amp;&amp; activeElement.root &amp;&amp; activeElement.root.activeElement)
      activeElement = activeElement.root.activeElement;
    <span class="hljs-keyword">return</span> activeElement;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Older versions of IE throws unspecified error when touching
document.activeElement in some cases (during loading, in iframe)</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">11</span>) activeElt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">try</span> { <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.activeElement; }
    <span class="hljs-keyword">catch</span>(e) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.body; }
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">classTest</span>(<span class="hljs-params">cls</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"(^|\\s)"</span> + cls + <span class="hljs-string">"(?:$|\\s)\\s*"</span>); }
  <span class="hljs-keyword">var</span> rmClass = CodeMirror.rmClass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, cls</span>) </span>{
    <span class="hljs-keyword">var</span> current = node.className;
    <span class="hljs-keyword">var</span> match = classTest(cls).exec(current);
    <span class="hljs-keyword">if</span> (match) {
      <span class="hljs-keyword">var</span> after = current.slice(match.index + match[<span class="hljs-number">0</span>].length);
      node.className = current.slice(<span class="hljs-number">0</span>, match.index) + (after ? match[<span class="hljs-number">1</span>] + after : <span class="hljs-string">""</span>);
    }
  };
  <span class="hljs-keyword">var</span> addClass = CodeMirror.addClass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, cls</span>) </span>{
    <span class="hljs-keyword">var</span> current = node.className;
    <span class="hljs-keyword">if</span> (!classTest(cls).test(current)) node.className += (current ? <span class="hljs-string">" "</span> : <span class="hljs-string">""</span>) + cls;
  };
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">joinClasses</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">as</span> = a.split(<span class="hljs-string">" "</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">as</span>.length; i++)
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">as</span>[i] &amp;&amp; !classTest(<span class="hljs-keyword">as</span>[i]).test(b)) b += <span class="hljs-string">" "</span> + <span class="hljs-keyword">as</span>[i];
    <span class="hljs-keyword">return</span> b;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>WINDOW-WIDE EVENTS</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>These must be handled carefully, because naively registering a
handler for each editor will cause the editors to never be
garbage collected.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachCodeMirror</span>(<span class="hljs-params">f</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">document</span>.body.getElementsByClassName) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> byClass = <span class="hljs-built_in">document</span>.body.getElementsByClassName(<span class="hljs-string">"CodeMirror"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; byClass.length; i++) {
      <span class="hljs-keyword">var</span> cm = byClass[i].CodeMirror;
      <span class="hljs-keyword">if</span> (cm) f(cm);
    }
  }

  <span class="hljs-keyword">var</span> globalsRegistered = <span class="hljs-literal">false</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureGlobalHandlers</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (globalsRegistered) <span class="hljs-keyword">return</span>;
    registerGlobalHandlers();
    globalsRegistered = <span class="hljs-literal">true</span>;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerGlobalHandlers</span>(<span class="hljs-params"></span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When the window resizes, we need to refresh active editors.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> resizeTimer;
    on(<span class="hljs-built_in">window</span>, <span class="hljs-string">"resize"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (resizeTimer == <span class="hljs-literal">null</span>) resizeTimer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        resizeTimer = <span class="hljs-literal">null</span>;
        forEachCodeMirror(onResize);
      }, <span class="hljs-number">100</span>);
    });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When the window loses focus, we want to show the editor as blurred</p></div></div><div class="code"><div class="wrapper">    on(<span class="hljs-built_in">window</span>, <span class="hljs-string">"blur"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      forEachCodeMirror(onBlur);
    });
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>FEATURE DETECTION</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Detect drag-and-drop</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> dragAndDrop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>There is <em>some</em> kind of drag-and-drop support in IE6-8, but I
couldn&#39;t get it to work yet.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (ie &amp;&amp; ie_version &lt; <span class="hljs-number">9</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> div = elt(<span class="hljs-string">'div'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-string">"draggable"</span> <span class="hljs-keyword">in</span> div || <span class="hljs-string">"dragDrop"</span> <span class="hljs-keyword">in</span> div;
  }();

  <span class="hljs-keyword">var</span> zwspSupported;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zeroWidthElement</span>(<span class="hljs-params">measure</span>) </span>{
    <span class="hljs-keyword">if</span> (zwspSupported == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> test = elt(<span class="hljs-string">"span"</span>, <span class="hljs-string">"\u200b"</span>);
      removeChildrenAndAdd(measure, elt(<span class="hljs-string">"span"</span>, [test, <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">"x"</span>)]));
      <span class="hljs-keyword">if</span> (measure.firstChild.offsetHeight != <span class="hljs-number">0</span>)
        zwspSupported = test.offsetWidth &lt;= <span class="hljs-number">1</span> &amp;&amp; test.offsetHeight &gt; <span class="hljs-number">2</span> &amp;&amp; !(ie &amp;&amp; ie_version &lt; <span class="hljs-number">8</span>);
    }
    <span class="hljs-keyword">var</span> node = zwspSupported ? elt(<span class="hljs-string">"span"</span>, <span class="hljs-string">"\u200b"</span>) :
      elt(<span class="hljs-string">"span"</span>, <span class="hljs-string">"\u00a0"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"display: inline-block; width: 1px; margin-right: -1px"</span>);
    node.setAttribute(<span class="hljs-string">"cm-text"</span>, <span class="hljs-string">""</span>);
    <span class="hljs-keyword">return</span> node;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Feature-detect IE&#39;s crummy client rect reporting for bidi text</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> badBidiRects;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasBadBidiRects</span>(<span class="hljs-params">measure</span>) </span>{
    <span class="hljs-keyword">if</span> (badBidiRects != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> badBidiRects;
    <span class="hljs-keyword">var</span> txt = removeChildrenAndAdd(measure, <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">"A\u062eA"</span>));
    <span class="hljs-keyword">var</span> r0 = range(txt, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>).getBoundingClientRect();
    <span class="hljs-keyword">if</span> (!r0 || r0.left == r0.right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Safari returns null in some cases (#2780)</span>
    <span class="hljs-keyword">var</span> r1 = range(txt, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>).getBoundingClientRect();
    <span class="hljs-keyword">return</span> badBidiRects = (r1.right - r0.right &lt; <span class="hljs-number">3</span>);
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>See if &quot;&quot;.split is the broken IE version, if so, provide an
alternative way to split lines.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> splitLinesAuto = CodeMirror.splitLines = <span class="hljs-string">"\n\nb"</span>.split(<span class="hljs-regexp">/\n/</span>).length != <span class="hljs-number">3</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">string</span>) </span>{
    <span class="hljs-keyword">var</span> pos = <span class="hljs-number">0</span>, result = [], l = string.length;
    <span class="hljs-keyword">while</span> (pos &lt;= l) {
      <span class="hljs-keyword">var</span> nl = string.indexOf(<span class="hljs-string">"\n"</span>, pos);
      <span class="hljs-keyword">if</span> (nl == -<span class="hljs-number">1</span>) nl = string.length;
      <span class="hljs-keyword">var</span> line = string.slice(pos, string.charAt(nl - <span class="hljs-number">1</span>) == <span class="hljs-string">"\r"</span> ? nl - <span class="hljs-number">1</span> : nl);
      <span class="hljs-keyword">var</span> rt = line.indexOf(<span class="hljs-string">"\r"</span>);
      <span class="hljs-keyword">if</span> (rt != -<span class="hljs-number">1</span>) {
        result.push(line.slice(<span class="hljs-number">0</span>, rt));
        pos += rt + <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        result.push(line);
        pos = nl + <span class="hljs-number">1</span>;
      }
    }
    <span class="hljs-keyword">return</span> result;
  } : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">string</span>)</span>{<span class="hljs-keyword">return</span> string.split(<span class="hljs-regexp">/\r\n?|\n/</span>);};

  <span class="hljs-keyword">var</span> hasSelection = <span class="hljs-built_in">window</span>.getSelection ? <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">te</span>) </span>{
    <span class="hljs-keyword">try</span> { <span class="hljs-keyword">return</span> te.selectionStart != te.selectionEnd; }
    <span class="hljs-keyword">catch</span>(e) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
  } : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">te</span>) </span>{
    <span class="hljs-keyword">try</span> {<span class="hljs-keyword">var</span> range = te.ownerDocument.selection.createRange();}
    <span class="hljs-keyword">catch</span>(e) {}
    <span class="hljs-keyword">if</span> (!range || range.parentElement() != te) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> range.compareEndPoints(<span class="hljs-string">"StartToEnd"</span>, range) != <span class="hljs-number">0</span>;
  };

  <span class="hljs-keyword">var</span> hasCopyEvent = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> e = elt(<span class="hljs-string">"div"</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"oncopy"</span> <span class="hljs-keyword">in</span> e) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    e.setAttribute(<span class="hljs-string">"oncopy"</span>, <span class="hljs-string">"return;"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> e.oncopy == <span class="hljs-string">"function"</span>;
  })();

  <span class="hljs-keyword">var</span> badZoomedRects = <span class="hljs-literal">null</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasBadZoomedRects</span>(<span class="hljs-params">measure</span>) </span>{
    <span class="hljs-keyword">if</span> (badZoomedRects != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> badZoomedRects;
    <span class="hljs-keyword">var</span> node = removeChildrenAndAdd(measure, elt(<span class="hljs-string">"span"</span>, <span class="hljs-string">"x"</span>));
    <span class="hljs-keyword">var</span> normal = node.getBoundingClientRect();
    <span class="hljs-keyword">var</span> fromRange = range(node, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>).getBoundingClientRect();
    <span class="hljs-keyword">return</span> badZoomedRects = <span class="hljs-built_in">Math</span>.abs(normal.left - fromRange.left) &gt; <span class="hljs-number">1</span>;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>KEY NAMES</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> keyNames = CodeMirror.keyNames = {
    <span class="hljs-number">3</span>: <span class="hljs-string">"Enter"</span>, <span class="hljs-number">8</span>: <span class="hljs-string">"Backspace"</span>, <span class="hljs-number">9</span>: <span class="hljs-string">"Tab"</span>, <span class="hljs-number">13</span>: <span class="hljs-string">"Enter"</span>, <span class="hljs-number">16</span>: <span class="hljs-string">"Shift"</span>, <span class="hljs-number">17</span>: <span class="hljs-string">"Ctrl"</span>, <span class="hljs-number">18</span>: <span class="hljs-string">"Alt"</span>,
    <span class="hljs-number">19</span>: <span class="hljs-string">"Pause"</span>, <span class="hljs-number">20</span>: <span class="hljs-string">"CapsLock"</span>, <span class="hljs-number">27</span>: <span class="hljs-string">"Esc"</span>, <span class="hljs-number">32</span>: <span class="hljs-string">"Space"</span>, <span class="hljs-number">33</span>: <span class="hljs-string">"PageUp"</span>, <span class="hljs-number">34</span>: <span class="hljs-string">"PageDown"</span>, <span class="hljs-number">35</span>: <span class="hljs-string">"End"</span>,
    <span class="hljs-number">36</span>: <span class="hljs-string">"Home"</span>, <span class="hljs-number">37</span>: <span class="hljs-string">"Left"</span>, <span class="hljs-number">38</span>: <span class="hljs-string">"Up"</span>, <span class="hljs-number">39</span>: <span class="hljs-string">"Right"</span>, <span class="hljs-number">40</span>: <span class="hljs-string">"Down"</span>, <span class="hljs-number">44</span>: <span class="hljs-string">"PrintScrn"</span>, <span class="hljs-number">45</span>: <span class="hljs-string">"Insert"</span>,
    <span class="hljs-number">46</span>: <span class="hljs-string">"Delete"</span>, <span class="hljs-number">59</span>: <span class="hljs-string">";"</span>, <span class="hljs-number">61</span>: <span class="hljs-string">"="</span>, <span class="hljs-number">91</span>: <span class="hljs-string">"Mod"</span>, <span class="hljs-number">92</span>: <span class="hljs-string">"Mod"</span>, <span class="hljs-number">93</span>: <span class="hljs-string">"Mod"</span>,
    <span class="hljs-number">106</span>: <span class="hljs-string">"*"</span>, <span class="hljs-number">107</span>: <span class="hljs-string">"="</span>, <span class="hljs-number">109</span>: <span class="hljs-string">"-"</span>, <span class="hljs-number">110</span>: <span class="hljs-string">"."</span>, <span class="hljs-number">111</span>: <span class="hljs-string">"/"</span>, <span class="hljs-number">127</span>: <span class="hljs-string">"Delete"</span>,
    <span class="hljs-number">173</span>: <span class="hljs-string">"-"</span>, <span class="hljs-number">186</span>: <span class="hljs-string">";"</span>, <span class="hljs-number">187</span>: <span class="hljs-string">"="</span>, <span class="hljs-number">188</span>: <span class="hljs-string">","</span>, <span class="hljs-number">189</span>: <span class="hljs-string">"-"</span>, <span class="hljs-number">190</span>: <span class="hljs-string">"."</span>, <span class="hljs-number">191</span>: <span class="hljs-string">"/"</span>, <span class="hljs-number">192</span>: <span class="hljs-string">"`"</span>, <span class="hljs-number">219</span>: <span class="hljs-string">"["</span>, <span class="hljs-number">220</span>: <span class="hljs-string">"\\"</span>,
    <span class="hljs-number">221</span>: <span class="hljs-string">"]"</span>, <span class="hljs-number">222</span>: <span class="hljs-string">"'"</span>, <span class="hljs-number">63232</span>: <span class="hljs-string">"Up"</span>, <span class="hljs-number">63233</span>: <span class="hljs-string">"Down"</span>, <span class="hljs-number">63234</span>: <span class="hljs-string">"Left"</span>, <span class="hljs-number">63235</span>: <span class="hljs-string">"Right"</span>, <span class="hljs-number">63272</span>: <span class="hljs-string">"Delete"</span>,
    <span class="hljs-number">63273</span>: <span class="hljs-string">"Home"</span>, <span class="hljs-number">63275</span>: <span class="hljs-string">"End"</span>, <span class="hljs-number">63276</span>: <span class="hljs-string">"PageUp"</span>, <span class="hljs-number">63277</span>: <span class="hljs-string">"PageDown"</span>, <span class="hljs-number">63302</span>: <span class="hljs-string">"Insert"</span>
  };
  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Number keys</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) keyNames[i + <span class="hljs-number">48</span>] = keyNames[i + <span class="hljs-number">96</span>] = <span class="hljs-built_in">String</span>(i);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Alphabetic keys</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">65</span>; i &lt;= <span class="hljs-number">90</span>; i++) keyNames[i] = <span class="hljs-built_in">String</span>.fromCharCode(i);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Function keys</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">12</span>; i++) keyNames[i + <span class="hljs-number">111</span>] = keyNames[i + <span class="hljs-number">63235</span>] = <span class="hljs-string">"F"</span> + i;
  })();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>BIDI HELPERS</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iterateBidiSections</span>(<span class="hljs-params">order, from, to, f</span>) </span>{
    <span class="hljs-keyword">if</span> (!order) <span class="hljs-keyword">return</span> f(from, to, <span class="hljs-string">"ltr"</span>);
    <span class="hljs-keyword">var</span> found = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; order.length; ++i) {
      <span class="hljs-keyword">var</span> part = order[i];
      <span class="hljs-keyword">if</span> (part.from &lt; to &amp;&amp; part.to &gt; from || from == to &amp;&amp; part.to == from) {
        f(<span class="hljs-built_in">Math</span>.max(part.from, from), <span class="hljs-built_in">Math</span>.min(part.to, to), part.level == <span class="hljs-number">1</span> ? <span class="hljs-string">"rtl"</span> : <span class="hljs-string">"ltr"</span>);
        found = <span class="hljs-literal">true</span>;
      }
    }
    <span class="hljs-keyword">if</span> (!found) f(from, to, <span class="hljs-string">"ltr"</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bidiLeft</span>(<span class="hljs-params">part</span>) </span>{ <span class="hljs-keyword">return</span> part.level % <span class="hljs-number">2</span> ? part.to : part.from; }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bidiRight</span>(<span class="hljs-params">part</span>) </span>{ <span class="hljs-keyword">return</span> part.level % <span class="hljs-number">2</span> ? part.from : part.to; }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineLeft</span>(<span class="hljs-params">line</span>) </span>{ <span class="hljs-keyword">var</span> order = getOrder(line); <span class="hljs-keyword">return</span> order ? bidiLeft(order[<span class="hljs-number">0</span>]) : <span class="hljs-number">0</span>; }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineRight</span>(<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">var</span> order = getOrder(line);
    <span class="hljs-keyword">if</span> (!order) <span class="hljs-keyword">return</span> line.text.length;
    <span class="hljs-keyword">return</span> bidiRight(lst(order));
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineStart</span>(<span class="hljs-params">cm, lineN</span>) </span>{
    <span class="hljs-keyword">var</span> line = getLine(cm.doc, lineN);
    <span class="hljs-keyword">var</span> visual = visualLine(line);
    <span class="hljs-keyword">if</span> (visual != line) lineN = lineNo(visual);
    <span class="hljs-keyword">var</span> order = getOrder(visual);
    <span class="hljs-keyword">var</span> ch = !order ? <span class="hljs-number">0</span> : order[<span class="hljs-number">0</span>].level % <span class="hljs-number">2</span> ? lineRight(visual) : lineLeft(visual);
    <span class="hljs-keyword">return</span> Pos(lineN, ch);
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineEnd</span>(<span class="hljs-params">cm, lineN</span>) </span>{
    <span class="hljs-keyword">var</span> merged, line = getLine(cm.doc, lineN);
    <span class="hljs-keyword">while</span> (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>).line;
      lineN = <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">var</span> order = getOrder(line);
    <span class="hljs-keyword">var</span> ch = !order ? line.text.length : order[<span class="hljs-number">0</span>].level % <span class="hljs-number">2</span> ? lineLeft(line) : lineRight(line);
    <span class="hljs-keyword">return</span> Pos(lineN == <span class="hljs-literal">null</span> ? lineNo(line) : lineN, ch);
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineStartSmart</span>(<span class="hljs-params">cm, pos</span>) </span>{
    <span class="hljs-keyword">var</span> start = lineStart(cm, pos.line);
    <span class="hljs-keyword">var</span> line = getLine(cm.doc, start.line);
    <span class="hljs-keyword">var</span> order = getOrder(line);
    <span class="hljs-keyword">if</span> (!order || order[<span class="hljs-number">0</span>].level == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> firstNonWS = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, line.text.search(<span class="hljs-regexp">/\S/</span>));
      <span class="hljs-keyword">var</span> inWS = pos.line == start.line &amp;&amp; pos.ch &lt;= firstNonWS &amp;&amp; pos.ch;
      <span class="hljs-keyword">return</span> Pos(start.line, inWS ? <span class="hljs-number">0</span> : firstNonWS);
    }
    <span class="hljs-keyword">return</span> start;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareBidiLevel</span>(<span class="hljs-params">order, a, b</span>) </span>{
    <span class="hljs-keyword">var</span> linedir = order[<span class="hljs-number">0</span>].level;
    <span class="hljs-keyword">if</span> (a == linedir) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (b == linedir) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> a &lt; b;
  }
  <span class="hljs-keyword">var</span> bidiOther;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBidiPartAt</span>(<span class="hljs-params">order, pos</span>) </span>{
    bidiOther = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, found; i &lt; order.length; ++i) {
      <span class="hljs-keyword">var</span> cur = order[i];
      <span class="hljs-keyword">if</span> (cur.from &lt; pos &amp;&amp; cur.to &gt; pos) <span class="hljs-keyword">return</span> i;
      <span class="hljs-keyword">if</span> ((cur.from == pos || cur.to == pos)) {
        <span class="hljs-keyword">if</span> (found == <span class="hljs-literal">null</span>) {
          found = i;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (compareBidiLevel(order, cur.level, order[found].level)) {
          <span class="hljs-keyword">if</span> (cur.from != cur.to) bidiOther = found;
          <span class="hljs-keyword">return</span> i;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (cur.from != cur.to) bidiOther = i;
          <span class="hljs-keyword">return</span> found;
        }
      }
    }
    <span class="hljs-keyword">return</span> found;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveInLine</span>(<span class="hljs-params">line, pos, dir, byUnit</span>) </span>{
    <span class="hljs-keyword">if</span> (!byUnit) <span class="hljs-keyword">return</span> pos + dir;
    <span class="hljs-keyword">do</span> pos += dir;
    <span class="hljs-keyword">while</span> (pos &gt; <span class="hljs-number">0</span> &amp;&amp; isExtendingChar(line.text.charAt(pos)));
    <span class="hljs-keyword">return</span> pos;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is needed in order to move &#39;visually&#39; through bi-directional
text -- i.e., pressing left should make the cursor go left, even
when in RTL text. The tricky part is the &#39;jumps&#39;, where RTL and
LTR text touch each other. This often requires the cursor offset
to move more than one unit, in order to visually move one unit.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveVisually</span>(<span class="hljs-params">line, start, dir, byUnit</span>) </span>{
    <span class="hljs-keyword">var</span> bidi = getOrder(line);
    <span class="hljs-keyword">if</span> (!bidi) <span class="hljs-keyword">return</span> moveLogically(line, start, dir, byUnit);
    <span class="hljs-keyword">var</span> pos = getBidiPartAt(bidi, start), part = bidi[pos];
    <span class="hljs-keyword">var</span> target = moveInLine(line, start, part.level % <span class="hljs-number">2</span> ? -dir : dir, byUnit);

    <span class="hljs-keyword">for</span> (;;) {
      <span class="hljs-keyword">if</span> (target &gt; part.from &amp;&amp; target &lt; part.to) <span class="hljs-keyword">return</span> target;
      <span class="hljs-keyword">if</span> (target == part.from || target == part.to) {
        <span class="hljs-keyword">if</span> (getBidiPartAt(bidi, target) == pos) <span class="hljs-keyword">return</span> target;
        part = bidi[pos += dir];
        <span class="hljs-keyword">return</span> (dir &gt; <span class="hljs-number">0</span>) == part.level % <span class="hljs-number">2</span> ? part.to : part.from;
      } <span class="hljs-keyword">else</span> {
        part = bidi[pos += dir];
        <span class="hljs-keyword">if</span> (!part) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> ((dir &gt; <span class="hljs-number">0</span>) == part.level % <span class="hljs-number">2</span>)
          target = moveInLine(line, part.to, -<span class="hljs-number">1</span>, byUnit);
        <span class="hljs-keyword">else</span>
          target = moveInLine(line, part.from, <span class="hljs-number">1</span>, byUnit);
      }
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveLogically</span>(<span class="hljs-params">line, start, dir, byUnit</span>) </span>{
    <span class="hljs-keyword">var</span> target = start + dir;
    <span class="hljs-keyword">if</span> (byUnit) <span class="hljs-keyword">while</span> (target &gt; <span class="hljs-number">0</span> &amp;&amp; isExtendingChar(line.text.charAt(target))) target += dir;
    <span class="hljs-keyword">return</span> target &lt; <span class="hljs-number">0</span> || target &gt; line.text.length ? <span class="hljs-literal">null</span> : target;
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Bidirectional ordering algorithm
See <a href="http://unicode.org/reports/tr9/tr9-13.html">http://unicode.org/reports/tr9/tr9-13.html</a> for the algorithm
that this (partially) implements.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>One-char codes used for character types:
L (L):   Left-to-Right
R (R):   Right-to-Left
r (AL):  Right-to-Left Arabic
1 (EN):  European Number</p>
<ul>
<li>(ES):  European Number Separator
% (ET):  European Number Terminator
n (AN):  Arabic Number
, (CS):  Common Number Separator
m (NSM): Non-Spacing Mark
b (BN):  Boundary Neutral
s (B):   Paragraph Separator
t (S):   Segment Separator
w (WS):  Whitespace
N (ON):  Other Neutrals</li>
</ul></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns null if characters are ordered as they appear
(left-to-right), or an array of sections ({from, to, level}
objects) in the order in which they occur visually.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> bidiOrdering = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Character types for codepoints 0 to 0xff</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> lowTypes = <span class="hljs-string">"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Character types for codepoints 0x600 to 0x6ff</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> arabicTypes = <span class="hljs-string">"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm"</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">charType</span>(<span class="hljs-params">code</span>) </span>{
      <span class="hljs-keyword">if</span> (code &lt;= <span class="hljs-number">0xf7</span>) <span class="hljs-keyword">return</span> lowTypes.charAt(code);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">0x590</span> &lt;= code &amp;&amp; code &lt;= <span class="hljs-number">0x5f4</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">"R"</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">0x600</span> &lt;= code &amp;&amp; code &lt;= <span class="hljs-number">0x6ed</span>) <span class="hljs-keyword">return</span> arabicTypes.charAt(code - <span class="hljs-number">0x600</span>);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">0x6ee</span> &lt;= code &amp;&amp; code &lt;= <span class="hljs-number">0x8ac</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">"r"</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">0x2000</span> &lt;= code &amp;&amp; code &lt;= <span class="hljs-number">0x200b</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">"w"</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (code == <span class="hljs-number">0x200c</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">"b"</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">"L"</span>;
    }

    <span class="hljs-keyword">var</span> bidiRE = <span class="hljs-regexp">/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/</span>;
    <span class="hljs-keyword">var</span> isNeutral = <span class="hljs-regexp">/[stwN]/</span>, isStrong = <span class="hljs-regexp">/[LRr]/</span>, countsAsLeft = <span class="hljs-regexp">/[Lb1n]/</span>, countsAsNum = <span class="hljs-regexp">/[1n]/</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Browsers seem to always treat the boundaries of block elements as being L.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> outerType = <span class="hljs-string">"L"</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BidiSpan</span>(<span class="hljs-params">level, from, to</span>) </span>{
      <span class="hljs-keyword">this</span>.level = level;
      <span class="hljs-keyword">this</span>.from = from; <span class="hljs-keyword">this</span>.to = to;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>{
      <span class="hljs-keyword">if</span> (!bidiRE.test(str)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> len = str.length, types = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, type; i &lt; len; ++i)
        types.push(type = charType(str.charCodeAt(i)));</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>W1. Examine each non-spacing mark (NSM) in the level run, and
change the type of the NSM to the type of the previous
character. If the NSM is at the start of the level run, it will
get the type of sor.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, prev = outerType; i &lt; len; ++i) {
        <span class="hljs-keyword">var</span> type = types[i];
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"m"</span>) types[i] = prev;
        <span class="hljs-keyword">else</span> prev = type;
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>W2. Search backwards from each instance of a European number
until the first strong type (R, L, AL, or sor) is found. If an
AL is found, change the type of the European number to Arabic
number.
W3. Change all ALs to R.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, cur = outerType; i &lt; len; ++i) {
        <span class="hljs-keyword">var</span> type = types[i];
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"1"</span> &amp;&amp; cur == <span class="hljs-string">"r"</span>) types[i] = <span class="hljs-string">"n"</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isStrong.test(type)) { cur = type; <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"r"</span>) types[i] = <span class="hljs-string">"R"</span>; }
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>W4. A single European separator between two European numbers
changes to a European number. A single common separator between
two numbers of the same type changes to that type.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, prev = types[<span class="hljs-number">0</span>]; i &lt; len - <span class="hljs-number">1</span>; ++i) {
        <span class="hljs-keyword">var</span> type = types[i];
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"+"</span> &amp;&amp; prev == <span class="hljs-string">"1"</span> &amp;&amp; types[i+<span class="hljs-number">1</span>] == <span class="hljs-string">"1"</span>) types[i] = <span class="hljs-string">"1"</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">","</span> &amp;&amp; prev == types[i+<span class="hljs-number">1</span>] &amp;&amp;
                 (prev == <span class="hljs-string">"1"</span> || prev == <span class="hljs-string">"n"</span>)) types[i] = prev;
        prev = type;
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>W5. A sequence of European terminators adjacent to European
numbers changes to all European numbers.
W6. Otherwise, separators and terminators change to Other
Neutral.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) {
        <span class="hljs-keyword">var</span> type = types[i];
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">","</span>) types[i] = <span class="hljs-string">"N"</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"%"</span>) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> end = i + <span class="hljs-number">1</span>; end &lt; len &amp;&amp; types[end] == <span class="hljs-string">"%"</span>; ++end) {}
          <span class="hljs-keyword">var</span> replace = (i &amp;&amp; types[i-<span class="hljs-number">1</span>] == <span class="hljs-string">"!"</span>) || (end &lt; len &amp;&amp; types[end] == <span class="hljs-string">"1"</span>) ? <span class="hljs-string">"1"</span> : <span class="hljs-string">"N"</span>;
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i; j &lt; end; ++j) types[j] = replace;
          i = end - <span class="hljs-number">1</span>;
        }
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>W7. Search backwards from each instance of a European number
until the first strong type (R, L, or sor) is found. If an L is
found, then change the type of the European number to L.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, cur = outerType; i &lt; len; ++i) {
        <span class="hljs-keyword">var</span> type = types[i];
        <span class="hljs-keyword">if</span> (cur == <span class="hljs-string">"L"</span> &amp;&amp; type == <span class="hljs-string">"1"</span>) types[i] = <span class="hljs-string">"L"</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isStrong.test(type)) cur = type;
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>N1. A sequence of neutrals takes the direction of the
surrounding strong text if the text on both sides has the same
direction. European and Arabic numbers act as if they were R in
terms of their influence on neutrals. Start-of-level-run (sor)
and end-of-level-run (eor) are used at level run boundaries.
N2. Any remaining neutrals take the embedding direction.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) {
        <span class="hljs-keyword">if</span> (isNeutral.test(types[i])) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> end = i + <span class="hljs-number">1</span>; end &lt; len &amp;&amp; isNeutral.test(types[end]); ++end) {}
          <span class="hljs-keyword">var</span> before = (i ? types[i-<span class="hljs-number">1</span>] : outerType) == <span class="hljs-string">"L"</span>;
          <span class="hljs-keyword">var</span> after = (end &lt; len ? types[end] : outerType) == <span class="hljs-string">"L"</span>;
          <span class="hljs-keyword">var</span> replace = before || after ? <span class="hljs-string">"L"</span> : <span class="hljs-string">"R"</span>;
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i; j &lt; end; ++j) types[j] = replace;
          i = end - <span class="hljs-number">1</span>;
        }
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Here we depart from the documented algorithm, in order to avoid
building up an actual levels array. Since there are only three
levels (0, 1, 2) in an implementation that doesn&#39;t take
explicit embedding into account, we can build up the order on
the fly, without following the level-based algorithm.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> order = [], m;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len;) {
        <span class="hljs-keyword">if</span> (countsAsLeft.test(types[i])) {
          <span class="hljs-keyword">var</span> start = i;
          <span class="hljs-keyword">for</span> (++i; i &lt; len &amp;&amp; countsAsLeft.test(types[i]); ++i) {}
          order.push(<span class="hljs-keyword">new</span> BidiSpan(<span class="hljs-number">0</span>, start, i));
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> pos = i, at = order.length;
          <span class="hljs-keyword">for</span> (++i; i &lt; len &amp;&amp; types[i] != <span class="hljs-string">"L"</span>; ++i) {}
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = pos; j &lt; i;) {
            <span class="hljs-keyword">if</span> (countsAsNum.test(types[j])) {
              <span class="hljs-keyword">if</span> (pos &lt; j) order.splice(at, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> BidiSpan(<span class="hljs-number">1</span>, pos, j));
              <span class="hljs-keyword">var</span> nstart = j;
              <span class="hljs-keyword">for</span> (++j; j &lt; i &amp;&amp; countsAsNum.test(types[j]); ++j) {}
              order.splice(at, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> BidiSpan(<span class="hljs-number">2</span>, nstart, j));
              pos = j;
            } <span class="hljs-keyword">else</span> ++j;
          }
          <span class="hljs-keyword">if</span> (pos &lt; i) order.splice(at, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> BidiSpan(<span class="hljs-number">1</span>, pos, i));
        }
      }
      <span class="hljs-keyword">if</span> (order[<span class="hljs-number">0</span>].level == <span class="hljs-number">1</span> &amp;&amp; (m = str.match(<span class="hljs-regexp">/^\s+/</span>))) {
        order[<span class="hljs-number">0</span>].from = m[<span class="hljs-number">0</span>].length;
        order.unshift(<span class="hljs-keyword">new</span> BidiSpan(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m[<span class="hljs-number">0</span>].length));
      }
      <span class="hljs-keyword">if</span> (lst(order).level == <span class="hljs-number">1</span> &amp;&amp; (m = str.match(<span class="hljs-regexp">/\s+$/</span>))) {
        lst(order).to -= m[<span class="hljs-number">0</span>].length;
        order.push(<span class="hljs-keyword">new</span> BidiSpan(<span class="hljs-number">0</span>, len - m[<span class="hljs-number">0</span>].length, len));
      }
      <span class="hljs-keyword">if</span> (order[<span class="hljs-number">0</span>].level == <span class="hljs-number">2</span>)
        order.unshift(<span class="hljs-keyword">new</span> BidiSpan(<span class="hljs-number">1</span>, order[<span class="hljs-number">0</span>].to, order[<span class="hljs-number">0</span>].to));
      <span class="hljs-keyword">if</span> (order[<span class="hljs-number">0</span>].level != lst(order).level)
        order.push(<span class="hljs-keyword">new</span> BidiSpan(order[<span class="hljs-number">0</span>].level, len, len));

      <span class="hljs-keyword">return</span> order;
    };
  })();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>THE END</p></div></div><div class="code"><div class="wrapper">  CodeMirror.version = <span class="hljs-string">"5.14.3"</span>;

  <span class="hljs-keyword">return</span> CodeMirror;
});</div></div></div></div></body></html>
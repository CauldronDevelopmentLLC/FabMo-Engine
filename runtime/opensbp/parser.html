<!DOCTYPE html><html lang="en"><head><title>runtime/opensbp/parser</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../"><meta name="groc-document-path" content="runtime/opensbp/parser"><meta name="groc-project-path" content="runtime/opensbp/parser.js"><link rel="stylesheet" type="text/css" media="all" href="../../assets/style.css"><script type="text/javascript" src="../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">runtime/opensbp/parser.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>runtime/opensbp/parser.js</p>
<p>This is the wrapper module for the OpenSBP parser.
Largely, parsing is one by sbp_parser.js which is generated by peg.js from sbp_parser.pegjs</p>
<p>This module wraps the parsing functions with convenience methods and objects and provides some additional
parsing functionality (sanitizing inputs, optimized parsing for certain commands, working with streams, etc)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-keyword">var</span> sbp_parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./sbp_parser'</span>)
<span class="hljs-keyword">var</span> log = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../log'</span>).logger(<span class="hljs-string">'sbp'</span>);
<span class="hljs-keyword">var</span> CMD_SPACE_RE = <span class="hljs-regexp">/(\w\w)([ \t]+)([^\s\t,].*)/i</span>
<span class="hljs-keyword">var</span> CMD_RE = <span class="hljs-regexp">/^\s*(\w\w)(((\s*,\s*)([+-]?[0-9]+(\.[0-9]+)?)?)+)\s*$/i</span>
<span class="hljs-keyword">var</span> STUPID_STRING_RE = <span class="hljs-regexp">/(\&amp;[A-Za-z]\w*)\s*=([^\n]*)/i</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parse the provided statement
Return the parsed statement
fastParse attempts to use string slicing and regular expressions to parse the simpler mnemonic commands
if fastParse can&#39;t figure it out (command contains complex expressions or is not of the right type) 
it will return null.  Since the majority of all OpenSBP commands are simple ones, this function will
usually work, and will save a bunch of time over using the pegjs parser for everything.
  statement - The string statement to parse</p></div></div><div class="code"><div class="wrapper">fastParse = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">statement</span>) </span>{
    <span class="hljs-keyword">var</span> match = statement.match(CMD_RE);
    <span class="hljs-keyword">if</span>(match) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>2 character mnemonic commands (IF is an exception)</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span>(match[<span class="hljs-number">1</span>] === <span class="hljs-string">'IF'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return value, which we&#39;ll fill in with arguments</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">var</span> retval = {
            type : <span class="hljs-string">'cmd'</span>,
            cmd : match[<span class="hljs-number">1</span>],
            args : []
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parse the arguments, build a list as we go</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">var</span> args = match[<span class="hljs-number">2</span>].split(<span class="hljs-string">','</span>);
        <span class="hljs-keyword">var</span> pargs = args.slice(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;pargs.length; i++) {
            <span class="hljs-keyword">var</span> arg = pargs[i]
            <span class="hljs-keyword">if</span>(arg.trim() === <span class="hljs-string">''</span>) {
                retval.args.push(<span class="hljs-literal">undefined</span>);
            } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO not sure we actually need to do this - numbers get parsed out later also</p></div></div><div class="code"><div class="wrapper">                <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Number</span>(arg);
                retval.args.push(<span class="hljs-built_in">isNaN</span>(n) ? arg : n);
            }
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return the return value</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> retval;
    }

    <span class="hljs-keyword">var</span> match = statement.match(CMD_SPACE_RE);
    <span class="hljs-keyword">if</span>(match) {
        <span class="hljs-keyword">if</span>(match[<span class="hljs-number">1</span>] != <span class="hljs-string">'IF'</span>) {
            statement = statement.replace(CMD_SPACE_RE, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match, cmd, space, rest, offset, string</span>) </span>{
                <span class="hljs-keyword">return</span> cmd + <span class="hljs-string">','</span> + rest;
            });
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parse the provided line
Returns an object representing the parsed statement
Tries to fast parse first, falls back on the more thorough pegjs parser</p></div></div><div class="code"><div class="wrapper">parseLine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
    line = line.replace(<span class="hljs-regexp">/\r/g</span>,<span class="hljs-string">''</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extract end-of-line comments</p></div></div><div class="code"><div class="wrapper">    parts = line.split(<span class="hljs-string">"'"</span>);
    statement = parts[<span class="hljs-number">0</span>]
    comment = parts.slice(<span class="hljs-number">1</span>,parts.length)

    <span class="hljs-keyword">try</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use parse optimization</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">var</span> obj = fastParse(statement)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>But fall back on PegJS</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span>(!obj) {
            obj = sbp_parser.parse(statement);
        }
    } <span class="hljs-keyword">catch</span>(e) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parse failure could be because of a stupid unquoted string:
eg: &amp;mystring = Hey this is a string, no big deal.
If this is a case, actually allow it like an insane person:</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">var</span> match = statement.match(STUPID_STRING_RE)
        <span class="hljs-keyword">if</span>(match) {
            obj = {type:<span class="hljs-string">"assign"</span>,<span class="hljs-keyword">var</span>:match[<span class="hljs-number">1</span>], expr:match[<span class="hljs-number">2</span>]}
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> e <span class="hljs-comment">// Or if not, throw the exception like we should do anyway</span>
        }
    }
    </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Deal with full-line comments</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(obj) || obj === <span class="hljs-literal">null</span>) {
        obj = {<span class="hljs-string">"type"</span>:<span class="hljs-string">"comment"</span>, <span class="hljs-string">"comment"</span>:comment};
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span>(comment != <span class="hljs-string">''</span>) {obj.comment = comment}
    }
    <span class="hljs-keyword">if</span>(obj.type == <span class="hljs-string">'cmd'</span>) {
        obj.cmd = obj.cmd.toUpperCase();
    }

    <span class="hljs-keyword">return</span> obj
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parse a string or array of strings
Returns a list of parsed statements
  data - The string or array input to parse</p></div></div><div class="code"><div class="wrapper">parse = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
    output = []
    </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parse from a string or an array of strings</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(data)) {
        lines = data;
    } <span class="hljs-keyword">else</span> {
        lines = data.split(<span class="hljs-string">'\n'</span>);
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Iterate over lines and parse one by one.  Throw an error if any don&#39;t parse.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;lines.length; i++) {
        <span class="hljs-keyword">try</span> {            
            output.push(parseLine(lines[i]))
        } <span class="hljs-keyword">catch</span>(err) {
            <span class="hljs-keyword">if</span>(err.name == <span class="hljs-string">'SyntaxError'</span>) {
                log.error(<span class="hljs-string">"Syntax Error on line "</span> + (i+<span class="hljs-number">1</span>))
                log.error(<span class="hljs-string">"Expected "</span> + <span class="hljs-built_in">JSON</span>.stringify(err.expected) + <span class="hljs-string">" but found "</span> + err.found)
                err.line = i+<span class="hljs-number">1</span>;
                log.error(err.line)
            } <span class="hljs-keyword">else</span> {
                log.error(err);
            }
            <span class="hljs-keyword">throw</span> err
        }
    }
    <span class="hljs-keyword">return</span> output
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Constructor for Parser object
Parser is a transform stream that accepts string input and streams out parsed statement objects</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parser</span>(<span class="hljs-params">options</span>) </span>{
    <span class="hljs-keyword">var</span> options = options || {};
    options.objectMode = <span class="hljs-literal">true</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>allow use without new</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Parser)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Parser(options);
  }
  <span class="hljs-keyword">this</span>.scrap = <span class="hljs-string">""</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>init Transform</p></div></div><div class="code"><div class="wrapper">  stream.Transform.call(<span class="hljs-keyword">this</span>, options);
}
util.inherits(Parser, stream.Transform);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Transform function, processes chunks of string data coming in, pushing parsed objects to the output</p></div></div><div class="code"><div class="wrapper">Parser.prototype._transform = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chunk, enc, cb</span>) </span>{
    <span class="hljs-keyword">var</span> str = <span class="hljs-keyword">this</span>.scrap + chunk.toString()
    <span class="hljs-keyword">this</span>.pause();
    <span class="hljs-keyword">try</span> {  
      <span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;str.length; i++) {
            <span class="hljs-keyword">if</span>(str[i] === <span class="hljs-string">'\n'</span>) {
                <span class="hljs-keyword">var</span> substr = str.substring(start, i)
                <span class="hljs-keyword">this</span>.push(parseLine(substr));
                start = i+<span class="hljs-number">1</span>;
            }
        }
        <span class="hljs-keyword">this</span>.scrap = str.substring(start)
    } <span class="hljs-keyword">catch</span>(e) {
        log.error(e)
    }
    <span class="hljs-keyword">this</span>.resume();
    cb();

}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Handle a stream flush</p></div></div><div class="code"><div class="wrapper">Parser.prototype._flush = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">done</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scrap) { <span class="hljs-keyword">this</span>.push(parseLine(<span class="hljs-keyword">this</span>.scrap)); }
  <span class="hljs-keyword">this</span>.scrap = <span class="hljs-string">''</span>;
  done();
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parse data from the provided stream
Return a stream whose output is a stream of parsed statements
        s - The input stream
  options - parser options</p></div></div><div class="code"><div class="wrapper">parseStream = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, options</span>) </span>{
    <span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> Parser(options);
    <span class="hljs-keyword">return</span> s.pipe(parser)
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parse the specified file
  filename - Full path of file to be parsed
  callback - Called with parsed data, or with error if error</p></div></div><div class="code"><div class="wrapper">parseFile = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">filename, callback</span>) </span>{
    <span class="hljs-keyword">var</span> st = fs.createReadStream(filename);
    <span class="hljs-keyword">var</span> obj = []
        <span class="hljs-keyword">return</span> parseStream(st)
            .on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
                obj.push(data)
            })
            .on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                callback(<span class="hljs-literal">null</span>, obj);
        })
        .on(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
        callback(err);
        });
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="below-here-are-some-functions-for-testing-the-parser-functions">Below here are some functions for testing the parser functions</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> main = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> argv = <span class="hljs-built_in">require</span>(<span class="hljs-string">'minimist'</span>)(process.argv);
    <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
    <span class="hljs-keyword">var</span> filename = argv[<span class="hljs-string">'_'</span>][<span class="hljs-number">2</span>]

    <span class="hljs-keyword">if</span>(filename) {
        log.tick();
        fs.readFile(filename, <span class="hljs-string">'utf8'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) </span>{
            <span class="hljs-keyword">if</span>(err) {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(err);
            } 
            
            <span class="hljs-keyword">var</span> obj = parse(data);
            log.tock(<span class="hljs-string">'parse'</span>);
        });
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Usage: node parser.js filename.sbp"</span>);
    }
}

<span class="hljs-keyword">var</span> main2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> argv = <span class="hljs-built_in">require</span>(<span class="hljs-string">'minimist'</span>)(process.argv);
    <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
    <span class="hljs-keyword">var</span> filename = argv[<span class="hljs-string">'_'</span>][<span class="hljs-number">2</span>]
    <span class="hljs-keyword">if</span>(filename) {
        log.tick();
        <span class="hljs-keyword">var</span> fileStream = fs.createReadStream(filename);
        <span class="hljs-keyword">var</span> obj = []
        parseStream(fileStream)
            .on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
                obj.push(data)
            })
            .on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(obj.length + <span class="hljs-string">' lines processed.'</span>)
        log.tock(<span class="hljs-string">"parse"</span>);
            });
    }
}

<span class="hljs-keyword">if</span> (<span class="hljs-built_in">require</span>.main === <span class="hljs-built_in">module</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>   main();</p></div></div><div class="code"><div class="wrapper">    main2();
}

exports.parse = parse
exports.parseFile = parseFile
exports.parseStream = parseStream</div></div></div></div></body></html>
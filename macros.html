<!DOCTYPE html><html lang="en"><head><title>macros</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="macros"><meta name="groc-project-path" content="macros.js"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path">macros.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>macros.js</p>
<p>Functions and data relating to macros.</p>
<p>Macros are sort of &quot;canned routines&quot; that are analagous to the &quot;custom cuts&quot; in SB3.
They are in fact, invoked in the same way in the OpenSBP runtime as they were in SB3,
by using the C# command (C3 to home the tool, C2 for Z-zero, etc.)</p>
<p>Macros are stored on disk at (for example) /opt/fabmo/macros - anything in this directory is scanned
at startup and files containing an appropriate header are loaded into memory.  Ideally macros can be
in any file format, but the OpenSBP format is the only one that is actually implemented right now.
When macros are modified by the user they are saved back to the files that they were loaded from. The
header in each macro file contains metadata that identifies the macro, its custom-cut number, and description</p>
<p>The macro headers are part of the files, but they are not displayed to the user when editing.  The user
is able to edit those fields, but only as exposed through the UI in the macro manager.  This prevents
users from corrupting the headers and creating a bunch of edge cases when editing macros.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs-extra'</span>)
<span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
<span class="hljs-keyword">var</span> <span class="hljs-keyword">async</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async'</span>)
<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./config'</span>)
<span class="hljs-keyword">var</span> log = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./log'</span>).logger(<span class="hljs-string">'macro'</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The marker in the header that signifies a macro.
TODO - This is used to create files, but not in the regexs used to parse them (see below)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> MARKER = <span class="hljs-string">'!FABMO!'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All the loaded macros will be stored here</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> macros = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>These functions create macro headers from the specified options
options:
        name - The macro display name
 description - The macro description
     enabled - Whether or not the macro is enabled (TODO: Is this used?)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> _createGCodeHeader = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
	name = options.name || <span class="hljs-string">"Untitled Macro"</span>
	description = options.description || <span class="hljs-string">""</span>
	enabled = options.enabled || <span class="hljs-literal">true</span>
	<span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + MARKER + <span class="hljs-string">"name:"</span> + name + <span class="hljs-string">")\n"</span> + 
	       <span class="hljs-string">"("</span> + MARKER + <span class="hljs-string">"description:"</span> + description + <span class="hljs-string">")\n"</span> + 
	       <span class="hljs-string">"("</span> + MARKER + <span class="hljs-string">"enabled:"</span> + enabled + <span class="hljs-string">")\n"</span>
}

<span class="hljs-keyword">var</span> _createOpenSBPHeader = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
	name = options.name || <span class="hljs-string">"Untitled Macro"</span>
	description = options.description || <span class="hljs-string">""</span>
	enabled = options.enabled || <span class="hljs-literal">true</span>
	<span class="hljs-keyword">return</span> <span class="hljs-string">"'"</span> + MARKER + <span class="hljs-string">"name:"</span> + name + <span class="hljs-string">"\n"</span> + 
	       <span class="hljs-string">"'"</span> + MARKER + <span class="hljs-string">"description:"</span> + description + <span class="hljs-string">"\n"</span>
	       <span class="hljs-string">"'"</span> + MARKER + <span class="hljs-string">"enabled:"</span> + enabled + <span class="hljs-string">"\n"</span>

}

<span class="hljs-keyword">var</span> _deleteMacroFile = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, callback</span>) </span>{
	<span class="hljs-keyword">var</span> macro_path = config.getDataDir(<span class="hljs-string">'macros'</span>);
	<span class="hljs-keyword">var</span> opensbp = path.join(macro_path, <span class="hljs-string">'macro_'</span> + index + <span class="hljs-string">'.sbp'</span>)
	<span class="hljs-keyword">var</span> gcode = path.join(macro_path, <span class="hljs-string">'macro_'</span> + index + <span class="hljs-string">'.nc'</span>)
	fs.unlink(opensbp, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
		fs.unlink(gcode, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
			callback(<span class="hljs-literal">null</span>);
		});
	});
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a number and a type, construct a path to the corresponding macro file</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> _createMacroFilename = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id, type</span>) </span>{
	<span class="hljs-keyword">var</span> macro_path = config.getDataDir(<span class="hljs-string">'macros'</span>);
	<span class="hljs-keyword">switch</span>(type) {
		<span class="hljs-keyword">case</span> <span class="hljs-string">'nc'</span>:
			<span class="hljs-keyword">return</span> path.join(macro_path, <span class="hljs-string">'macro_'</span> + id + <span class="hljs-string">'.nc'</span>);
			<span class="hljs-keyword">break</span>;

		<span class="hljs-keyword">case</span> <span class="hljs-string">'sbp'</span>:
			<span class="hljs-keyword">return</span> path.join(macro_path, <span class="hljs-string">'macro_'</span> + id + <span class="hljs-string">'.sbp'</span>);
			<span class="hljs-keyword">break</span>;

		<span class="hljs-keyword">default</span>:
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Invalid macro type: '</span> + type)
			<span class="hljs-keyword">break</span>;
	}
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create default macro content for the specified macro.
(Use if you want &quot;new&quot; macros to be non-empty)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> _createMacroDefaultContent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">macro</span>) </span>{
	<span class="hljs-keyword">switch</span>(macro.type) {
		<span class="hljs-keyword">case</span> <span class="hljs-string">'nc'</span>:
			<span class="hljs-comment">//return 	'( ' + macro.name + ' )\n( ' + macro.description + ' )\n\n';</span>
			<span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
            <span class="hljs-keyword">break</span>;

		<span class="hljs-keyword">case</span> <span class="hljs-string">'sbp'</span>:
			<span class="hljs-comment">//return 	"' " + macro.name + "\n' " + macro.description + "\n\n";</span>
			<span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
            <span class="hljs-keyword">break</span>;

		<span class="hljs-keyword">default</span>:
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Invalid macro type: '</span> + type)
			<span class="hljs-keyword">break</span>;
	}
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Iterate over the lines in the macro file, and parse out lines that appear to be part of the header
filename - The filename of the macro to parse out
callback - called with the parsed contents of the macro file, eg:
           {name : &#39;My Macro&#39;, description:&#39;Move to X=10&#39;,content : &#39;MZ,0.5\nMX,10&#39;}</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> _parseMacroFile = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">filename, callback</span>) </span>{
	<span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/[\(']!FABMO!(\w+):([^\)]*)\)?/</span>
	<span class="hljs-keyword">var</span> obj = {}
	<span class="hljs-keyword">var</span> ok = <span class="hljs-literal">false</span>;
	fs.readFile(filename, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) </span>{
		<span class="hljs-keyword">if</span>(err) {
			log.error(err)
		} <span class="hljs-keyword">else</span> {
			lines = data.toString().split(<span class="hljs-string">'\n'</span>);
			i = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">while</span>(i &lt; lines.length) {
				<span class="hljs-keyword">var</span> line = lines[i];
				<span class="hljs-keyword">var</span> groups = line.match(re);
				<span class="hljs-keyword">if</span>(groups) {
					ok = <span class="hljs-literal">true</span>;
					<span class="hljs-keyword">var</span> key = groups[<span class="hljs-number">1</span>];
					<span class="hljs-keyword">var</span> value = groups[<span class="hljs-number">2</span>];
					obj[key] = value;
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">break</span>;
				}
				i+=<span class="hljs-number">1</span>;
			}
			<span class="hljs-keyword">if</span>(ok) {
				obj.filename = filename;
				obj.content = lines.slice(i,lines.length).join(<span class="hljs-string">'\n'</span>);
				callback(<span class="hljs-literal">null</span>, obj);
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">try</span> {
					log.error(<span class="hljs-string">'File '</span> + filename + <span class="hljs-string">' failed to parse.  Unlinking it so it can be replaced.'</span>)
					fs.unlink(filename);
				} <span class="hljs-keyword">finally</span> {
					callback(<span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>)
				}
			}
		}
	});
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update an existing macro with new content
      id - The macro to update
   macro - The macro object that contains the new content
callback - called on completion, with an error if appropriate</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> update = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id, macro, callback</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the old macro data</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> old_macro = get(id);

	<span class="hljs-keyword">if</span>(old_macro) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Here, we&#39;re updating an existing macro
We only update fields that were provided in the macro passed in
Other fields, we leave alone.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">savemacro</span>(<span class="hljs-params">id, callback</span>) </span>{
			old_macro.name = macro.name || old_macro.name;
			old_macro.description = macro.description || old_macro.description;
			old_macro.content = macro.content || old_macro.content;
			old_macro.index = macro.index || old_macro.index;
			old_macro.type = macro.type || old_macro.type;
			old_macro.filename = _createMacroFilename(old_macro.index, old_macro.type);
			save(id, callback);
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This function takes an id, and the macro can carry an index as well
If the incoming macros index is different than the id that was passed,
we interpret that as an intent to move that macro to a new index.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span>(macro.index) {
			<span class="hljs-keyword">var</span> new_index = <span class="hljs-built_in">parseInt</span>(macro.index);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there&#39;s already a macro at the index that we&#39;re moving to, that&#39;s an error.
we&#39;re not going to write it.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span>(get(new_index)) {
				<span class="hljs-keyword">return</span> callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"There is already a macro #"</span> + new_index));
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the new index is different we actually want to move the macro,
so we assign it to the new index, trash the macro at the old index
trash the file at the old index, and finally save the file at the new index</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span>(new_index != old_macro.index) {
				macros[new_index] = old_macro;
				<span class="hljs-keyword">delete</span> macros[old_macro.index];
				_deleteMacroFile(old_macro.index, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
					savemacro(new_index, callback);
				});
			} <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Provided an index with the macro, but it&#39;s the the same, so no move needed</p></div></div><div class="code"><div class="wrapper">				savemacro(id, callback);
			}
		} <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Not moving the macro (didn&#39;t provide an index) so just save it</p></div></div><div class="code"><div class="wrapper">			savemacro(id, callback);
		}

	} <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In this case, we&#39;re &quot;updating&quot; a macro that doesn&#39;t exist, so create a new one
(filling in any attributes that were not provided by the update)</p></div></div><div class="code"><div class="wrapper">		new_macro = {
			name : macro.name || <span class="hljs-string">'Untitled Macro'</span>,
			description : macro.description || <span class="hljs-string">'Macro Description'</span>,
			type : macro.type || <span class="hljs-string">'sbp'</span>,
			enabled : macro.enabled || <span class="hljs-literal">true</span>, <span class="hljs-comment">// TODO fix this</span>
			index : id
		}
		new_macro.filename = _createMacroFilename(id, new_macro.type);
		new_macro.content = macro.content || _createMacroDefaultContent(new_macro);
		macros[id] = new_macro;
		save(id, callback);
	}
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Commit the provided macro id to disk.
callback is called with the macro object that was saved (or error)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> save = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id, callback</span>) </span>{
	macro = get(id);
	<span class="hljs-keyword">if</span>(macro) {
		<span class="hljs-keyword">var</span> macro_path = config.getDataDir(<span class="hljs-string">'macros'</span>);
		<span class="hljs-keyword">var</span> file_path = path.join(macro_path, <span class="hljs-string">'macro_'</span> + macro.index + <span class="hljs-string">'.'</span> + macro.type);
		<span class="hljs-keyword">switch</span>(macro.type) {
			<span class="hljs-keyword">case</span> <span class="hljs-string">'nc'</span>:
				<span class="hljs-keyword">var</span> header = _createGCodeHeader(macro);
				<span class="hljs-keyword">break</span>;			
			<span class="hljs-keyword">case</span> <span class="hljs-string">'sbp'</span>:
				<span class="hljs-keyword">var</span> header = _createOpenSBPHeader(macro);
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">default</span>:
				setImmediate(callback, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Invalid macro type: '</span> + macro.type));
				<span class="hljs-keyword">break</span>;
		}
		fs.open(file_path, <span class="hljs-string">'w'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, fd</span>) </span>{
			<span class="hljs-keyword">if</span>(err) {
				log.error(err);
				<span class="hljs-keyword">return</span> callback(err);
			}
			<span class="hljs-keyword">var</span> contents = <span class="hljs-keyword">new</span> Buffer(header + macro.content);
			fs.write(fd, contents, <span class="hljs-number">0</span>, contents.length, <span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, written, string</span>) </span>{
				<span class="hljs-keyword">if</span>(err) {
					log.error(err);
					<span class="hljs-keyword">return</span> callback(err);
				}
				fs.fsync(fd, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
					<span class="hljs-keyword">if</span>(err) {
						log.error(err);
					}
					fs.closeSync(fd);
					log.debug(<span class="hljs-string">'fsync()ed '</span> + file_path);
					callback(err, macro);
				});
			});
		});
	} <span class="hljs-keyword">else</span> {
		callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"No such macro "</span> + id));
	}
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Load all macros from disk</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> load = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
	<span class="hljs-keyword">var</span> macro_path = config.getDataDir(<span class="hljs-string">'macros'</span>);
	<span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/macro_([0-9]+)\.(nc|sbp)/</span>
	macros = {};
	fs.readdir(macro_path, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, files</span>) </span>{
		<span class="hljs-keyword">if</span>(err) {
			callback(err);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;files.length; i++) {
				files[i] = path.join(macro_path, files[i]);
			}
			<span class="hljs-keyword">async</span>.map(files, _parseMacroFile, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, results</span>) </span>{
				results.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">info</span>) </span>{
					<span class="hljs-keyword">if</span>(info) {
						groups = info.filename.match(re);
						<span class="hljs-keyword">if</span>(groups) {
							idx = <span class="hljs-built_in">parseInt</span>(groups[<span class="hljs-number">1</span>]);
							ext = groups[<span class="hljs-number">2</span>];
							info.index = idx;
							info.type = ext;
							macros[idx] = info;							
						}
					}
				});
				callback(<span class="hljs-literal">null</span>);
			});
		}
	})
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return the full list of macros (scrubbed)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> list = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
	retval = [];
	<span class="hljs-keyword">for</span>(key <span class="hljs-keyword">in</span> macros) {
		retval.push(getInfo(key));
	}
	<span class="hljs-keyword">return</span> retval;
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the metadata for a macro by index (null if no macro with that index)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> getInfo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">idx</span>) </span>{
	<span class="hljs-keyword">var</span> macro = get(idx);
	<span class="hljs-keyword">if</span>(macro) {
		<span class="hljs-keyword">return</span> 	{
			<span class="hljs-string">'name'</span> : macro.name,
			<span class="hljs-string">'description'</span> : macro.description,
			<span class="hljs-string">'enabled'</span> : macro.enabled,
			<span class="hljs-string">'type'</span> : macro.type,
			<span class="hljs-string">'index'</span> : <span class="hljs-built_in">parseInt</span>(macro.index)
		}
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; 
	}
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Retrieve a macro by index</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">idx</span>) </span>{
	<span class="hljs-keyword">return</span> macros[idx] || <span class="hljs-literal">null</span>;
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Run a macro by index.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> run = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">idx</span>) </span>{
	<span class="hljs-keyword">var</span> machine = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./machine'</span>).machine;
	<span class="hljs-keyword">var</span> bypassInterlock = <span class="hljs-literal">false</span>;
	info = macros[idx];
	<span class="hljs-built_in">console</span>.log(idx);
	<span class="hljs-built_in">console</span>.log(info);
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">parseInt</span>(idx) === <span class="hljs-number">2</span> ){
		bypassInterlock = <span class="hljs-literal">true</span>;
	}
	<span class="hljs-keyword">if</span>(info) {
			machine.runFile(info.filename, bypassInterlock);
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"No such macro."</span>)
	}
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Delete a macro by index
callback returns an error only</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> del = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">idx, callback</span>) </span>{
	info = macros[idx];
	<span class="hljs-keyword">if</span>(info) {
		_deleteMacroFile(idx, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
			<span class="hljs-keyword">if</span>(err) {
				callback(err);
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">delete</span> macros[idx];
				callback(<span class="hljs-literal">null</span>);
			}
		});
	} <span class="hljs-keyword">else</span> {
		callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No such macro: '</span> + idx))
	}
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Copy macros from the current profile to the macros directory.
Only copies macros if they do not exist.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> loadProfileMacros = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
	<span class="hljs-keyword">var</span> installedMacrosDir = config.getDataDir(<span class="hljs-string">'macros'</span>);
	<span class="hljs-keyword">var</span> profileMacrosDir = config.getProfileDir(<span class="hljs-string">'macros'</span>);
	<span class="hljs-keyword">var</span> copyIfNotExists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, callback</span>) </span>{
		<span class="hljs-keyword">var</span> a = path.join(profileMacrosDir, fn);
		<span class="hljs-keyword">var</span> b = path.join(installedMacrosDir, fn);
		fs.stat(b, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, stats</span>) </span>{
			<span class="hljs-keyword">if</span>(!err &amp;&amp; stats.isFile()) {
				log.debug(<span class="hljs-string">'Not Copying '</span> + a + <span class="hljs-string">' -&gt; '</span> + b + <span class="hljs-string">' because it already exists.'</span>);					
				callback();
			} <span class="hljs-keyword">else</span> {
				log.debug(<span class="hljs-string">'Copying '</span> + a + <span class="hljs-string">' -&gt; '</span> + b + <span class="hljs-string">' because it doesnt already exist.'</span>);
				fs.copy(a,b, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) </span>{
					callback(err);
				});
			}
		});
	}

	fs.readdir(profileMacrosDir, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, files</span>) </span>{
		<span class="hljs-keyword">if</span>(err) { <span class="hljs-keyword">return</span> callback(err); }
		<span class="hljs-keyword">async</span>.map(files, copyIfNotExists, callback);
	})
}

exports.load = load;
exports.list = list;
exports.get = get;
exports.del = del;
exports.run = run;
exports.getInfo = getInfo;
exports.update = update;
exports.save = save;
exports.loadProfile = loadProfileMacros;</div></div></div></div></body></html>
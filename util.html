<!DOCTYPE html><html lang="en"><head><title>util</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="util"><meta name="groc-project-path" content="util.js"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path">util.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>util.js</p>
<p>This module is full of functions that are of general interest.</p>
<p>Note that this function bears the same name as node&#39;s built-in util module.
This one is require()d with require(&#39;./util&#39;) while the built-in one with require(&#39;util&#39;)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">var</span> log = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./log'</span>).logger(<span class="hljs-string">'util'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> q = <span class="hljs-built_in">require</span>(<span class="hljs-string">'q'</span>);
<span class="hljs-keyword">var</span> uuid = <span class="hljs-built_in">require</span>(<span class="hljs-string">'node-uuid'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> escapeRE = <span class="hljs-built_in">require</span>(<span class="hljs-string">'escape-regexp-component'</span>);
<span class="hljs-keyword">var</span> exec = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).exec;
<span class="hljs-keyword">var</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);
<span class="hljs-keyword">var</span> mime = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mime'</span>);
<span class="hljs-keyword">var</span> restify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'restify'</span>);
<span class="hljs-keyword">var</span> errors = <span class="hljs-built_in">require</span>(<span class="hljs-string">'restify'</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>These are consulted by various upload functions</p></div></div><div class="code"><div class="wrapper">ALLOWED_EXTENSIONS = [<span class="hljs-string">'.nc'</span>,<span class="hljs-string">'.g'</span>,<span class="hljs-string">'.sbp'</span>,<span class="hljs-string">'.gc'</span>,<span class="hljs-string">'.gcode'</span>];
ALLOWED_APP_EXTENSIONS = [<span class="hljs-string">'.zip'</span>, <span class="hljs-string">'.fma'</span>];

GCODE_EXTENSIONS = [<span class="hljs-string">'.nc'</span>,<span class="hljs-string">'.g'</span>,<span class="hljs-string">'.gc'</span>,<span class="hljs-string">'.gcode'</span>];
OPENSBP_EXTENSIONS = [<span class="hljs-string">'.sbp'</span>, <span class="hljs-string">'.sbc'</span>];

<span class="hljs-keyword">var</span> MethodNotAllowedError = errors.MethodNotAllowedError;
<span class="hljs-keyword">var</span> NotAuthorizedError = errors.NotAuthorizedError;
<span class="hljs-keyword">var</span> ResourceNotFoundError = errors.ResourceNotFoundError;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listify</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {
        <span class="hljs-keyword">return</span> x;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> [x];
    }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Execute a command in the shell
  callback - gets the output of the command (stdout)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doshell</span>(<span class="hljs-params">command, callback</span>)</span>{
    exec(command, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, stdout, stderr</span>) </span>{
        callback(stdout);
    });
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call the &#39;sync&#39; function (linux)
Careful - this function waits for a second before returning</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diskSync</span>(<span class="hljs-params">callback</span>) </span>{
    doshell(<span class="hljs-string">'sync'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
	setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		callback();
	}, <span class="hljs-number">1000</span>);		
    });
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extend an object with the properties of another object.
force - If true, create new keys in a if they do not already exist.  Otherwise, don&#39;t.
Example:
  extend( {a:1,b:2,c:{d:3}}, {a:2,c:{d:4}}) = {a:2,b:2,c:{d:4}}</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>(<span class="hljs-params">a,b, force</span>) </span>{
    <span class="hljs-keyword">for</span>(k <span class="hljs-keyword">in</span> b) {
        <span class="hljs-keyword">if</span>(a.hasOwnProperty(k) || force) {
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> b[k] === <span class="hljs-string">'object'</span> &amp;&amp; b[k] !== <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> a[k] === <span class="hljs-string">'object'</span> &amp;&amp; a[k] !== <span class="hljs-literal">null</span>) {
                    extend(a[k], b[k], force);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span>(force) {
                        a[k] = b[k];
                    } <span class="hljs-keyword">else</span> {
                        log.warn(<span class="hljs-string">'Object format error in extend.'</span>);
                    }
                }
            } <span class="hljs-keyword">else</span> {
                a[k] = b[k];
            }
        }
    }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return the filename given a full path
TODO - this seems senseless - can&#39;t we just use the path module where needed?</p></div></div><div class="code"><div class="wrapper">exports.filename = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pathname</span>) </span>{
    parts = pathname.split(path.sep);
    <span class="hljs-keyword">return</span> parts[parts.legnth-<span class="hljs-number">1</span>];
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create and return a unique filename with the same extension as the provided filename
  filename - an existing filename whose extension will be copied for the new filename
   Example: 
     createUniqueFilename(&#39;/opt/fabmo/example.sbp&#39;) -&gt; &#39;12345.sbp&#39;</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> createUniqueFilename = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">filename</span>) </span>{
    <span class="hljs-keyword">var</span> extension = (<span class="hljs-regexp">/[.]/</span>.exec(filename)) ? <span class="hljs-regexp">/[^.]+$/</span>.exec(filename) : <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">return</span> uuid.v1() + (extension ? (<span class="hljs-string">'.'</span> + extension) : <span class="hljs-string">''</span>);
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Simple queue, faster than using array.shift
Example: 
   var q = new Queue()
   q.enqueue(&#39;a&#39;)
   q.enqueue(&#39;b&#39;)
   q.enqueue(&#39;c&#39;)</p>
<p>   q.dequeue() -&gt; &#39;a&#39;
   q.multiDequeue(2) -&gt; [&#39;b&#39;,&#39;c&#39;]</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span>(<span class="hljs-params"></span>)</span>{

  <span class="hljs-keyword">var</span> queue  = [];
  <span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">this</span>.getLength = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> (queue.length - offset); };
  <span class="hljs-keyword">this</span>.getContents = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> queue; };
  <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> (queue.length === <span class="hljs-number">0</span>); };
  <span class="hljs-keyword">this</span>.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{ queue.push(item); };
  <span class="hljs-keyword">this</span>.multiEnqueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">iterable</span>) </span>{
    iterable.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
      queue.push(item);
    });
  }
  <span class="hljs-keyword">this</span>.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if the queue is empty, return immediately</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (queue.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>store the item at the front of the queue</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> item = queue[offset];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>increment the offset and remove the free space if necessary</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (++ offset * <span class="hljs-number">2</span> &gt;= queue.length){
      queue  = queue.slice(offset);
      offset = <span class="hljs-number">0</span>;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return the dequeued item</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">return</span> item;

  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return up to count items from the queue (in the order they would be retrieved if dequeued)
  count - The number of items to return
          Note: If there are fewer than the number of requested items in the queue
                all items in the queue will be returned.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">this</span>.multiDequeue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">count</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If asking for more items than are in the queue, return everything</p></div></div><div class="code"><div class="wrapper">    count = count &gt; queue.length ? queue.length : count;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>store the item at the front of the queue</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> items = queue.slice(offset, offset+count);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>add to the offset and remove the free space if necessary</p></div></div><div class="code"><div class="wrapper">    offset += count;
    <span class="hljs-keyword">if</span> (offset * <span class="hljs-number">2</span> &gt;= queue.length){
      queue  = queue.slice(offset);
      offset = <span class="hljs-number">0</span>;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return the dequeued item</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">return</span> items;

  };

  <span class="hljs-keyword">this</span>.peek = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> (queue.length &gt; <span class="hljs-number">0</span> ? queue[offset] : <span class="hljs-literal">undefined</span>);
  };
  <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
	queue = [];
	offset = <span class="hljs-number">0</span>;
	};
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return true if this is an allowable NC file
TODO - this sort of functionality should really be moved to the runtimes
TODO - function name should be camel case in keeping with coding conventions</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">allowed_file</span>(<span class="hljs-params">filename</span>)</span>{
    <span class="hljs-keyword">return</span> isGCodeFile(filename) || isOpenSBPFile(filename);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isGCodeFile</span>(<span class="hljs-params">pathname</span>) </span>{
    <span class="hljs-keyword">return</span> (GCODE_EXTENSIONS.indexOf(path.extname(pathname).toLowerCase()) !== -<span class="hljs-number">1</span>)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isOpenSBPFile</span>(<span class="hljs-params">pathname</span>) </span>{
    <span class="hljs-keyword">return</span> (OPENSBP_EXTENSIONS.indexOf(path.extname(pathname).toLowerCase()) !== -<span class="hljs-number">1</span>)
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return true if this is an allowable file to contain an app.
TODO - This check should live in the app manager, really.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">allowedAppFile</span>(<span class="hljs-params">filename</span>) </span>{
  <span class="hljs-keyword">if</span> (ALLOWED_APP_EXTENSIONS.indexOf(path.extname(filename).toLowerCase()) !== -<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Move a file from src to dest, avoiding cross-device rename failures.
This method will first try fs.rename and call the supplied callback if it succeeds. Otherwise
it will pipe the conent of src into dest and unlink src upon completion.</p>
<p>This might take a little more time than a single fs.rename, but it avoids error when
trying to rename files from one device to the other.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> move = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">src, dest, cb</span>) </span>{
	<span class="hljs-keyword">var</span> renameDeferred = q.defer();

	fs.rename(src, dest, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
		<span class="hljs-keyword">if</span> (err) {
			renameDeferred.reject(err);
		}
		<span class="hljs-keyword">else</span> {
			renameDeferred.resolve();
		}
	});

	renameDeferred.promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>rename worked</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> cb(<span class="hljs-literal">null</span>);
	}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{

		log.warn(<span class="hljs-string">'io.move: standard rename failed, trying stream pipe... ('</span> + err + <span class="hljs-string">')'</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>rename didn&#39;t work, try pumping</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> is = fs.createReadStream(src),
			os = fs.createWriteStream(dest);

		is.pipe(os);

		is.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
			fs.unlinkSync(src);
			cb(<span class="hljs-literal">null</span>);
		});

		is.on(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
			<span class="hljs-keyword">return</span> cb(err);
		});

		os.on(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
			<span class="hljs-keyword">return</span> cb(err);
		});
	});
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serveStatic</span>(<span class="hljs-params">opts</span>) </span>{
    opts = opts || {};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>assert.object(opts, &#39;options&#39;);
assert.string(opts.directory, &#39;options.directory&#39;);
assert.optionalNumber(opts.maxAge, &#39;options.maxAge&#39;);
assert.optionalObject(opts.match, &#39;options.match&#39;);
assert.optionalString(opts.charSet, &#39;options.charSet&#39;);</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> p = path.normalize(opts.directory).replace(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">'/'</span>);
    <span class="hljs-keyword">var</span> re = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^'</span> + escapeRE(p) + <span class="hljs-string">'/?.*'</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serveFileFromStats</span>(<span class="hljs-params">file, err, stats, isGzip, req, res, next</span>) </span>{
        <span class="hljs-keyword">if</span> (err) {
            next(<span class="hljs-keyword">new</span> ResourceNotFoundError(err,
                req.path()));
            <span class="hljs-keyword">return</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!stats.isFile()) {
            next(<span class="hljs-keyword">new</span> ResourceNotFoundError(<span class="hljs-string">'%s does not exist'</span>, req.path()));
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (res.handledGzip &amp;&amp; isGzip) {
            res.handledGzip();
        }

        <span class="hljs-keyword">var</span> fstream = fs.createReadStream(file + (isGzip ? <span class="hljs-string">'.gz'</span> : <span class="hljs-string">''</span>));
        <span class="hljs-keyword">var</span> maxAge = opts.maxAge === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">3600</span> : opts.maxAge;
        fstream.once(<span class="hljs-string">'open'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fd</span>) </span>{
            res.cache({maxAge: maxAge});
            res.set(<span class="hljs-string">'Content-Length'</span>, stats.size);
            res.set(<span class="hljs-string">'Content-Type'</span>, mime.lookup(file));
            res.set(<span class="hljs-string">'Last-Modified'</span>, stats.mtime);
            <span class="hljs-keyword">if</span> (opts.charSet) {
                <span class="hljs-keyword">var</span> type = res.getHeader(<span class="hljs-string">'Content-Type'</span>) +
                    <span class="hljs-string">'; charset='</span> + opts.charSet;
                res.setHeader(<span class="hljs-string">'Content-Type'</span>, type);
            }
            <span class="hljs-keyword">if</span> (opts.etag) {
                res.set(<span class="hljs-string">'ETag'</span>, opts.etag(stats, opts));
            }
            res.writeHead(<span class="hljs-number">200</span>);
            fstream.pipe(res);
            fstream.once(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                next(<span class="hljs-literal">false</span>);
            });
        });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serveNormal</span>(<span class="hljs-params">file, req, res, next</span>) </span>{
        fs.stat(file, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, stats</span>) </span>{
            <span class="hljs-keyword">if</span> (!err &amp;&amp; stats.isDirectory() &amp;&amp; opts.default) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Serve an index.html page or similar</p></div></div><div class="code"><div class="wrapper">                file = path.join(file, opts.default);
                fs.stat(file, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dirErr, dirStats</span>) </span>{
                    serveFileFromStats(file,
                        dirErr,
                        dirStats,
                        <span class="hljs-literal">false</span>,
                        req,
                        res,
                        next);
                });
            } <span class="hljs-keyword">else</span> {
                serveFileFromStats(file,
                    err,
                    stats,
                    <span class="hljs-literal">false</span>,
                    req,
                    res,
                    next);
            }
        });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serve</span>(<span class="hljs-params">req, res, next</span>) </span>{
        <span class="hljs-keyword">var</span> uricomp = <span class="hljs-built_in">decodeURIComponent</span>(req.path());
        <span class="hljs-keyword">var</span> file = path.join(opts.directory, uricomp);

        <span class="hljs-keyword">if</span> (req.method !== <span class="hljs-string">'GET'</span> &amp;&amp; req.method !== <span class="hljs-string">'HEAD'</span>) {
            next(<span class="hljs-keyword">new</span> MethodNotAllowedError(req.method));
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (!re.test(file.replace(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">'/'</span>))) {
            next(<span class="hljs-keyword">new</span> NotAuthorizedError(req.path()));
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (opts.match &amp;&amp; !opts.match.test(file)) {
            next(<span class="hljs-keyword">new</span> NotAuthorizedError(req.path()));
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (opts.gzip &amp;&amp; req.acceptsEncoding(<span class="hljs-string">'gzip'</span>)) {
            fs.stat(file + <span class="hljs-string">'.gz'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, stats</span>) </span>{
                <span class="hljs-keyword">if</span> (!err) {
                    res.setHeader(<span class="hljs-string">'Content-Encoding'</span>, <span class="hljs-string">'gzip'</span>);
                    serveFileFromStats(file,
                        err,
                        stats,
                        <span class="hljs-literal">true</span>,
                        req,
                        res,
                        next);
                } <span class="hljs-keyword">else</span> {
                    serveNormal(file, req, res, next);
                }
            });
        } <span class="hljs-keyword">else</span> {
            serveNormal(file, req, res, next);
        }

    }

    <span class="hljs-keyword">return</span> (serve);
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO better error handling here
TODO bad argument name
Return a tree structure that represents a walk of the specified directory
  filename - The name of the directory to walk ()
Each node in the returned object has the following properties:
    path : The path of the object
    text : The filename only
    name : The filename (again?  TODO: Why?)
    type : &#39;file&#39; for files, &#39;dir&#39; for directories
children : A list of child nodes, if this is a directory</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walkDir</span>(<span class="hljs-params">filename</span>) </span>{
    <span class="hljs-keyword">var</span> stats = fs.lstatSync(filename),
        info = {
            path: filename,
            text: path.basename(filename),
            name: path.basename(filename)
        };

    <span class="hljs-keyword">if</span> (stats.isDirectory()) {
        info.type = <span class="hljs-string">"dir"</span>;
        info.children = fs.readdirSync(filename).map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>) </span>{
            <span class="hljs-keyword">return</span> walkDir(filename + <span class="hljs-string">'/'</span> + child);
        });
    } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Assuming it&#39;s a file. In real life it could be a symlink or
something else!</p></div></div><div class="code"><div class="wrapper">        info.type = <span class="hljs-string">"file"</span>;
        info.children = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> info;
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the size of this file
  path - Path to check
    cb - Callback gets the size as an integer number of bytes, or error
TODO - is this really needed?</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSize</span> (<span class="hljs-params">path, cb</span>) </span>{
    fs.stat(path, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, stats</span>) </span>{
        <span class="hljs-keyword">if</span>(err) {
            cb(err);
        } <span class="hljs-keyword">else</span> {
            cb(<span class="hljs-literal">null</span>, stats.size);
        }
    });
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO: I am pretty sure this function is terrible.
Look at where it&#39;s used, and re-evaluate the need for it.  I think it should be factored out.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fixJSON</span>(<span class="hljs-params">json</span>) </span>{
    <span class="hljs-keyword">var</span> retval = {};

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> json) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> json[key] === <span class="hljs-string">'object'</span>) {
            <span class="hljs-keyword">var</span> value = fixJSON(json[key]);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> value = <span class="hljs-built_in">Number</span>(json[key]);
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span> || <span class="hljs-built_in">isNaN</span>(value)) {
                <span class="hljs-keyword">if</span>(json[key] === <span class="hljs-string">'true'</span>) {
                    value = <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(json[key] === <span class="hljs-string">'false'</span>) {
                    value = <span class="hljs-literal">false</span>;
                } <span class="hljs-keyword">else</span> {
                    value = json[key];
                }
            }
        }
        <span class="hljs-keyword">if</span>(key[<span class="hljs-number">0</span>] === <span class="hljs-string">'_'</span>) {
            key = key.slice(<span class="hljs-number">1</span>);
        }
        retval[key] = value;
    }
    <span class="hljs-keyword">return</span> retval;
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Watchdog object
Simple object that keeps a recurring timer that, if it expires, 
will exit the application.  Timer can be refreshed by the reset() method.
Works like a watchdog in an embedded system that resets the CPU if a process runs away.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO:  Not sure that this is currently used, but it doesn&#39;t do anything. (exit stuff commented out)
       I think a more useful watchdog would accept a callback in its constructor, and simply call that
       in the case that it expires. </p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Watchdog</span>(<span class="hljs-params">timeout,exit_code</span>)</span>{
    <span class="hljs-keyword">var</span> watchdog_flag;
    <span class="hljs-keyword">var</span> watchdog_timeout=timeout||<span class="hljs-number">1000</span>;
    <span class="hljs-keyword">var</span> watchdog_exit_code=exit_code||<span class="hljs-number">20</span>;

    watchdog_exit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//throw new Error("G2 is not responding");</span>
        <span class="hljs-comment">//process.exit(this.watchdog_exit_code);</span>
    };

    <span class="hljs-keyword">this</span>.start = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.watchdog_flag===<span class="hljs-literal">undefined</span>){
            <span class="hljs-keyword">this</span>.watchdog_flag=setTimeout(watchdog_exit,watchdog_timeout);
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">this</span>.reset();
        }
    };

    <span class="hljs-keyword">this</span>.stop= <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.watchdog_flag){
            clearTimeout(<span class="hljs-keyword">this</span>.watchdog_flag);
            <span class="hljs-keyword">this</span>.watchdog_flag=<span class="hljs-literal">undefined</span>;
        }
    };

    <span class="hljs-keyword">this</span>.reset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.watchdog_flag){
            clearTimeout(<span class="hljs-keyword">this</span>.watchdog_flag);
            <span class="hljs-keyword">this</span>.watchdog_flag=setTimeout(watchdog_exit,watchdog_timeout);
        }
    };
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convenience function for getting the client IP address from a restify request.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> getClientAddress = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req</span>) </span>{
        <span class="hljs-keyword">return</span> (req.headers[<span class="hljs-string">'x-forwarded-for'</span>] || <span class="hljs-string">''</span>).split(<span class="hljs-string">','</span>)[<span class="hljs-number">0</span>]
        || req.connection.remoteAddress;
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check to see if something is a number (strings that parse to numbers, for example)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> isANumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Number</span>(n);
        <span class="hljs-keyword">return</span> n == n;
    } <span class="hljs-keyword">catch</span>(e) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unit conversion</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> mm2in = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mm</span>) </span>{
  <span class="hljs-keyword">return</span> mm/<span class="hljs-number">25.4</span>;
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unit conversion</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> in2mm = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inch</span>) </span>{
  <span class="hljs-keyword">return</span> inch*<span class="hljs-number">25.4</span>;
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unit type normalizer</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> unitType = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">u</span>) </span>{
  u = <span class="hljs-built_in">String</span>(u).trim().toLowerCase()
  <span class="hljs-keyword">switch</span>(u) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'0'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'in'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'in'</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'1'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'mm'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'mm'</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Invalid unit type specifier: '</span> + u);
      <span class="hljs-keyword">break</span>;
  }
}



<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LineNumberer</span>(<span class="hljs-params">options</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>allow use without new</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> LineNumberer)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LineNumberer(options);
  }
  <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>init Transform</p></div></div><div class="code"><div class="wrapper">  stream.Transform.call(<span class="hljs-keyword">this</span>, options);
}
util.inherits(LineNumberer, stream.Transform);



LineNumberer.prototype._transform = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chunk, enc, next</span>) </span>{
  <span class="hljs-keyword">var</span> data = chunk.toString();
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lastLineData) { data = <span class="hljs-keyword">this</span>._lastLineData + data; }

  <span class="hljs-keyword">var</span> lines = data.split(<span class="hljs-string">'\n'</span>);
  <span class="hljs-keyword">this</span>._lastLineData = lines.splice(lines.length-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];
  block = []
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;lines.length; i++) {
    <span class="hljs-keyword">this</span>.count += <span class="hljs-number">1</span>;
    <span class="hljs-comment">//this.push("N" + this.count + " " + lines[i] + '\n');</span>
    block.push(<span class="hljs-string">"N"</span> + <span class="hljs-keyword">this</span>.count + <span class="hljs-string">" "</span> + lines[i]);
  }

  <span class="hljs-keyword">this</span>.push(block.join(<span class="hljs-string">'\n'</span>))
  next();
};

LineNumberer.prototype._flush = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">done</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lastLineData) { <span class="hljs-keyword">this</span>.push(<span class="hljs-keyword">this</span>._lastLineData); }
  <span class="hljs-keyword">this</span>._lastLineData = <span class="hljs-literal">null</span>;
  done();
};

<span class="hljs-keyword">var</span> countLineNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">filename, callback</span>) </span>{
    <span class="hljs-keyword">var</span> i;
    <span class="hljs-keyword">var</span> lines = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).createReadStream(filename)
      .on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>) </span>{
        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i &lt; chunk.length; ++i)
          <span class="hljs-keyword">if</span> (chunk[i] == <span class="hljs-number">10</span>) lines++;
      })
      .on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        callback(<span class="hljs-literal">null</span>, lines)
      });
}

exports.countLineNumbers = countLineNumbers;
exports.LineNumberer = LineNumberer;


exports.serveStatic = serveStatic;
exports.getSize = getSize;
exports.Queue = Queue;
exports.Watchdog = Watchdog;
exports.allowed_file = allowed_file;
exports.allowedAppFile = allowedAppFile;
exports.move = move;
exports.walkDir = walkDir;
exports.createUniqueFilename = createUniqueFilename;
exports.fixJSON = fixJSON;
exports.extend = extend;
exports.doshell = doshell;
exports.getClientAddress = getClientAddress;
exports.isANumber = isANumber;
exports.in2mm = in2mm;
exports.mm2in = mm2in;
exports.unitType = unitType;
exports.diskSync = diskSync;</div></div></div></div></body></html>